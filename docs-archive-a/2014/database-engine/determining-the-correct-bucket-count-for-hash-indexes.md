---
title: Détermination du nombre de compartiments correct pour les index de hachage | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 6d1ac280-87db-4bd8-ad43-54353647d8b5
author: stevestein
ms.author: sstein
ms.openlocfilehash: e0579a98e3302b6944f68ca449d3e7cda0ecc01d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87603003"
---
# <a name="determining-the-correct-bucket-count-for-hash-indexes"></a><span data-ttu-id="28723-102">Déterminer le nombre de compartiments correct pour les index de hachage</span><span class="sxs-lookup"><span data-stu-id="28723-102">Determining the Correct Bucket Count for Hash Indexes</span></span>
  <span data-ttu-id="28723-103">Vous devez spécifier une valeur pour le paramètre `BUCKET_COUNT` lorsque vous créez la table mémoire optimisée.</span><span class="sxs-lookup"><span data-stu-id="28723-103">You must specify a value for the `BUCKET_COUNT` parameter when you create the memory-optimized table.</span></span> <span data-ttu-id="28723-104">Cette rubrique fournit des recommandations pour déterminer la valeur appropriée du paramètre `BUCKET_COUNT`.</span><span class="sxs-lookup"><span data-stu-id="28723-104">This topic makes recommendations for determining the appropriate value for the `BUCKET_COUNT` parameter.</span></span> <span data-ttu-id="28723-105">Si vous ne pouvez pas déterminer le nombre de compartiments correct, utilisez un index non cluster à la place.</span><span class="sxs-lookup"><span data-stu-id="28723-105">If you cannot determine the correct bucket count, use a nonclustered index instead.</span></span>  <span data-ttu-id="28723-106">Une valeur `BUCKET_COUNT` incorrecte, en particulier une valeur trop basse, peut avoir un impact important sur les performances de la charge de travail, ainsi que sur le temps de récupération de la base de données.</span><span class="sxs-lookup"><span data-stu-id="28723-106">An incorrect `BUCKET_COUNT` value, especially one that is too low, can significantly impact workload performance, as well as recovery time of the database.</span></span> <span data-ttu-id="28723-107">Il vaut mieux surestimer le nombre de compartiments.</span><span class="sxs-lookup"><span data-stu-id="28723-107">It is better to overestimate the bucket count.</span></span>  
  
 <span data-ttu-id="28723-108">Les clés d'index dupliquées peuvent réduire les performances avec un index hach car elles sont hachées dans le même compartiment, ce qui entraîne l'augmentation de la chaîne du compartiment.</span><span class="sxs-lookup"><span data-stu-id="28723-108">Duplicate index keys can decrease performance with a hash index because the keys are hashed to the same bucket, causing that bucket's chain to increase.</span></span>  
  
 <span data-ttu-id="28723-109">Pour plus d'informations sur les index de hachage non cluster, consultez [Hash Indexes](hash-indexes.md) et [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="28723-109">For more information about nonclustered hash indexes, see [Hash Indexes](hash-indexes.md) and [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="28723-110">Une table de hachage est allouée pour chaque index de hachage sur une table mémoire optimisée.</span><span class="sxs-lookup"><span data-stu-id="28723-110">One hash table is allocated for each hash index on a memory-optimized table.</span></span> <span data-ttu-id="28723-111">La taille de la table de hachage allouée pour un index est spécifiée par le `BUCKET_COUNT` paramètre dans [Create table &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) ou [Create type &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="28723-111">The size of the hash table allocated for an index is specified by the `BUCKET_COUNT` parameter in [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) or [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span></span> <span data-ttu-id="28723-112">Le nombre de compartiment est arrondi en interne à la puissance de 2 suivante.</span><span class="sxs-lookup"><span data-stu-id="28723-112">The bucket count will internally be rounded up to the next power of two.</span></span> <span data-ttu-id="28723-113">Par exemple, la spécification d'un nombre de compartiments égal à 300 000 créera un nombre réel de compartiments égal à 524 288.</span><span class="sxs-lookup"><span data-stu-id="28723-113">For example, specifying a bucket count of 300,000 will result in an actual bucket count of 524,288.</span></span>  
  
 <span data-ttu-id="28723-114">Pour accéder à un article et à une vidéo sur le nombre de compartiments, consultez [How to determine the right bucket count for hash indexes (In-Memory OLTP)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span><span class="sxs-lookup"><span data-stu-id="28723-114">For links to an article and video on bucket count, see [How to determine the right bucket count for hash indexes (In-Memory OLTP)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span></span>  
  
## <a name="recommendations"></a><span data-ttu-id="28723-115">Recommandations</span><span class="sxs-lookup"><span data-stu-id="28723-115">Recommendations</span></span>  
 <span data-ttu-id="28723-116">Dans la plupart des cas, le nombre de compartiments doit être compris entre 1 et 2 fois par le nombre estimé maximal de valeurs distinctes dans la clé d'index.</span><span class="sxs-lookup"><span data-stu-id="28723-116">In most cases the bucket count should be between 1 and 2 times the number of distinct values in the index key.</span></span> <span data-ttu-id="28723-117">Si la clé d'index contient de nombreuses valeurs dupliquées (en moyenne il y a plus de 10 lignes pour chaque valeur de clé d'index), utilisez un index non cluster à la place</span><span class="sxs-lookup"><span data-stu-id="28723-117">If the index key contains a lot of duplicate values, on average there are more than 10 rows for each index key value, use a nonclustered index instead</span></span>  
  
 <span data-ttu-id="28723-118">Vous ne pouvez pas toujours prédire le nombre exact de valeurs qu'une clé d'index donnée peut avoir ou aura.</span><span class="sxs-lookup"><span data-stu-id="28723-118">You may not always be able to predict how many values a particular index key may have or will have.</span></span> <span data-ttu-id="28723-119">Les performances doivent être acceptables si la valeur `BUCKET_COUNT` est inférieure ou égale à 5 fois le nombre réel de valeurs de clés.</span><span class="sxs-lookup"><span data-stu-id="28723-119">Performance should be acceptable if the `BUCKET_COUNT` value is within 5 times of the actual number of key values.</span></span>  
  
 <span data-ttu-id="28723-120">Pour déterminer le nombre de clés d'index uniques dans les données existantes, utilisez des requêtes similaires aux exemples suivants :</span><span class="sxs-lookup"><span data-stu-id="28723-120">To determine the number of unique index keys in existing data, use queries similar to the following examples:</span></span>  
  
### <a name="primary-key-and-unique-indexes"></a><span data-ttu-id="28723-121">Clé primaire et index uniques</span><span class="sxs-lookup"><span data-stu-id="28723-121">Primary Key and Unique Indexes</span></span>  
 <span data-ttu-id="28723-122">Étant donné que l'index de clé primaire est unique, le nombre de valeurs distinctes dans la clé correspond au nombre de lignes dans la table.</span><span class="sxs-lookup"><span data-stu-id="28723-122">Because the primary key index is unique, the number of distinct values in the key corresponds to the number of rows in the table.</span></span> <span data-ttu-id="28723-123">Pour obtenir un exemple de clé primaire sur (SalesOrderID, SalesOrderDetailID) dans la table Sales.SalesOrderDetail dans la base de données AdventureWorks, exécutez la requête suivante pour calculer le nombre de valeurs de clé primaire distinctes, qui correspond au nombre de lignes dans la table :</span><span class="sxs-lookup"><span data-stu-id="28723-123">For an example primary key on (SalesOrderID, SalesOrderDetailID) in the table Sales.SalesOrderDetail in the AdventureWorks database, issue the following query to calculate the number of distinct primary key values, which corresponds to the number of rows in the table:</span></span>  
  
```sql  
SELECT COUNT(*) AS [row count]   
FROM Sales.SalesOrderDetail  
```  
  
 <span data-ttu-id="28723-124">Cette requête affiche un nombre de lignes égal à 121 317.</span><span class="sxs-lookup"><span data-stu-id="28723-124">This query shows a row count of 121,317.</span></span> <span data-ttu-id="28723-125">Utilisez un nombre de compartiments de 240 000 si le nombre de lignes ne va pas changer de manière significative.</span><span class="sxs-lookup"><span data-stu-id="28723-125">Use a bucket count of 240,000 if the row count will not change significantly.</span></span> <span data-ttu-id="28723-126">Utilisez un nombre de compartiments de 480 000 si le nombre de commandes client dans la table va quadrupler.</span><span class="sxs-lookup"><span data-stu-id="28723-126">Use a bucket count of 480,000 if the number of sales orders in the table is expected to quadruple.</span></span>  
  
### <a name="non-unique-indexes"></a><span data-ttu-id="28723-127">Index non uniques</span><span class="sxs-lookup"><span data-stu-id="28723-127">Non-Unique Indexes</span></span>  
 <span data-ttu-id="28723-128">Pour les autres index, par exemple un index à plusieurs colonnes sur (SpecialOfferID, ProductID), exécutez la requête suivante pour déterminer le nombre de valeurs de clé d'index uniques :</span><span class="sxs-lookup"><span data-stu-id="28723-128">For other indexes, for example a multi-column index on (SpecialOfferID, ProductID), issue the following query to determine the number of unique index key values:</span></span>  
  
```sql  
SELECT COUNT(*) AS [SpecialOfferID_ProductID index key count]  
FROM   
   (SELECT DISTINCT SpecialOfferID, ProductID   
    FROM Sales.SalesOrderDetail) t  
```  
  
 <span data-ttu-id="28723-129">Cette requête retourne un nombre de clés d'index (pour SpecialOfferID, ProductID) de 484, indiquant qu'un index non cluster doit être utilisé à la place d'un index hach non cluster.</span><span class="sxs-lookup"><span data-stu-id="28723-129">This query returns an index key count for (SpecialOfferID, ProductID) of 484, indicating a that a nonclustered index should be used instead of a nonclustered hash index.</span></span>  
  
### <a name="determining-the-number-of-duplicates"></a><span data-ttu-id="28723-130">Détermination du nombre de doublons</span><span class="sxs-lookup"><span data-stu-id="28723-130">Determining the Number of Duplicates</span></span>  
 <span data-ttu-id="28723-131">Pour déterminer le nombre moyen de valeurs dupliquées pour une valeur de clé d'index, divisez le nombre total de lignes par le nombre de clés d'index uniques.</span><span class="sxs-lookup"><span data-stu-id="28723-131">To determine the average number of duplicate values for an index key value, divide the total number of rows by the number of unique index keys.</span></span>  
  
 <span data-ttu-id="28723-132">Pour l'exemple d'index sur (SpecialOfferID, ProductID), cela aboutit à 121317 / 484 = 251.</span><span class="sxs-lookup"><span data-stu-id="28723-132">For the example index on (SpecialOfferID, ProductID), this leads to 121317 / 484 = 251.</span></span> <span data-ttu-id="28723-133">Cela signifie que les valeurs de clé d'index ont une moyenne de 251, par conséquent, ceci doit être un index non cluster.</span><span class="sxs-lookup"><span data-stu-id="28723-133">This means index key values have an average of 251, and thus this should be a nonclustered index.</span></span>  
  
## <a name="troubleshooting-the-bucket-count"></a><span data-ttu-id="28723-134">Résolution des problèmes liés au nombre de compartiments</span><span class="sxs-lookup"><span data-stu-id="28723-134">Troubleshooting the Bucket Count</span></span>  
 <span data-ttu-id="28723-135">Pour résoudre les problèmes liés au nombre de compartiments dans les tables optimisées en mémoire, utilisez [sys. dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) pour obtenir des statistiques sur les compartiments vides et la longueur des chaînes de lignes.</span><span class="sxs-lookup"><span data-stu-id="28723-135">To troubleshoot bucket count issues in memory-optimized tables, use [sys.dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) to obtain statistics about the empty buckets and the length of row chains.</span></span> <span data-ttu-id="28723-136">La requête suivante peut être utilisée pour obtenir les statistiques sur tous les index de hachage dans la base de données active.</span><span class="sxs-lookup"><span data-stu-id="28723-136">The following query can be used to obtain statistics about all the hash indexes in the current database.</span></span> <span data-ttu-id="28723-137">Son exécution peut prendre plusieurs minutes s'il existe de grandes tables dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="28723-137">The query can take several minutes to run if there are large tables in the database.</span></span>  
  
```sql  
SELECT   
   object_name(hs.object_id) AS 'object name',   
   i.name as 'index name',   
   hs.total_bucket_count,  
   hs.empty_bucket_count,  
   floor((cast(empty_bucket_count as float)/total_bucket_count) * 100) AS 'empty_bucket_percent',  
   hs.avg_chain_length,   
   hs.max_chain_length  
FROM sys.dm_db_xtp_hash_index_stats AS hs   
   JOIN sys.indexes AS i   
   ON hs.object_id=i.object_id AND hs.index_id=i.index_id  
```  
  
 <span data-ttu-id="28723-138">Les deux indicateurs clés d'intégrité d'index de hachage sont :</span><span class="sxs-lookup"><span data-stu-id="28723-138">The two key indicators of hash index health are:</span></span>  
  
 <span data-ttu-id="28723-139">*empty_bucket_percent*</span><span class="sxs-lookup"><span data-stu-id="28723-139">*empty_bucket_percent*</span></span>  
 <span data-ttu-id="28723-140">*empty_bucket_percent* indique le nombre de compartiments vides dans l'index de hachage.</span><span class="sxs-lookup"><span data-stu-id="28723-140">*empty_bucket_percent* indicates the number of empty buckets in the hash index.</span></span>  
  
 <span data-ttu-id="28723-141">Si *empty_bucket_percent* est inférieur à 10 pour cent, le nombre de compartiments est probablement trop bas.</span><span class="sxs-lookup"><span data-stu-id="28723-141">If *empty_bucket_percent* is less than 10 percent, the bucket count is likely to be too low.</span></span> <span data-ttu-id="28723-142">Idéalement, *empty_bucket_percent* devrait être de 33 pour cent ou plus.</span><span class="sxs-lookup"><span data-stu-id="28723-142">Ideally, the *empty_bucket_percent* should be 33 percent or greater.</span></span> <span data-ttu-id="28723-143">Si le nombre de compartiments correspond au nombre de valeurs de clés d'index, environ 1/3 des compartiments est vide, en raison de la distribution du hachage.</span><span class="sxs-lookup"><span data-stu-id="28723-143">If the bucket count matches the number of index key values, about 1/3 of the buckets is empty, due to hash distribution.</span></span>  
  
 <span data-ttu-id="28723-144">*avg_chain_length*</span><span class="sxs-lookup"><span data-stu-id="28723-144">*avg_chain_length*</span></span>  
 <span data-ttu-id="28723-145">*avg_chain_length* indique la longueur maximale des chaînes de ligne dans les compartiments de hachage.</span><span class="sxs-lookup"><span data-stu-id="28723-145">*avg_chain_length* indicates the average length of the row chains in the hash buckets.</span></span>  
  
 <span data-ttu-id="28723-146">Si *avg_chain_length* est supérieur à 10 et *empty_bucket_percent* est supérieur à 10 pour cent, il existe probablement plusieurs valeurs de clé d'index dupliquées et un index non cluster serait plus approprié.</span><span class="sxs-lookup"><span data-stu-id="28723-146">If *avg_chain_length* is greater than 10 and *empty_bucket_percent* is greater than 10 percent, there likely are many duplicate index key values and a nonclustered index would be more appropriate.</span></span> <span data-ttu-id="28723-147">Une longueur de chaîne moyenne de 1 est idéale.</span><span class="sxs-lookup"><span data-stu-id="28723-147">An average chain length of 1 is ideal.</span></span>  
  
 <span data-ttu-id="28723-148">Il y a deux facteurs qui ont un impact sur la longueur de chaîne :</span><span class="sxs-lookup"><span data-stu-id="28723-148">There are two factors that impact the chain length:</span></span>  
  
1.  <span data-ttu-id="28723-149">Les doublons. Toutes les lignes en double font partie de la même chaîne dans l'index hach.</span><span class="sxs-lookup"><span data-stu-id="28723-149">Duplicates; all duplicate rows are part of the same chain in the hash index.</span></span>  
  
2.  <span data-ttu-id="28723-150">Plusieurs valeurs de clés mappent sur le même compartiment.</span><span class="sxs-lookup"><span data-stu-id="28723-150">Multiple key values map to the same bucket.</span></span> <span data-ttu-id="28723-151">Plus le nombre de compartiments est faible, plus il y aura de compartiments qui auront plusieurs valeurs mappées.</span><span class="sxs-lookup"><span data-stu-id="28723-151">The lower the bucket count, the more buckets that will have multiple values mapped to them.</span></span>  
  
 <span data-ttu-id="28723-152">En guise d'exemple, examinez le tableau suivant et le script pour insérer des lignes d'exemple dans la table :</span><span class="sxs-lookup"><span data-stu-id="28723-152">As an example, consider the following table and script to insert sample rows in the table:</span></span>  
  
```sql  
CREATE TABLE [Sales].[SalesOrderHeader_test]  
(  
   [SalesOrderID] [uniqueidentifier] NOT NULL DEFAULT (newid()),  
   [OrderSequence] int NOT NULL,  
   [OrderDate] [datetime2](7) NOT NULL,  
   [Status] [tinyint] NOT NULL,  
  
PRIMARY KEY NONCLUSTERED HASH ([SalesOrderID]) WITH ( BUCKET_COUNT = 262144 ),  
INDEX IX_OrderSequence HASH (OrderSequence) WITH ( BUCKET_COUNT = 20000),  
INDEX IX_Status HASH ([Status]) WITH ( BUCKET_COUNT = 8),  
INDEX IX_OrderDate NONCLUSTERED ([OrderDate] ASC),  
)WITH ( MEMORY_OPTIMIZED = ON , DURABILITY = SCHEMA_AND_DATA )  
GO  
  
DECLARE @i int = 0  
BEGIN TRAN  
WHILE @i < 262144  
BEGIN  
   INSERT Sales.SalesOrderHeader_test (OrderSequence, OrderDate, [Status]) VALUES (@i, sysdatetime(), @i % 8)  
   SET @i += 1  
END  
COMMIT  
GO  
```  
  
 <span data-ttu-id="28723-153">Le script insère 262 144 lignes dans la table.</span><span class="sxs-lookup"><span data-stu-id="28723-153">The script inserts 262,144 rows in the table.</span></span> <span data-ttu-id="28723-154">Il insère des valeurs uniques dans l'index de clé primaire et dans IX_OrderSequence.</span><span class="sxs-lookup"><span data-stu-id="28723-154">It inserts unique values in the primary key index and in IX_OrderSequence.</span></span> <span data-ttu-id="28723-155">Il insère plusieurs valeurs dupliquées dans l'index IX_Status : le script génère uniquement 8 valeurs distinctes.</span><span class="sxs-lookup"><span data-stu-id="28723-155">It inserts a lot of duplicate values in the index IX_Status: the script only generates 8 distinct values.</span></span>  
  
 <span data-ttu-id="28723-156">La sortie de la requête de résolution des problèmes BUCKET_COUNT est la suivante :</span><span class="sxs-lookup"><span data-stu-id="28723-156">The output of the BUCKET_COUNT troubleshooting query is as follows:</span></span>  
  
|<span data-ttu-id="28723-157">nom de l'index</span><span class="sxs-lookup"><span data-stu-id="28723-157">index name</span></span>|<span data-ttu-id="28723-158">total_bucket_count</span><span class="sxs-lookup"><span data-stu-id="28723-158">total_bucket_count</span></span>|<span data-ttu-id="28723-159">empty_bucket_count</span><span class="sxs-lookup"><span data-stu-id="28723-159">empty_bucket_count</span></span>|<span data-ttu-id="28723-160">empty_bucket_percent</span><span class="sxs-lookup"><span data-stu-id="28723-160">empty_bucket_percent</span></span>|<span data-ttu-id="28723-161">avg_chain_length</span><span class="sxs-lookup"><span data-stu-id="28723-161">avg_chain_length</span></span>|<span data-ttu-id="28723-162">max_chain_length</span><span class="sxs-lookup"><span data-stu-id="28723-162">max_chain_length</span></span>|  
|----------------|--------------------------|--------------------------|----------------------------|------------------------|------------------------|  
|<span data-ttu-id="28723-163">IX_Status</span><span class="sxs-lookup"><span data-stu-id="28723-163">IX_Status</span></span>|<span data-ttu-id="28723-164">8</span><span class="sxs-lookup"><span data-stu-id="28723-164">8</span></span>|<span data-ttu-id="28723-165">4</span><span class="sxs-lookup"><span data-stu-id="28723-165">4</span></span>|<span data-ttu-id="28723-166">50</span><span class="sxs-lookup"><span data-stu-id="28723-166">50</span></span>|<span data-ttu-id="28723-167">65536</span><span class="sxs-lookup"><span data-stu-id="28723-167">65536</span></span>|<span data-ttu-id="28723-168">65536</span><span class="sxs-lookup"><span data-stu-id="28723-168">65536</span></span>|  
|<span data-ttu-id="28723-169">IX_OrderSequence</span><span class="sxs-lookup"><span data-stu-id="28723-169">IX_OrderSequence</span></span>|<span data-ttu-id="28723-170">32 768</span><span class="sxs-lookup"><span data-stu-id="28723-170">32768</span></span>|<span data-ttu-id="28723-171">13</span><span class="sxs-lookup"><span data-stu-id="28723-171">13</span></span>|<span data-ttu-id="28723-172">0</span><span class="sxs-lookup"><span data-stu-id="28723-172">0</span></span>|<span data-ttu-id="28723-173">8</span><span class="sxs-lookup"><span data-stu-id="28723-173">8</span></span>|<span data-ttu-id="28723-174">26</span><span class="sxs-lookup"><span data-stu-id="28723-174">26</span></span>|  
|<span data-ttu-id="28723-175">PK_SalesOrd_B14003C3F8FB3364</span><span class="sxs-lookup"><span data-stu-id="28723-175">PK_SalesOrd_B14003C3F8FB3364</span></span>|<span data-ttu-id="28723-176">262 144</span><span class="sxs-lookup"><span data-stu-id="28723-176">262144</span></span>|<span data-ttu-id="28723-177">96319</span><span class="sxs-lookup"><span data-stu-id="28723-177">96319</span></span>|<span data-ttu-id="28723-178">36</span><span class="sxs-lookup"><span data-stu-id="28723-178">36</span></span>|<span data-ttu-id="28723-179">1</span><span class="sxs-lookup"><span data-stu-id="28723-179">1</span></span>|<span data-ttu-id="28723-180">8</span><span class="sxs-lookup"><span data-stu-id="28723-180">8</span></span>|  
  
 <span data-ttu-id="28723-181">Considérez les trois index de hachage sur cette table :</span><span class="sxs-lookup"><span data-stu-id="28723-181">Consider the three hash indexes on this table:</span></span>  
  
-   <span data-ttu-id="28723-182">IX_Status : 50 pour cent des compartiments sont vides, ce qui est correct.</span><span class="sxs-lookup"><span data-stu-id="28723-182">IX_Status: 50 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="28723-183">Cependant, la longueur de chaîne moyenne est très élevée (65 536).</span><span class="sxs-lookup"><span data-stu-id="28723-183">However, the average chain length is very high (65,536).</span></span> <span data-ttu-id="28723-184">Cela indique un grand nombre de valeurs dupliquées.</span><span class="sxs-lookup"><span data-stu-id="28723-184">This indicates a large number of duplicate values.</span></span> <span data-ttu-id="28723-185">Par conséquent, l'utilisation d'un index de hachage non cluster n'est pas appropriée dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="28723-185">Therefore, using a nonclustered hash index is not appropriate in this case.</span></span> <span data-ttu-id="28723-186">Il convient d'utiliser un index non cluster.</span><span class="sxs-lookup"><span data-stu-id="28723-186">A nonclustered index should be used instead.</span></span>  
  
-   <span data-ttu-id="28723-187">IX_OrderSequence : 0 pour cent des compartiments sont vides, ce qui est trop bas.</span><span class="sxs-lookup"><span data-stu-id="28723-187">IX_OrderSequence: 0 percent of the buckets are empty, which is too low.</span></span> <span data-ttu-id="28723-188">En outre, la longueur de chaîne moyenne est de 8.</span><span class="sxs-lookup"><span data-stu-id="28723-188">In addition, the average chain length is 8.</span></span> <span data-ttu-id="28723-189">En tant donné que les valeurs dans cet index sont uniques, cela signifie que 8 valeurs en moyenne sont mappées à chaque compartiment.</span><span class="sxs-lookup"><span data-stu-id="28723-189">As the values in this index are unique, this means on average 8 values are mapped to each bucket.</span></span> <span data-ttu-id="28723-190">Le nombre de compartiments doit être augmenté.</span><span class="sxs-lookup"><span data-stu-id="28723-190">The bucket count should be increased.</span></span> <span data-ttu-id="28723-191">Étant donné que la clé d'index a 262 144 valeurs uniques, le nombre de compartiments doit être égal ou supérieur à 262 144.</span><span class="sxs-lookup"><span data-stu-id="28723-191">As the index key has 262,144 unique values, the bucket count should be at least 262,144.</span></span> <span data-ttu-id="28723-192">Si une croissance future est attendue, le nombre doit être supérieur.</span><span class="sxs-lookup"><span data-stu-id="28723-192">If future growth is expected, the number should be higher.</span></span>  
  
-   <span data-ttu-id="28723-193">Index de clé primaire (PK__SalesOrder...) : 36% des compartiments sont vides, ce qui est correct.</span><span class="sxs-lookup"><span data-stu-id="28723-193">Primary key index (PK__SalesOrder...): 36 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="28723-194">En outre, la longueur de chaîne moyenne est de 1, ce qui est également correct.</span><span class="sxs-lookup"><span data-stu-id="28723-194">In addition the average chain length is 1, which is also good.</span></span> <span data-ttu-id="28723-195">Aucun changement n'est requis.</span><span class="sxs-lookup"><span data-stu-id="28723-195">No change needed.</span></span>  
  
 <span data-ttu-id="28723-196">Pour plus d'informations sur le dépannage de vos index de hachage mémoire optimisés, consultez [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="28723-196">For more information on troubleshooting issues with your memory-optimized hash indexes, see [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span></span>  
  
## <a name="detailed-considerations-for-further-optimization"></a><span data-ttu-id="28723-197">Observations détaillées pour une meilleure optimisation</span><span class="sxs-lookup"><span data-stu-id="28723-197">Detailed Considerations for Further Optimization</span></span>  
 <span data-ttu-id="28723-198">Cette section décrit d'autres éléments à prendre en considération pour optimiser le nombre de compartiments.</span><span class="sxs-lookup"><span data-stu-id="28723-198">This section outlines further considerations for optimizing the bucket count.</span></span>  
  
 <span data-ttu-id="28723-199">Pour obtenir de meilleures performances pour les index de hachage, équilibrez la quantité de mémoire allouée à la table de hachage et le nombre de valeurs distinctes dans la clé d'index.</span><span class="sxs-lookup"><span data-stu-id="28723-199">To achieve the best performance for hash indexes, balance the amount of memory allocated to the hash table and the number of distinct values in the index key.</span></span> <span data-ttu-id="28723-200">Il existe également un équilibre entre les performances des recherches de points et les analyses de table :</span><span class="sxs-lookup"><span data-stu-id="28723-200">There is also a balance between the performance of point lookups and table scans:</span></span>  
  
-   <span data-ttu-id="28723-201">Plus la valeur du nombre de compartiments est élevée, plus les compartiments vides seront nombreux dans l'index.</span><span class="sxs-lookup"><span data-stu-id="28723-201">The higher the bucket count value, the more empty buckets there will be in the index.</span></span> <span data-ttu-id="28723-202">Cela a un impact sur l'utilisation de la mémoire (8 octets par compartiment) et les performances des analyses de table, car chaque compartiment est analysé dans le cadre d'une analyse de table.</span><span class="sxs-lookup"><span data-stu-id="28723-202">This has an impact on memory usage (8 bytes per bucket) and the performance of table scans, as each bucket is scanned as part of a table scan.</span></span>  
  
-   <span data-ttu-id="28723-203">Plus le nombre de compartiments est faible, plus le nombre de valeurs affectées à un seul compartiment est grand.</span><span class="sxs-lookup"><span data-stu-id="28723-203">The lower the bucket count, the more values are assigned to a single bucket.</span></span> <span data-ttu-id="28723-204">Cela réduit les performances des recherches et des insertions de points, car [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] peut potentiellement parcourir plusieurs valeurs dans un seul compartiment pour trouver la valeur spécifiée par le prédicat de recherche.</span><span class="sxs-lookup"><span data-stu-id="28723-204">This decreases performance for point lookups and inserts, because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] may need to traverse several values in a single bucket to find the value specified by the search predicate.</span></span>  
  
 <span data-ttu-id="28723-205">Si le nombre de compartiments est considérablement inférieur au nombre de clés d'index uniques, plusieurs valeurs mapperont à chaque compartiment.</span><span class="sxs-lookup"><span data-stu-id="28723-205">If the bucket count is significantly lower than the number of unique index keys, many values will map to each bucket.</span></span> <span data-ttu-id="28723-206">Cela dégrade les performances de la plupart des opérations DML, en particulier les recherches de points (recherches de clés d'index individuelles) et des opérations d'insertion.</span><span class="sxs-lookup"><span data-stu-id="28723-206">This degrades performance of most DML operations, particularly point lookups (lookups of individual index keys) and insert operations.</span></span> <span data-ttu-id="28723-207">Par exemple, vous pouvez constater des performances médiocres des requêtes et SELECT et des opérations UPDATE et DELETE avec des prédicats d'égalité correspondant aux colonnes clés d'index dans la clause WHERE.</span><span class="sxs-lookup"><span data-stu-id="28723-207">For example, you may see poor performance of SELECT queries and, UPDATE and DELETE operations with equality predicates matching the index key columns in the WHERE clause.</span></span> <span data-ttu-id="28723-208">Un nombre de compartiments faible affectera également le temps de récupération de la base de données, car les index sont recréés au démarrage de la base de données.</span><span class="sxs-lookup"><span data-stu-id="28723-208">A low bucket count will also affect the recovery time of the database, as the indexes are recreated on database startup.</span></span>  
  
### <a name="duplicate-index-key-values"></a><span data-ttu-id="28723-209">Valeurs de clé d'index dupliquées</span><span class="sxs-lookup"><span data-stu-id="28723-209">Duplicate Index Key Values</span></span>  
 <span data-ttu-id="28723-210">Les valeurs dupliquées peuvent augmenter l'impact des collisions de hachage sur les performances.</span><span class="sxs-lookup"><span data-stu-id="28723-210">Duplicate values can increase the performance impact of hash collisions.</span></span> <span data-ttu-id="28723-211">Cela n'est généralement pas un problème si chaque clé d'index a un nombre faible de doublons.</span><span class="sxs-lookup"><span data-stu-id="28723-211">This is usually not a problem if each index key has a low number of duplicates.</span></span> <span data-ttu-id="28723-212">Mais des problèmes peuvent surgir si l'écart entre le nombre de clés d'index uniques et le nombre de lignes de la table est très grand.</span><span class="sxs-lookup"><span data-stu-id="28723-212">But this can be a problem if the discrepancy between the number of unique index keys and the number of rows in the tables becomes very large.</span></span>  
  
 <span data-ttu-id="28723-213">Toutes les lignes ayant la même clé d'index vont aller dans la même chaîne dupliquée.</span><span class="sxs-lookup"><span data-stu-id="28723-213">All rows with the same index key will go into the same duplicate chain.</span></span> <span data-ttu-id="28723-214">Si plusieurs clés d'index sont dans le même compartiment en raison d'une collision de hachage, les scanneurs d'index doivent toujours analyser la chaîne en double complète pour la première valeur avant de pouvoir localiser la première ligne correspondant à la deuxième valeur.</span><span class="sxs-lookup"><span data-stu-id="28723-214">If multiple index keys are in the same bucket due to a hash collision, index scanners always need to scan the full duplicate chain for the first value before they can locate the first row corresponding to the second value.</span></span> <span data-ttu-id="28723-215">Les clés dupliquées rendent plus difficile la localisation de la ligne par le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="28723-215">Duplicate keys also make it more difficult for garbage collection to locate the row.</span></span> <span data-ttu-id="28723-216">Par exemple, s'il existe 1 000 doublons d'une clé et une des lignes est supprimée, le garbage collector doit analyser la chaîne de 1 000 doublons pour dissocier la ligne de l'index.</span><span class="sxs-lookup"><span data-stu-id="28723-216">For example, if there are 1,000 duplicates for any key and one of the rows is deleted, the garbage collector needs to scan the chain of 1,000 duplicates to unlink the row from the index.</span></span> <span data-ttu-id="28723-217">Cela est vrai même si la requête qui a trouvé la suppression a utilisé un index plus efficace (un index de clé primaire) pour localiser la ligne, car le garbage collector doit dissocier de chaque index.</span><span class="sxs-lookup"><span data-stu-id="28723-217">This is true even if the query that found the delete used a more efficient index (a primary key index) to locate the row, because the garbage collector needs to unlink from every index</span></span>  
  
 <span data-ttu-id="28723-218">Pour les index de hachage, il existe deux façons de réduire le travail causé par les valeurs de clé d'index dupliquées :</span><span class="sxs-lookup"><span data-stu-id="28723-218">For hash indexes, there are two ways to reduce the work caused by duplicate index key values:</span></span>  
  
-   <span data-ttu-id="28723-219">Utilisez plutôt un index non cluster.</span><span class="sxs-lookup"><span data-stu-id="28723-219">Use a nonclustered index instead.</span></span> <span data-ttu-id="28723-220">Vous pouvez diminuer les doublons en ajoutant des colonnes à la clé d'index sans modifier l'application.</span><span class="sxs-lookup"><span data-stu-id="28723-220">You can decrease the duplicates by adding columns to the index key without requiring any changes to the application.</span></span>  
  
-   <span data-ttu-id="28723-221">Définissez un nombre très élevé de compartiments pour l'index.</span><span class="sxs-lookup"><span data-stu-id="28723-221">Specify a very high bucket count for the index.</span></span> <span data-ttu-id="28723-222">Par exemple, 20 à 100 fois le nombre de clés d'index uniques.</span><span class="sxs-lookup"><span data-stu-id="28723-222">For example, 20-to-100 times the number of unique index keys.</span></span> <span data-ttu-id="28723-223">Cela va réduire les collisions de hachage.</span><span class="sxs-lookup"><span data-stu-id="28723-223">This will reduce hash collisions.</span></span>  
  
### <a name="small-tables"></a><span data-ttu-id="28723-224">Petites tables</span><span class="sxs-lookup"><span data-stu-id="28723-224">Small Tables</span></span>  
 <span data-ttu-id="28723-225">Pour les tables plus petites, l'utilisation de la mémoire n'est généralement pas un souci, car la taille de l'index sera petite comparée à la taille générale de la base de données.</span><span class="sxs-lookup"><span data-stu-id="28723-225">For smaller tables, memory utilization is usually not a concern, as the size of the index will be small compared to the overall size of the database.</span></span>  
  
 <span data-ttu-id="28723-226">Vous devez maintenant faire un choix en fonction du type de performances que vous recherchez :</span><span class="sxs-lookup"><span data-stu-id="28723-226">You must now make a choice based on the kind of performance you want:</span></span>  
  
-   <span data-ttu-id="28723-227">Si les opérations critiques pour les performances sur l'index sont majoritairement des recherches de point et/ou des opérations d'insertion, un nombre plus élevé de compartiments peut contribuer à réduire la probabilité de collisions de hachage.</span><span class="sxs-lookup"><span data-stu-id="28723-227">If the performance-critical operations on the index are predominantly point lookups and/or insert operations, a higher bucket count would be appropriate to reduce the likelihood of hash collisions.</span></span> <span data-ttu-id="28723-228">Trois fois le nombre de lignes, ou plus, est la meilleure option.</span><span class="sxs-lookup"><span data-stu-id="28723-228">Three times the number of rows or even more would be the best option.</span></span>  
  
-   <span data-ttu-id="28723-229">Si les analyses complètes d'index sont les principales opérations critiques pour les performances, utilisez un nombre de compartiments qui est proche du nombre réel de valeurs de clés d'index.</span><span class="sxs-lookup"><span data-stu-id="28723-229">If full index scans are the predominant performance-critical operations, use a bucket count that is close to the actual number of index key values.</span></span>  
  
### <a name="big-tables"></a><span data-ttu-id="28723-230">Grandes tables</span><span class="sxs-lookup"><span data-stu-id="28723-230">Big Tables</span></span>  
 <span data-ttu-id="28723-231">Pour les grandes tables, l'utilisation de la mémoire peut devenir un problème.</span><span class="sxs-lookup"><span data-stu-id="28723-231">For large tables, memory utilization could become a concern.</span></span> <span data-ttu-id="28723-232">Par exemple, avec une table de lignes 250 millions avec 4 index de hachage, chacun avec un nombre de compartiments de 1 milliard, la charge des tables de hachage est de 4 index \* 1 milliard compartiments \* 8 octets = 32 gigaoctets d’utilisation de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="28723-232">For example, with a 250 million row table that has 4 hash indexes, each with a bucket count of one billion, the overhead for the hash tables is 4 indexes \* 1 billion buckets \* 8 bytes = 32 gigabytes of memory utilization.</span></span> <span data-ttu-id="28723-233">Lorsque vous choisissez un nombre de compartiments de 250 millions pour chacun des index, la charge totale pour les tables de hachage est de 8 gigaoctets.</span><span class="sxs-lookup"><span data-stu-id="28723-233">When choosing a bucket count of 250 million for each of the indexes, the total overhead for the hash tables will be 8 gigabytes.</span></span> <span data-ttu-id="28723-234">Notez que cela s’ajoute aux 8 octets d’utilisation de la mémoire que chaque index ajoute à chaque ligne individuelle, ce qui correspond à 8 gigaoctets dans ce scénario (4 indexe \* 8 octets \* 250 millions lignes).</span><span class="sxs-lookup"><span data-stu-id="28723-234">Note that this is in addition to the 8 bytes of memory usage each index adds to each individual row, which is 8 gigabytes in this scenario (4 indexes \* 8 bytes \* 250 million rows).</span></span>  
  
 <span data-ttu-id="28723-235">Les analyses de table complètes ne sont généralement pas un problème critique pour les performances pour les charges de travail OLTP.</span><span class="sxs-lookup"><span data-stu-id="28723-235">Full table scans are not usually in the performance-critical path for OLTP workloads.</span></span> <span data-ttu-id="28723-236">Par conséquent, un choix doit être fait entre l'utilisation de la mémoire et les performances de la recherche de point et des opérations d'insertion :</span><span class="sxs-lookup"><span data-stu-id="28723-236">Therefore, the choice is between memory utilization versus performance of point lookup and insert operations:</span></span>  
  
-   <span data-ttu-id="28723-237">Si l'utilisation de la mémoire est un souci, choisissez un nombre de compartiments similaire au nombre de valeurs de clés d'index.</span><span class="sxs-lookup"><span data-stu-id="28723-237">If memory utilization is a concern, choose a bucket count close to the number of index key values.</span></span> <span data-ttu-id="28723-238">Le nombre de compartiments ne doit pas être considérablement inférieur au nombre de valeurs de clés d'index, car cela affecte la plupart des opérations DML tout comme le temps de récupération de la base de données après le redémarrage du serveur.</span><span class="sxs-lookup"><span data-stu-id="28723-238">The bucket count should not be significantly lower than the number of index key values, as this impacts most DML operations as well the time it takes to recover the database after server restart.</span></span>  
  
-   <span data-ttu-id="28723-239">Pour optimiser les performances des recherches de point, un nombre plus élevé de compartiments, égal à 2 ou 3 fois le nombre de valeurs d'index uniques, semble approprié.</span><span class="sxs-lookup"><span data-stu-id="28723-239">When optimizing the performance for point lookups, a higher bucket count of two or even three times the number of unique index values would be appropriate.</span></span> <span data-ttu-id="28723-240">Un nombre plus élevé de compartiments signifierait une utilisation accrue de mémoire et une augmentation du temps requis pour une analyse d'index complète.</span><span class="sxs-lookup"><span data-stu-id="28723-240">A higher bucket count would mean an increased memory utilization and an increase in the time required for a full index scan.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="28723-241">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="28723-241">See Also</span></span>  
 [<span data-ttu-id="28723-242">Index sur des tables optimisées en mémoire</span><span class="sxs-lookup"><span data-stu-id="28723-242">Indexes on Memory-Optimized Tables</span></span>](../../2014/database-engine/indexes-on-memory-optimized-tables.md)  
  
  
