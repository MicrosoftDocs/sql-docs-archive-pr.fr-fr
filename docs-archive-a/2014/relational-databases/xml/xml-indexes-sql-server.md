---
title: Index XML (SQL Server) | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- removing indexes
- deleting indexes
- secondary indexes [XML in SQL Server]
- xml data type [SQL Server], indexes
- dropping indexes
- PATH index
- DROP_EXISTING clause
- XML [SQL Server], indexes
- primary indexes [XML in SQL Server]
- indexes [SQL Server], XML
- XML indexes [SQL Server], secondary
- BLOBs, XML indexes
- disabling indexes
- XML indexes [SQL Server], modifying
- XML indexes [SQL Server]
- XML indexes [SQL Server], primary
- modifying indexes
- XML indexes [SQL Server], dropping
- VALUE index
- XML indexes [SQL Server], xml data type
- PROPERTY index
- XML indexes [SQL Server], creating
ms.assetid: f5c9209d-b3f3-4543-b30b-01365a5e7333
author: rothja
ms.author: jroth
ms.openlocfilehash: bf9a33bc18790bf8821d778746a708f78bbb3d8f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87611630"
---
# <a name="xml-indexes-sql-server"></a><span data-ttu-id="c4313-102">Index XML (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="c4313-102">XML Indexes (SQL Server)</span></span>
  <span data-ttu-id="c4313-103">Des index XML peuvent être créés sur des colonnes de type `xml`.</span><span class="sxs-lookup"><span data-stu-id="c4313-103">XML indexes can be created on `xml` data type columns.</span></span> <span data-ttu-id="c4313-104">L'indexation porte sur les balises, les valeurs et les chemins d'accès rencontrés dans les instances XML de la colonne et contribue à l'optimisation des performances des requêtes.</span><span class="sxs-lookup"><span data-stu-id="c4313-104">They index all tags, values and paths over the XML instances in the column and benefit query performance.</span></span> <span data-ttu-id="c4313-105">Votre application peut bénéficier d'un index XML dans les situations suivantes :</span><span class="sxs-lookup"><span data-stu-id="c4313-105">Your application may benefit from an XML index in the following situations:</span></span>  
  
-   <span data-ttu-id="c4313-106">Les requêtes portant sur des colonnes XML sont fréquentes dans votre charge de travail.</span><span class="sxs-lookup"><span data-stu-id="c4313-106">Queries on XML columns are common in your workload.</span></span> <span data-ttu-id="c4313-107">Le coût de la maintenance des index XML au cours de la modification des données doit être pris en compte lors de l'évaluation des avantages.</span><span class="sxs-lookup"><span data-stu-id="c4313-107">XML index maintenance cost during data modification must be considered.</span></span>  
  
-   <span data-ttu-id="c4313-108">Vos valeurs XML sont relativement grandes et les parties récupérées relativement petites.</span><span class="sxs-lookup"><span data-stu-id="c4313-108">Your XML values are relatively large and the retrieved parts are relatively small.</span></span> <span data-ttu-id="c4313-109">En créant un index, vous n'avez plus à analyser l'ensemble des données lors de l'exécution et pouvez profiter de la recherche d'index pour accélérer le traitement des requêtes.</span><span class="sxs-lookup"><span data-stu-id="c4313-109">Building the index avoids parsing the whole data at run time and benefits index lookups for efficient query processing.</span></span>  
  
 <span data-ttu-id="c4313-110">Les index XML sont classés en plusieurs catégories :</span><span class="sxs-lookup"><span data-stu-id="c4313-110">XML indexes fall into the following categories:</span></span>  
  
-   <span data-ttu-id="c4313-111">Index XML primaires</span><span class="sxs-lookup"><span data-stu-id="c4313-111">Primary XML index</span></span>  
  
-   <span data-ttu-id="c4313-112">Index XML secondaires</span><span class="sxs-lookup"><span data-stu-id="c4313-112">Secondary XML index</span></span>  
  
 <span data-ttu-id="c4313-113">Le premier index portant sur la colonne de type `xml` est obligatoirement l'index XML primaire.</span><span class="sxs-lookup"><span data-stu-id="c4313-113">The first index on the `xml` type column must be the primary XML index.</span></span> <span data-ttu-id="c4313-114">Par le biais de l’index XML primaire, les trois types d’index secondaires suivants sont pris en charge : PATH, VALUE et PROPERTY.</span><span class="sxs-lookup"><span data-stu-id="c4313-114">Using the primary XML index, the following types of secondary indexes are supported: PATH, VALUE, and PROPERTY.</span></span> <span data-ttu-id="c4313-115">Selon le type de requêtes, ces index secondaires peuvent contribuer à améliorer les performances liées à l'exécution de requêtes.</span><span class="sxs-lookup"><span data-stu-id="c4313-115">Depending on the type of queries, these secondary indexes might help improve query performance.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="c4313-116">Vous ne pouvez pas créer ou modifier d'index XML à moins que les options de base de données ne soient définies correctement pour utiliser le type de données `xml`.</span><span class="sxs-lookup"><span data-stu-id="c4313-116">You cannot create or modify an XML index unless the database options are set correctly for working with the `xml` data type.</span></span> <span data-ttu-id="c4313-117">Pour plus d’informations, consultez [Utiliser la recherche en texte intégral avec des colonnes XML](use-full-text-search-with-xml-columns.md).</span><span class="sxs-lookup"><span data-stu-id="c4313-117">For more information, see [Use Full-Text Search with XML Columns](use-full-text-search-with-xml-columns.md).</span></span>  
  
 <span data-ttu-id="c4313-118">Les instances XML sont stockées dans les colonnes de type `xml` sous forme de BLOB (Binary Large Objects, objets volumineux binaires).</span><span class="sxs-lookup"><span data-stu-id="c4313-118">XML instances are stored in `xml` type columns as large binary objects (BLOBs).</span></span> <span data-ttu-id="c4313-119">Ces instances XML peuvent donc être volumineuses et la représentation binaire stockée d'instances de type `xml` peut atteindre jusqu'à 2 Go.</span><span class="sxs-lookup"><span data-stu-id="c4313-119">These XML instances can be large, and the stored binary representation of `xml` data type instances can be up to 2 GB.</span></span> <span data-ttu-id="c4313-120">Sans index, ces objets sont fragmentés au moment de l'exécution du programme afin d'évaluer une requête,</span><span class="sxs-lookup"><span data-stu-id="c4313-120">Without an index, these binary large objects are shredded at run time to evaluate a query.</span></span> <span data-ttu-id="c4313-121">ce qui peut prendre du temps.</span><span class="sxs-lookup"><span data-stu-id="c4313-121">This shredding can be time-consuming.</span></span> <span data-ttu-id="c4313-122">Examinons, par exemple, la requête suivante :</span><span class="sxs-lookup"><span data-stu-id="c4313-122">For example, consider the following query:</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")  
  
SELECT CatalogDescription.query('  
  /PD:ProductDescription/PD:Summary  
') as Result  
FROM Production.ProductModel  
WHERE CatalogDescription.exist ('/PD:ProductDescription/@ProductModelID[.="19"]') = 1  
```  
  
 <span data-ttu-id="c4313-123">Pour pouvoir sélectionner les instances XML satisfaisant la condition stipulée dans la clause `WHERE` , le BLOB XML se trouvant dans chaque ligne de la table `Production.ProductModel` est fragmenté au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="c4313-123">To select the XML instances that satisfy the condition in the `WHERE` clause, the XML binary large object (BLOB) in each row of table `Production.ProductModel` is shredded at run time.</span></span> <span data-ttu-id="c4313-124">L'expression `(/PD:ProductDescription/@ProductModelID[.="19"]`) tirée de la méthode `exist()` est ensuite évaluée.</span><span class="sxs-lookup"><span data-stu-id="c4313-124">Then, the expression `(/PD:ProductDescription/@ProductModelID[.="19"]`) in the `exist()` method is evaluated.</span></span> <span data-ttu-id="c4313-125">Une telle fragmentation à l'exécution peut être coûteuse selon la taille et le nombre d'instances stockées dans la colonne.</span><span class="sxs-lookup"><span data-stu-id="c4313-125">This run-time shredding can be costly, depending on the size and number of instances stored in the column.</span></span>  
  
 <span data-ttu-id="c4313-126">Si l'exécution de requêtes sur des BLOB est courante dans l'environnement de votre application, cette méthodologie permet d'indexer les colonnes de type `xml`.</span><span class="sxs-lookup"><span data-stu-id="c4313-126">If querying XML binary large objects (BLOBs) is common in your application environment, it helps to index the `xml` type columns.</span></span> <span data-ttu-id="c4313-127">En contrepartie, le coût associé à la gestion de l'index lors de la modification des données est également à prendre en compte.</span><span class="sxs-lookup"><span data-stu-id="c4313-127">However, there is a cost associated with maintaining the index during data modification.</span></span>  
  
## <a name="primary-xml-index"></a><span data-ttu-id="c4313-128">Index XML primaires</span><span class="sxs-lookup"><span data-stu-id="c4313-128">Primary XML Index</span></span>  
 <span data-ttu-id="c4313-129">L'index XML primaire indexe toutes les balises, valeurs et chemins d'accès rencontrés dans les instances XML d'une colonne XML.</span><span class="sxs-lookup"><span data-stu-id="c4313-129">The primary XML index indexes all tags, values, and paths within the XML instances in an XML column.</span></span> <span data-ttu-id="c4313-130">Pour créer un index XML primaire, la table contenant la colonne XML doit posséder un index cluster portant sur la clé primaire de la table.</span><span class="sxs-lookup"><span data-stu-id="c4313-130">To create a primary XML index, the table in which the XML column occurs must have a clustered index on the primary key of the table.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="c4313-131">utilise cette clé primaire pour corréler les lignes de l'index XML primaire avec des lignes dans la table qui contient la colonne XML.</span><span class="sxs-lookup"><span data-stu-id="c4313-131">uses this primary key to correlate rows in the primary XML index with rows in the table that contains the XML column.</span></span>  
  
 <span data-ttu-id="c4313-132">L'index XML primaire correspond à une représentation fragmentée et persistante des objets blob XML inclus dans la colonne des données de type `xml`.</span><span class="sxs-lookup"><span data-stu-id="c4313-132">The primary XML index is a shredded and persisted representation of the XML BLOBs in the `xml` data type column.</span></span> <span data-ttu-id="c4313-133">Pour chacun de ces objets blob XML de la colonne, l'index crée plusieurs lignes de données.</span><span class="sxs-lookup"><span data-stu-id="c4313-133">For each XML binary large object (BLOB) in the column, the index creates several rows of data.</span></span> <span data-ttu-id="c4313-134">Le nombre de lignes dans l'index est presque égal au nombre de nœuds se trouvant dans l'objet blob XML.</span><span class="sxs-lookup"><span data-stu-id="c4313-134">The number of rows in the index is approximately equal to the number of nodes in the XML binary large object.</span></span> <span data-ttu-id="c4313-135">Lorsqu'une requête extrait l'intégralité de l'instance XML, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] fournit l'instance à partir de la colonne XML.</span><span class="sxs-lookup"><span data-stu-id="c4313-135">When a query retrieves the full XML instance, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] provides the instance from the XML column.</span></span> <span data-ttu-id="c4313-136">Les requêtes dans des instances XML utilisent l'index XML primaire et peuvent renvoyer des valeurs scalaires ou des sous-arborescences XML en se servant de l'index lui-même.</span><span class="sxs-lookup"><span data-stu-id="c4313-136">Queries within XML instances use the primary XML index, and can return scalar values or XML subtrees by using the index itself.</span></span>  
  
 <span data-ttu-id="c4313-137">Chaque ligne stocke les informations suivantes relatives aux nœuds :</span><span class="sxs-lookup"><span data-stu-id="c4313-137">Each row stores the following node information:</span></span>  
  
-   <span data-ttu-id="c4313-138">Le nom de la balise tel que le nom d'un élément ou d'un attribut.</span><span class="sxs-lookup"><span data-stu-id="c4313-138">Tag name such as an element or attribute name.</span></span>  
  
-   <span data-ttu-id="c4313-139">La valeur du nœud.</span><span class="sxs-lookup"><span data-stu-id="c4313-139">Node value.</span></span>  
  
-   <span data-ttu-id="c4313-140">Le type de nœud, par exemple un nœud élément, un nœud attribut ou un nœud texte.</span><span class="sxs-lookup"><span data-stu-id="c4313-140">Node type such as an element node, attribute node, or text node.</span></span>  
  
-   <span data-ttu-id="c4313-141">Les informations sur l'ordre du document, représentées par un identifiant de nœud interne.</span><span class="sxs-lookup"><span data-stu-id="c4313-141">Document order information, represented by an internal node identifier.</span></span>  
  
-   <span data-ttu-id="c4313-142">Le chemin d'accès de chacun des nœuds vers la racine de l'arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="c4313-142">Path from each node to the root of the XML tree.</span></span> <span data-ttu-id="c4313-143">Cette colonne fait l'objet de recherches pour y trouver la présence d'expressions de chemin d'accès mentionnées dans la requête.</span><span class="sxs-lookup"><span data-stu-id="c4313-143">This column is searched for path expressions in the query.</span></span>  
  
-   <span data-ttu-id="c4313-144">La clé primaire de la table de base.</span><span class="sxs-lookup"><span data-stu-id="c4313-144">Primary key of the base table.</span></span> <span data-ttu-id="c4313-145">Cette clé est copiée dans l'index XML primaire afin de pouvoir effectuer une jointure en retour avec la table de base et le nombre maximal de colonnes dans la clé primaire de la table de base est limité à 15.</span><span class="sxs-lookup"><span data-stu-id="c4313-145">The primary key of the base table is duplicated in the primary XML index for a back join with the base table, and the maximum number of columns in the primary key of the base table is limited to 15.</span></span>  
  
 <span data-ttu-id="c4313-146">Les informations de ce nœud sont utilisées afin d'évaluer et d'élaborer les résultats sous forme de données XML découlant d'une requête donnée.</span><span class="sxs-lookup"><span data-stu-id="c4313-146">This node information is used to evaluate and construct XML results for a specified query.</span></span> <span data-ttu-id="c4313-147">Pour des raisons d'optimisation, les informations relatives au nom de la balise et au type de nœud sont encodées sous forme de valeurs entières et la colonne Path s'appuie sur ce même encodage.</span><span class="sxs-lookup"><span data-stu-id="c4313-147">For optimization purposes, the tag name and the node type information are encoded as integer values, and the Path column uses the same encoding.</span></span> <span data-ttu-id="c4313-148">En outre, les chemins d'accès sont stockés dans l'ordre inverse afin de pouvoir faire correspondre les chemins d'accès où seul le suffixe est connu.</span><span class="sxs-lookup"><span data-stu-id="c4313-148">Also, paths are stored in reverse order to allow matching paths when only the path suffix is known.</span></span> <span data-ttu-id="c4313-149">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="c4313-149">For example:</span></span>  
  
-   <span data-ttu-id="c4313-150">`//ContactRecord/PhoneNumber` , où seuls les deux derniers niveaux sont connus ;</span><span class="sxs-lookup"><span data-stu-id="c4313-150">`//ContactRecord/PhoneNumber` where only the last two steps are known</span></span>  
  
 <span data-ttu-id="c4313-151">OR</span><span class="sxs-lookup"><span data-stu-id="c4313-151">OR</span></span>  
  
-   <span data-ttu-id="c4313-152">`/Book/*/Title` où le caractère générique (`*`) est mentionné au milieu de l’expression.</span><span class="sxs-lookup"><span data-stu-id="c4313-152">`/Book/*/Title` where the wildcard character (`*`) is specified in the middle of the expression.</span></span>  
  
 <span data-ttu-id="c4313-153">Le processeur de requêtes utilise l'index XML primaire dans le cas de requêtes mettant en œuvre des [xml Data Type Methods](/sql/t-sql/xml/xml-data-type-methods) et renvoie les valeurs scalaires ou les sous-arborescences XML tirées de l'index primaire lui-même</span><span class="sxs-lookup"><span data-stu-id="c4313-153">The query processor uses the primary XML index for queries that involve [xml Data Type Methods](/sql/t-sql/xml/xml-data-type-methods) and returns either scalar values or the XML subtrees from the primary index itself.</span></span> <span data-ttu-id="c4313-154">(cet index stocke toutes les informations nécessaires afin de reconstruire l'instance XML).</span><span class="sxs-lookup"><span data-stu-id="c4313-154">(This index stores all the necessary information to reconstruct the XML instance.)</span></span>  
  
 <span data-ttu-id="c4313-155">Par exemple, la requête suivante retourne des informations de résumé stockées dans la `CatalogDescription``xml` colonne type de la `ProductModel` table.</span><span class="sxs-lookup"><span data-stu-id="c4313-155">For example, the following query returns summary information stored in the `CatalogDescription``xml` type column in the `ProductModel` table.</span></span> <span data-ttu-id="c4313-156">Elle ne renvoie les informations dans la balise <`Summary`> que pour les modèles de produits dont la description de catalogue stocke également la description située dans la balise <`Features`>.</span><span class="sxs-lookup"><span data-stu-id="c4313-156">The query returns <`Summary`> information only for product models whose catalog description also stores the <`Features`> description.</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")SELECT CatalogDescription.query('  /PD:ProductDescription/PD:Summary') as ResultFROM Production.ProductModelWHERE CatalogDescription.exist ('/PD:ProductDescription/PD:Features') = 1  
```  
  
 <span data-ttu-id="c4313-157">Concernant l'index XML primaire, au lieu de fragmenter chaque instance d'objet blob XML se trouvant dans la table de base, les lignes de l'index correspondant à chaque objet blob XML sont soumises à des recherches séquentielles pour retrouver l'expression indiquée dans la méthode `exist()` .</span><span class="sxs-lookup"><span data-stu-id="c4313-157">With regard to the primary XML index, instead of shredding each XML binary large object instance in the base table, the rows in the index that correspond to each XML binary large object are searched sequentially for the expression specified in the `exist()` method.</span></span> <span data-ttu-id="c4313-158">Si le chemin d'accès est retrouvé dans la colonne Path de l'index, l'élément <`Summary`> ainsi que ses sous-arborescences sont extraits de l'index XML primaire, puis convertis en objet blob XML suite à l'exécution de la méthode `query()`.</span><span class="sxs-lookup"><span data-stu-id="c4313-158">If the path is found in the Path column in the index, the <`Summary`> element together with its subtrees is retrieved from the primary XML index and converted into an XML binary large object as the result of the `query()` method.</span></span>  
  
 <span data-ttu-id="c4313-159">Notez que l'index XML primaire n'est pas sollicité lors de la récupération d'une instance XML complète.</span><span class="sxs-lookup"><span data-stu-id="c4313-159">Note that the primary XML index is not used when retrieving a full XML instance.</span></span> <span data-ttu-id="c4313-160">Par exemple, la requête suivante extrait de la table l'instance XML tout entière décrivant les instructions de fabrication d'un modèle de produit donné.</span><span class="sxs-lookup"><span data-stu-id="c4313-160">For example, the following query retrieves from the table the whole XML instance that describes the manufacturing instructions for a specific product model.</span></span>  
  
```  
USE AdventureWorks2012;SELECT InstructionsFROM Production.ProductModel WHERE ProductModelID=7;  
```  
  
## <a name="secondary-xml-indexes"></a><span data-ttu-id="c4313-161">Index XML secondaires</span><span class="sxs-lookup"><span data-stu-id="c4313-161">Secondary XML Indexes</span></span>  
 <span data-ttu-id="c4313-162">Afin d'améliorer les performances lors des recherches, vous pouvez créer des index XML secondaires.</span><span class="sxs-lookup"><span data-stu-id="c4313-162">To enhance search performance, you can create secondary XML indexes.</span></span> <span data-ttu-id="c4313-163">Un index XML primaire doit être défini au préalable avant de pouvoir créer des index secondaires.</span><span class="sxs-lookup"><span data-stu-id="c4313-163">A primary XML index must first exist before you can create secondary indexes.</span></span> <span data-ttu-id="c4313-164">Il en existe trois types différents :</span><span class="sxs-lookup"><span data-stu-id="c4313-164">These are the types:</span></span>  
  
-   <span data-ttu-id="c4313-165">les index XML secondaires de type PATH (s'appuyant sur le chemin d'accès) ;</span><span class="sxs-lookup"><span data-stu-id="c4313-165">PATH secondary XML index</span></span>  
  
-   <span data-ttu-id="c4313-166">les index XML secondaires de type VALUE (utilisant la valeur comme critère de recherche) ;</span><span class="sxs-lookup"><span data-stu-id="c4313-166">VALUE secondary XML index</span></span>  
  
-   <span data-ttu-id="c4313-167">les index XML secondaires de type PROPERTY (pour rechercher des données d'après leurs propriétés).</span><span class="sxs-lookup"><span data-stu-id="c4313-167">PROPERTY secondary XML index</span></span>  
  
 <span data-ttu-id="c4313-168">Voici quelques consignes pour vous aider à créer un ou plusieurs index secondaires :</span><span class="sxs-lookup"><span data-stu-id="c4313-168">Following are some guidelines for creating one or more secondary indexes:</span></span>  
  
-   <span data-ttu-id="c4313-169">Si votre charge de travail utilise souvent des expressions de chemin sur les colonnes XML, l'index secondaire PATH a toutes les chances de l'accélérer.</span><span class="sxs-lookup"><span data-stu-id="c4313-169">If your workload uses path expressions significantly on XML columns, the PATH secondary XML index is likely to speed up your workload.</span></span> <span data-ttu-id="c4313-170">C’est ce que vous pouvez constater le plus souvent en cas d’utilisation de la méthode **exist()** sur des colonnes XML dans la clause WHERE de Transact-SQL.</span><span class="sxs-lookup"><span data-stu-id="c4313-170">The most common case is the use of the **exist()** method on XML columns in the WHERE clause of Transact-SQL.</span></span>  
  
-   <span data-ttu-id="c4313-171">Si votre charge de travail récupère plusieurs valeurs d'instances XML individuelles en utilisant des expressions de chemin, le clustering des chemins pour chaque instance XML dans l'index PROPERTY peut s'avérer fort utile.</span><span class="sxs-lookup"><span data-stu-id="c4313-171">If your workload retrieves multiple values from individual XML instances by using path expressions, clustering paths within each XML instance in the PROPERTY index may be helpful.</span></span> <span data-ttu-id="c4313-172">Ce scénario se produit généralement avec un sac de propriétés où les propriétés d'un objet sont récupérées et la valeur de sa clé primaire est connue.</span><span class="sxs-lookup"><span data-stu-id="c4313-172">This scenario typically occurs in a property bag scenario when properties of an object are fetched and its primary key value is known.</span></span>  
  
-   <span data-ttu-id="c4313-173">Si votre charge de travail implique le lancement de requêtes sur des valeurs d'instances XML pour lesquelles vous ne connaissez pas les noms d'élément ou d'attribut, vous aurez peut-être intérêt à créer l'index VALUE.</span><span class="sxs-lookup"><span data-stu-id="c4313-173">If your workload involves querying for values within XML instances without knowing the element or attribute names that contain those values, you may want to create the VALUE index.</span></span> <span data-ttu-id="c4313-174">C’est généralement ce qui se produit en cas de recherches d’axes descendants telles que //author[last-name="Howard"], où les éléments \<author> peuvent se trouver à tout niveau de la hiérarchie.</span><span class="sxs-lookup"><span data-stu-id="c4313-174">This typically occurs with descendant axes lookups, such as //author[last-name="Howard"], where \<author> elements can occur at any level of the hierarchy.</span></span> <span data-ttu-id="c4313-175">Cela se rencontre aussi dans les requêtes basées sur des caractères génériques telles que /book [@\* = "novel"], où la requête recherche les éléments \<book> ayant des attributs de valeur « novel ».</span><span class="sxs-lookup"><span data-stu-id="c4313-175">It also occurs in wildcard queries, such as /book [@\* = "novel"], where the query looks for \<book> elements that have some attribute having the value "novel".</span></span>  
  
### <a name="path-secondary-xml-index"></a><span data-ttu-id="c4313-176">les index XML secondaires de type PATH (s'appuyant sur le chemin d'accès) ;</span><span class="sxs-lookup"><span data-stu-id="c4313-176">PATH Secondary XML Index</span></span>  
 <span data-ttu-id="c4313-177">Si vos requêtes précisent habituellement les expressions de chemin d'accès sur les colonnes de type `xml`, un index secondaire de type PATH peut s'avérer à même d'accélérer la recherche.</span><span class="sxs-lookup"><span data-stu-id="c4313-177">If your queries generally specify path expressions on `xml` type columns, a PATH secondary index may be able to speed up the search.</span></span> <span data-ttu-id="c4313-178">Comme nous l’avons vu précédemment, l’index primaire est des plus utiles pour les requêtes indiquant la méthode **exist()** dans leur clause WHERE.</span><span class="sxs-lookup"><span data-stu-id="c4313-178">As described earlier in this topic, the primary index is helpful when you have queries that specify **exist()** method in the WHERE clause.</span></span> <span data-ttu-id="c4313-179">Si vous ajoutez à présent un index secondaire de type PATH, il se peut que vous amélioriez encore la rapidité de la recherche lancée par de telles requêtes.</span><span class="sxs-lookup"><span data-stu-id="c4313-179">If you add a PATH secondary index, you may also improve the search performance in such queries.</span></span>  
  
 <span data-ttu-id="c4313-180">Bien qu'un index XML primaire évite de fragmenter les objets blob XML à l'exécution, il peut ne pas offrir les meilleurs temps de réponse pour les requêtes s'appuyant sur des expressions de chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="c4313-180">Although a primary XML index avoids having to shred the XML binary large objects at run time, it may not provide the best performance for queries based on path expressions.</span></span> <span data-ttu-id="c4313-181">Une recherche, lancée sur toutes les lignes constituant l'index XML primaire correspondant à un objet blob XML et s'opérant de façon séquentielle pour des instances XML volumineuses, peut s'avérer des plus lentes.</span><span class="sxs-lookup"><span data-stu-id="c4313-181">Because all rows in the primary XML index corresponding to an XML binary large object are searched sequentially for large XML instances, the sequential search may be slow.</span></span> <span data-ttu-id="c4313-182">Dans ce cas, un index secondaire construit sur les valeurs de chemin d'accès et sur celles des nœuds de l'index primaire peut accélérer de façon significative la recherche sur l'index.</span><span class="sxs-lookup"><span data-stu-id="c4313-182">In this case, having a secondary index built on the path values and node values in the primary index can significantly speed up the index search.</span></span> <span data-ttu-id="c4313-183">Dans le cas d'un index XML secondaire de type PATH, les valeurs de chemin d'accès et des nœuds correspondent à des colonnes clés permettant donc des recherches plus efficaces si ces dernières portent sur le chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="c4313-183">In the PATH secondary index, the path and node values are key columns that allow for more efficient seeks when searching for paths.</span></span> <span data-ttu-id="c4313-184">Il se peut que l'optimiseur de requête utilise l'index de type PATH dans des expressions telles que celles mentionnées ci-dessous :</span><span class="sxs-lookup"><span data-stu-id="c4313-184">The query optimizer may use the PATH index for expressions such as those shown in the following:</span></span>  
  
-   <span data-ttu-id="c4313-185">`/root/Location` , n'indiquant que son chemin d'accès ;</span><span class="sxs-lookup"><span data-stu-id="c4313-185">`/root/Location` which specify only a path</span></span>  
  
 <span data-ttu-id="c4313-186">OR</span><span class="sxs-lookup"><span data-stu-id="c4313-186">OR</span></span>  
  
-   <span data-ttu-id="c4313-187">`/root/Location/@LocationID[.="10"]` , où le chemin et la valeur du nœud sont précisés.</span><span class="sxs-lookup"><span data-stu-id="c4313-187">`/root/Location/@LocationID[.="10"]` where both the path and the node value are specified.</span></span>  
  
 <span data-ttu-id="c4313-188">La requête suivante illustre un cas de figure où l'index de type PATH s'avère particulièrement utile :</span><span class="sxs-lookup"><span data-stu-id="c4313-188">The following query shows where the PATH index is helpful:</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")  
  
SELECT CatalogDescription.query('  
  /PD:ProductDescription/PD:Summary  
') AS Result  
FROM Production.ProductModel  
WHERE CatalogDescription.exist ('/PD:ProductDescription/@ProductModelID[.="19"]') = 1  
```  
  
 <span data-ttu-id="c4313-189">Dans la requête, l'expression de chemin d'accès `/PD:ProductDescription/@ProductModelID` et sa valeur `"19"` se trouvant dans la méthode `exist()` correspondent aux champs de clé définis pour l'index de type PATH.</span><span class="sxs-lookup"><span data-stu-id="c4313-189">In the query, the path expression `/PD:ProductDescription/@ProductModelID` and value `"19"` in the `exist()` method correspond to the key fields of the PATH index.</span></span> <span data-ttu-id="c4313-190">Des recherches directes portant sur l'index PATH peuvent s'effectuer et offrir ainsi de meilleures performances que dans le cas d'une recherche séquentielle portant sur les valeurs de chemin d'accès de l'index primaire.</span><span class="sxs-lookup"><span data-stu-id="c4313-190">This allows for direct seek in the PATH index and provides better search performance than the sequential search for path values in the primary index.</span></span>  
  
### <a name="value-secondary-xml-index"></a><span data-ttu-id="c4313-191">les index XML secondaires de type VALUE (utilisant la valeur comme critère de recherche) ;</span><span class="sxs-lookup"><span data-stu-id="c4313-191">VALUE Secondary XML Index</span></span>  
 <span data-ttu-id="c4313-192">Si des requêtes s'appuient sur les valeurs pour ses résultats, par exemple `/Root/ProductDescription/@*[. = "Mountain Bike"]` ou `//ProductDescription[@Name = "Mountain Bike"]`, et que le chemin n'est pas entièrement précisé ou qu'il contient un caractère générique, vous pourriez obtenir des résultats plus rapidement en construisant un index XML secondaire sur les valeurs des nœuds de l'index XML primaire.</span><span class="sxs-lookup"><span data-stu-id="c4313-192">If queries are value based, for example, `/Root/ProductDescription/@*[. = "Mountain Bike"]` or `//ProductDescription[@Name = "Mountain Bike"]`, and the path is not fully specified or it includes a wildcard, you might obtain faster results by building a secondary XML index that is built on node values in the primary XML index.</span></span>  
  
 <span data-ttu-id="c4313-193">Les colonnes clés (correspondant aux valeurs de nœud et aux chemins d'accès) de l'index de type VALUE sont tirées de l'index XML primaire.</span><span class="sxs-lookup"><span data-stu-id="c4313-193">The key columns of the VALUE index are (node value and path) of the primary XML index.</span></span> <span data-ttu-id="c4313-194">Si vous devez lancer des requêtes sur des valeurs provenant d'instances XML sans connaître le nom des éléments ou des attributs contenant les valeurs, il se peut que l'index de type VALUE vous soit particulièrement utile.</span><span class="sxs-lookup"><span data-stu-id="c4313-194">If your workload involves querying for values from XML instances without knowing the element or attribute names that contain the values, a VALUE index may be useful.</span></span> <span data-ttu-id="c4313-195">Par exemple, l'expression suivante tire parti de l'utilisation d'un index de type VALUE :</span><span class="sxs-lookup"><span data-stu-id="c4313-195">For example, the following expression will benefit from having a VALUE index:</span></span>  
  
-   <span data-ttu-id="c4313-196">`//author[LastName="someName"]`, où vous connaissez la valeur de l'élément <`LastName`>, mais où le parent <`author`> peut se placer n'importe où.</span><span class="sxs-lookup"><span data-stu-id="c4313-196">`//author[LastName="someName"]` where you know the value of the <`LastName`> element, but the <`author`> parent can occur anywhere.</span></span>  
  
-   <span data-ttu-id="c4313-197">`/book[@* = "someValue"]`, où la requête recherche l'élément <`book`> dont un attribut possède la valeur `"someValue"`.</span><span class="sxs-lookup"><span data-stu-id="c4313-197">`/book[@* = "someValue"]` where the query looks for the <`book`> element that has some attribute having the value `"someValue"`.</span></span>  
  
 <span data-ttu-id="c4313-198">La requête suivante renvoie `ContactID` à partir de la table `Contact` .</span><span class="sxs-lookup"><span data-stu-id="c4313-198">The following query returns `ContactID` from the `Contact` table.</span></span> <span data-ttu-id="c4313-199">La `WHERE` clause spécifie un filtre qui recherche des valeurs dans la `AdditionalContactInfo``xml` colonne Type.</span><span class="sxs-lookup"><span data-stu-id="c4313-199">The `WHERE` clause specifies a filter that looks for values in the `AdditionalContactInfo``xml` type column.</span></span> <span data-ttu-id="c4313-200">L'ID des contacts n'est renvoyé que si l'objet blob XML relatif aux informations complémentaires sur les contacts correspondants contient un numéro de téléphone spécifique.</span><span class="sxs-lookup"><span data-stu-id="c4313-200">The contact IDs are returned only if the corresponding additional contact information XML binary large object includes a specific telephone number.</span></span> <span data-ttu-id="c4313-201">Puisque l'élément <`telephoneNumber`> peut apparaître n'importe où dans le document XML, l'expression du chemin d'accès indique l'axe descendant-or-self.</span><span class="sxs-lookup"><span data-stu-id="c4313-201">Because the <`telephoneNumber`> element may appear anywhere in the XML, the path expression specifies the descendent-or-self axis.</span></span>  
  
```  
WITH XMLNAMESPACES (  
  'https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ContactInfo' AS CI,  
  'https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ContactTypes' AS ACT)  
  
SELECT ContactID   
FROM   Person.Contact  
WHERE  AdditionalContactInfo.exist('//ACT:telephoneNumber/ACT:number[.="111-111-1111"]') = 1  
```  
  
 <span data-ttu-id="c4313-202">Dans ce cas, nous connaissons donc la valeur de recherche correspondant à <`number`> mais elle peut se trouver n'importe où dans l'instance XML en tant qu'enfant de l'élément <`telephoneNumber`>.</span><span class="sxs-lookup"><span data-stu-id="c4313-202">In this situation, the search value for <`number`> is known, but it can appear anywhere in the XML instance as a child of the <`telephoneNumber`> element.</span></span> <span data-ttu-id="c4313-203">Ce type de requête pourrait être plus efficace grâce à la recherche d'une valeur précise dans les index.</span><span class="sxs-lookup"><span data-stu-id="c4313-203">This kind of query might benefit from an index lookup based on a specific value.</span></span>  
  
### <a name="property-secondary-index"></a><span data-ttu-id="c4313-204">Index secondaire de type PROPERTY</span><span class="sxs-lookup"><span data-stu-id="c4313-204">PROPERTY Secondary Index</span></span>  
 <span data-ttu-id="c4313-205">Les requêtes chargées d'extraire plusieurs valeurs d'instances XML distinctes peuvent bénéficier de l'utilisation d'un index de type PROPERTY.</span><span class="sxs-lookup"><span data-stu-id="c4313-205">Queries that retrieve one or more values from individual XML instances might benefit from a PROPERTY index.</span></span> <span data-ttu-id="c4313-206">Ce scénario se produit lorsque vous récupérez des propriétés d’objet à l’aide de la méthode **value ()** du `xml` type et lorsque la valeur de clé primaire de l’objet est connue.</span><span class="sxs-lookup"><span data-stu-id="c4313-206">This scenario occurs when you retrieve object properties by using the **value()** method of the `xml` type and when the primary key value of the object is known.</span></span>  
  
 <span data-ttu-id="c4313-207">L'index utilisant le paramètre PROPERTY se construit d'après des colonnes (PK pour la clé primaire, Path pour le chemin d'accès, ainsi que la valeur du nœud) issues de l'index XML primaire, où PK correspond à la clé primaire de la table de base.</span><span class="sxs-lookup"><span data-stu-id="c4313-207">The PROPERTY index is built on columns (PK, Path and node value) of the primary XML index where PK is the primary key of the base table.</span></span>  
  
 <span data-ttu-id="c4313-208">Par exemple, concernant le modèle de produit `19`, la requête suivante extrait les valeurs des attributs `ProductModelID` et `ProductModelName` grâce à la méthode `value()` .</span><span class="sxs-lookup"><span data-stu-id="c4313-208">For example, for product model `19`, the following query retrieves the `ProductModelID` and `ProductModelName` attribute values using the `value()` method.</span></span> <span data-ttu-id="c4313-209">Contrairement aux requêtes utilisant les index XML primaires ou tout autre index XML secondaire, l'index PROPERTY peut permettre une exécution plus rapide.</span><span class="sxs-lookup"><span data-stu-id="c4313-209">Instead of using the primary XML index or the other secondary XML indexes, the PROPERTY index may provide faster execution.</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")  
  
SELECT CatalogDescription.value('(/PD:ProductDescription/@ProductModelID)[1]', 'int') as ModelID,  
       CatalogDescription.value('(/PD:ProductDescription/@ProductModelName)[1]', 'varchar(30)') as ModelName          
FROM Production.ProductModel     
WHERE ProductModelID = 19  
```  
  
 <span data-ttu-id="c4313-210">À l’exception des différences décrites plus loin dans cette rubrique, la création d’un index XML sur une `xml` colonne de type est similaire à la création d’un index sur une colonne qui n’est pas de `xml` type.</span><span class="sxs-lookup"><span data-stu-id="c4313-210">Except for the differences described later in this topic, creating an XML index on an`xml` type column is similar to creating an index on a non-`xml` type column.</span></span> <span data-ttu-id="c4313-211">Les instructions DDL [!INCLUDE[tsql](../../includes/tsql-md.md)] suivantes permettent de créer et de gérer les index XML :</span><span class="sxs-lookup"><span data-stu-id="c4313-211">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] DDL statements can be used to create and manage XML indexes:</span></span>  
  
-   [<span data-ttu-id="c4313-212">CREATE INDEX &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="c4313-212">CREATE INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/create-index-transact-sql)  
  
-   [<span data-ttu-id="c4313-213">ALTER INDEX &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="c4313-213">ALTER INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/alter-index-transact-sql)  
  
-   [<span data-ttu-id="c4313-214">DROP INDEX &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="c4313-214">DROP INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/drop-index-transact-sql)  
  
## <a name="getting-information-about-xml-indexes"></a><span data-ttu-id="c4313-215">Obtention d'informations sur les index XML</span><span class="sxs-lookup"><span data-stu-id="c4313-215">Getting Information about XML Indexes</span></span>  
 <span data-ttu-id="c4313-216">Les entrées d'index XML apparaissent dans l'affichage catalogue, sys.indexes, avec l'index de « type » 3.</span><span class="sxs-lookup"><span data-stu-id="c4313-216">XML index entries appear in the catalog view, sys.indexes, with the index "type" 3.</span></span> <span data-ttu-id="c4313-217">La colonne name contient le nom de l'index XML.</span><span class="sxs-lookup"><span data-stu-id="c4313-217">The name column contains the name of the XML index.</span></span>  
  
 <span data-ttu-id="c4313-218">Les index XML sont également enregistrés dans l'affichage catalogue, sys.xml_indexes,</span><span class="sxs-lookup"><span data-stu-id="c4313-218">XML indexes are also recorded in the catalog view, sys.xml_indexes.</span></span> <span data-ttu-id="c4313-219">qui contient toutes les colonnes de sys.indexes, ainsi que d'autres plus spécifiques et utiles aux index XML.</span><span class="sxs-lookup"><span data-stu-id="c4313-219">This contains all the columns of sys.indexes and some specific ones that are useful for XML indexes.</span></span> <span data-ttu-id="c4313-220">La valeur NULL de la colonne, secondary_type, indique qu'il s'agit d'un index XML primaire ; les valeurs « P », « R » et « V » représentent respectivement les index XML secondaires PATH, PROPERTY et VALUE.</span><span class="sxs-lookup"><span data-stu-id="c4313-220">The value NULL in the column, secondary_type, indicates a primary XML index; the values 'P', 'R' and 'V' stand for PATH, PROPERTY, and VALUE secondary XML indexes, respectively.</span></span>  
  
 <span data-ttu-id="c4313-221">L’espace utilisé par les index XML figure dans la fonction table [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql),</span><span class="sxs-lookup"><span data-stu-id="c4313-221">The space use of XML indexes can be found in the table-valued function [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql).</span></span> <span data-ttu-id="c4313-222">qui fournit des informations telles que le nombre de pages disque occupées, la taille moyenne des lignes en octets et le nombre d'enregistrements, pour tous les types d'index.</span><span class="sxs-lookup"><span data-stu-id="c4313-222">It provides information, such as the number of disk pages occupied, average row size in bytes, and number of records, for all index types..</span></span> <span data-ttu-id="c4313-223">Vous y trouvez également les index XML.</span><span class="sxs-lookup"><span data-stu-id="c4313-223">This also includes XML indexes.</span></span> <span data-ttu-id="c4313-224">Ces informations sont disponibles pour chaque partition de la base de données.</span><span class="sxs-lookup"><span data-stu-id="c4313-224">This information is available for each database partition.</span></span> <span data-ttu-id="c4313-225">Les index XML utilisent le même schéma et la même fonction de partitionnement que la table de base.</span><span class="sxs-lookup"><span data-stu-id="c4313-225">XML indexes use the same partitioning scheme and partitioning function of the base table.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c4313-226">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="c4313-226">See Also</span></span>  
 <span data-ttu-id="c4313-227">[sys.dm_db_index_physical_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="c4313-227">[sys.dm_db_index_physical_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) </span></span>  
 [<span data-ttu-id="c4313-228">Données XML &#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="c4313-228">XML Data &#40;SQL Server&#41;</span></span>](../xml/xml-data-sql-server.md)  
  
  
