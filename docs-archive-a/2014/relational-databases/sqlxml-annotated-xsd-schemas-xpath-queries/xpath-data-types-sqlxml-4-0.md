---
title: Types de données XPath (SQLXML 4,0) | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- mapping XDR types to XPath types [SQLXML]
- data types [XPath]
- arithmetic operators
- mapping data types [SQLXML]
- relational operators [SQLXML]
- node-set [SQLXML]
- data types [SQLXML], XPath
- XPath operators [SQLXML]
- XDR data type [SQLXML]
- equality operators [SQLXML]
- XPath conversions [SQLXML]
- converting data types [SQLXML]
- Boolean operators
- XPath queries [SQLXML], data types
- XPath data types [SQLXML]
- operators [SQLXML]
ms.assetid: a90374bf-406f-4384-ba81-59478017db68
author: rothja
ms.author: jroth
ms.openlocfilehash: 846fc5a17ac97d30b6f0ab65fee176ac459c20cc
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87611688"
---
# <a name="xpath-data-types-sqlxml-40"></a><span data-ttu-id="016e1-102">Types de données XPath (SQLXML 4.0)</span><span class="sxs-lookup"><span data-stu-id="016e1-102">XPath Data Types (SQLXML 4.0)</span></span>
  [!INCLUDE[msCoName](../../includes/msconame-md.md)]<span data-ttu-id="016e1-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath et le schéma XML (XSD) ont des types de données très différents.</span><span class="sxs-lookup"><span data-stu-id="016e1-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath, and XML Schema (XSD) have very different data types.</span></span> <span data-ttu-id="016e1-104">Par exemple, XPath n'affiche aucun type de données integer ou date tandis que [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] et XSD en possèdent un grand nombre.</span><span class="sxs-lookup"><span data-stu-id="016e1-104">For example, XPath does not have integer or date data types, but [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] and XSD have many.</span></span> <span data-ttu-id="016e1-105">XSD utilise une précision à la nanoseconde pour les valeurs temporelles ; [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] affiche au maximum une précision de 1/300ème de seconde.</span><span class="sxs-lookup"><span data-stu-id="016e1-105">XSD uses nanosecond precision for time values, and [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] uses at most 1/300-second precision.</span></span> <span data-ttu-id="016e1-106">Par conséquent, le mappage d'un type de données à un autre n'est pas toujours possible.</span><span class="sxs-lookup"><span data-stu-id="016e1-106">Consequently, mapping one data type to another is not always possible.</span></span> <span data-ttu-id="016e1-107">Pour plus d’informations sur [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] le mappage des types de données aux types de données XSD, consultez [forçages de type de données et annotation sql : DataType &#40;SQLXML 4,0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span><span class="sxs-lookup"><span data-stu-id="016e1-107">For more information about mapping [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data types to XSD data types, see [Data Type Coercions and the sql:datatype Annotation &#40;SQLXML 4.0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span></span>  
  
 <span data-ttu-id="016e1-108">XPath possède trois types de données : `string`, `number` et `boolean`.</span><span class="sxs-lookup"><span data-stu-id="016e1-108">XPath has three data types: `string`, `number`, and `boolean`.</span></span> <span data-ttu-id="016e1-109">Le type de données `number` est toujours une valeur à virgule flottante double précision IEEE 754.</span><span class="sxs-lookup"><span data-stu-id="016e1-109">The `number` data type is always an IEEE 754 double-precision floating-point.</span></span> <span data-ttu-id="016e1-110">Le [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `float(53)` type de données est le plus proche de XPath `number` .</span><span class="sxs-lookup"><span data-stu-id="016e1-110">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`float(53)` data type is the closest to XPath `number`.</span></span> <span data-ttu-id="016e1-111">Toutefois, le type `float(53)` n'est pas exactement une valeur IEEE 754.</span><span class="sxs-lookup"><span data-stu-id="016e1-111">However, `float(53)` is not exactly IEEE 754.</span></span> <span data-ttu-id="016e1-112">Par exemple, ni la valeur NaN (Not-a-Number,), ni une valeur infinie n'est employée.</span><span class="sxs-lookup"><span data-stu-id="016e1-112">For example, neither NaN (Not-a-Number) nor infinity is used.</span></span> <span data-ttu-id="016e1-113">Toute tentative de conversion d'une chaîne non numérique en type `number` et de division par zéro entraîne une erreur.</span><span class="sxs-lookup"><span data-stu-id="016e1-113">Attempting to convert a nonnumeric string to `number` and trying to divide by zero results in an error.</span></span>  
  
## <a name="xpath-conversions"></a><span data-ttu-id="016e1-114">Conversions XPath</span><span class="sxs-lookup"><span data-stu-id="016e1-114">XPath Conversions</span></span>  
 <span data-ttu-id="016e1-115">Lorsque vous utilisez une requête XPath, telle que `OrderDetail[@UnitPrice > "10.0"]`, les conversions de type de données implicites et explicites peuvent modifier la signification de la requête de manière subtile.</span><span class="sxs-lookup"><span data-stu-id="016e1-115">When you use an XPath query such as `OrderDetail[@UnitPrice > "10.0"]`, implicit and explicit data type conversions can change the meaning of the query in subtle ways.</span></span> <span data-ttu-id="016e1-116">Par conséquent, il est primordial de comprendre la manière dont les types de données Xpath sont implémentés.</span><span class="sxs-lookup"><span data-stu-id="016e1-116">Therefore, it is important to understand how XPath data types are implemented.</span></span> <span data-ttu-id="016e1-117">La spécification du langage XPath, XML Path Language (XPath) version 1,0 W3C proposed Recommendation 8 octobre 1999, est disponible sur le site Web du W3C à l’adresse http://www.w3.org/TR/1999/PR-xpath-19991008.html .</span><span class="sxs-lookup"><span data-stu-id="016e1-117">The XPath language specification, XML Path Language (XPath) version 1.0 W3C Proposed Recommendation 8 October 1999, can be found at the W3C Web site at http://www.w3.org/TR/1999/PR-xpath-19991008.html.</span></span>  
  
 <span data-ttu-id="016e1-118">Les opérateurs XPath sont divisés en quatre catégories :</span><span class="sxs-lookup"><span data-stu-id="016e1-118">XPath operators are divided into four categories:</span></span>  
  
-   <span data-ttu-id="016e1-119">Opérateurs booléens (et, ou)</span><span class="sxs-lookup"><span data-stu-id="016e1-119">Boolean operators (and, or)</span></span>  
  
-   <span data-ttu-id="016e1-120">Opérateurs relationnels ( \<, > , \<=, > =)</span><span class="sxs-lookup"><span data-stu-id="016e1-120">Relational operators (\<, >, \<=, >=)</span></span>  
  
-   <span data-ttu-id="016e1-121">Opérateurs d'égalité (=, !=)</span><span class="sxs-lookup"><span data-stu-id="016e1-121">Equality operators (=, !=)</span></span>  
  
-   <span data-ttu-id="016e1-122">Opérateurs arithmétiques (+, -, \*, div, mod)</span><span class="sxs-lookup"><span data-stu-id="016e1-122">Arithmetic operators (+, -, \*, div, mod)</span></span>  
  
 <span data-ttu-id="016e1-123">Chaque catégorie d'opérateur convertit ses opérandes de manière distincte.</span><span class="sxs-lookup"><span data-stu-id="016e1-123">Each category of operator converts its operands differently.</span></span> <span data-ttu-id="016e1-124">Les opérateurs XPath convertissent implicitement leurs opérandes si cela est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="016e1-124">XPath operators implicitly convert their operands if necessary.</span></span> <span data-ttu-id="016e1-125">Les opérateurs arithmétiques convertissent leurs opérandes en type `number` et génèrent une valeur numérique.</span><span class="sxs-lookup"><span data-stu-id="016e1-125">Arithmetic operators convert their operands to `number`, and result in a number value.</span></span> <span data-ttu-id="016e1-126">Les opérateurs booléens convertissent leurs opérandes en `boolean` et génèrent une valeur booléenne.</span><span class="sxs-lookup"><span data-stu-id="016e1-126">Boolean operators convert their operands to `boolean`, and result in a Boolean value.</span></span> <span data-ttu-id="016e1-127">Les opérateurs relationnels et d'égalité génèrent une valeur booléenne.</span><span class="sxs-lookup"><span data-stu-id="016e1-127">Relational operators and equality operators result in a Boolean value.</span></span> <span data-ttu-id="016e1-128">Toutefois, ils suivent des règles de conversion différentes en fonction des types de données d'origine de leurs opérandes comme le montre le tableau ci-après.</span><span class="sxs-lookup"><span data-stu-id="016e1-128">However, they have different conversion rules depending on the original data types of their operands, as shown in this table.</span></span>  
  
|<span data-ttu-id="016e1-129">Opérande</span><span class="sxs-lookup"><span data-stu-id="016e1-129">Operand</span></span>|<span data-ttu-id="016e1-130">Opérateur relationnel</span><span class="sxs-lookup"><span data-stu-id="016e1-130">Relational operator</span></span>|<span data-ttu-id="016e1-131">Opérateur d’égalité</span><span class="sxs-lookup"><span data-stu-id="016e1-131">Equality operator</span></span>|  
|-------------|-------------------------|-----------------------|  
|<span data-ttu-id="016e1-132">Les deux opérandes sont des éléments node-set.</span><span class="sxs-lookup"><span data-stu-id="016e1-132">Both operands are node-sets.</span></span>|<span data-ttu-id="016e1-133">TRUE si et uniquement s'il existe un nœud dans un jeu et un nœud dans le deuxième jeu justifiant que la comparaison de leurs valeurs `string` soit TRUE.</span><span class="sxs-lookup"><span data-stu-id="016e1-133">TRUE if and only if there is a node in one set and a node in the second set such that the comparison of their `string` values is TRUE.</span></span>|<span data-ttu-id="016e1-134">Idem.</span><span class="sxs-lookup"><span data-stu-id="016e1-134">Same.</span></span>|  
|<span data-ttu-id="016e1-135">L'un est un élément node-set, l'autre est de type `string`.</span><span class="sxs-lookup"><span data-stu-id="016e1-135">One is a node-set, the other a `string`.</span></span>|<span data-ttu-id="016e1-136">TRUE si et uniquement s'il existe un nœud dans l'élément node-set de sorte que, en cas de conversion en type `number`, sa comparaison avec la valeur `string` convertie en `number` est TRUE.</span><span class="sxs-lookup"><span data-stu-id="016e1-136">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `string` converted to `number` is TRUE.</span></span>|<span data-ttu-id="016e1-137">TRUE si et uniquement s'il existe un nœud dans l'élément node-set de sorte que, en cas de conversion en type `string`, sa comparaison avec la valeur `string` est TRUE.</span><span class="sxs-lookup"><span data-stu-id="016e1-137">TRUE if and only if there is a node in the node-set such that when converted to `string`, the comparison of it with the `string` is TRUE.</span></span>|  
|<span data-ttu-id="016e1-138">L'un est un élément node-set, l'autre est de type `number`.</span><span class="sxs-lookup"><span data-stu-id="016e1-138">One is a node-set, the other a `number`.</span></span>|<span data-ttu-id="016e1-139">TRUE si et uniquement s'il existe un nœud dans l'élément node-set de sorte que, en cas de conversion en type `number`, sa comparaison avec la valeur `number` est TRUE.</span><span class="sxs-lookup"><span data-stu-id="016e1-139">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `number` is TRUE.</span></span>|<span data-ttu-id="016e1-140">Idem.</span><span class="sxs-lookup"><span data-stu-id="016e1-140">Same.</span></span>|  
|<span data-ttu-id="016e1-141">L'un est un élément node-set, l'autre est de type `boolean`.</span><span class="sxs-lookup"><span data-stu-id="016e1-141">One is a node-set, the other a `boolean`.</span></span>|<span data-ttu-id="016e1-142">TRUE si et uniquement s'il existe un nœud dans l'élément node-set de sorte que, en cas de conversion en type `boolean`, puis en type `number`, sa comparaison avec la valeur `boolean` convertie en `number` est TRUE.</span><span class="sxs-lookup"><span data-stu-id="016e1-142">TRUE if and only if there is a node in the node-set such that when converted to `boolean` and then to `number`, the comparison of it with the `boolean` converted to `number` is TRUE.</span></span>|<span data-ttu-id="016e1-143">TRUE si et uniquement s'il existe un nœud dans l'élément node-set de sorte que, en cas de conversion en type `boolean`, sa comparaison avec la valeur `boolean` est TRUE.</span><span class="sxs-lookup"><span data-stu-id="016e1-143">TRUE if and only if there is a node in the node-set such that when converted to `boolean`, the comparison of it with the `boolean` is TRUE.</span></span>|  
|<span data-ttu-id="016e1-144">Ni l'un ni l'autre n'est un élément node-set.</span><span class="sxs-lookup"><span data-stu-id="016e1-144">Neither is a node-set.</span></span>|<span data-ttu-id="016e1-145">Convertissez les deux opérandes en type `number`, puis comparez-les.</span><span class="sxs-lookup"><span data-stu-id="016e1-145">Convert both operands to `number` and then compare.</span></span>|<span data-ttu-id="016e1-146">Convertissez les deux opérandes en un type commun, puis comparez-les.</span><span class="sxs-lookup"><span data-stu-id="016e1-146">Convert both operands to a common type and then compare.</span></span> <span data-ttu-id="016e1-147">Convertissez en type `boolean` si l'une des valeurs est de type `boolean`, en `number` si l'une des valeurs est de type `number` ; sinon, effectuez une conversion en type `string`.</span><span class="sxs-lookup"><span data-stu-id="016e1-147">Convert to `boolean` if either is `boolean`, `number` if either is `number`; otherwise, convert to `string`.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="016e1-148">Parce que les opérateurs relationnels XPath convertissent toujours leurs opérandes en `number`, les comparaisons de valeurs `string` ne sont pas possibles.</span><span class="sxs-lookup"><span data-stu-id="016e1-148">Because XPath relational operators always convert their operands to `number`, `string` comparisons are not possible.</span></span> <span data-ttu-id="016e1-149">Pour inclure des comparaisons de date, SQL Server 2000 propose la variante suivante par rapport à la recommandation XPath : lorsqu'un opérateur relationnel compare une valeur `string` à une autre valeur `string`, un élément node-set à une valeur `string`, ou deux éléments node-set à valeur de chaîne entre eux, une comparaison de la valeur `string` (et non une comparaison de `number`) a lieu.</span><span class="sxs-lookup"><span data-stu-id="016e1-149">To include date comparisons, SQL Server 2000 offers this variation to the XPath specification: When a relational operator compares a `string` to a `string`, a node-set to a `string`, or a string-valued node-set to a string-valued node-set, a `string` comparison (not a `number` comparison) is performed.</span></span>  
  
## <a name="node-set-conversions"></a><span data-ttu-id="016e1-150">Conversions des éléments node-set</span><span class="sxs-lookup"><span data-stu-id="016e1-150">Node-Set Conversions</span></span>  
 <span data-ttu-id="016e1-151">Les conversions des éléments node-set ne sont pas toujours intuitives.</span><span class="sxs-lookup"><span data-stu-id="016e1-151">Node-set conversions are not always intuitive.</span></span> <span data-ttu-id="016e1-152">Un élément node-set est converti en type `string` par extraction de la valeur de chaîne du premier nœud du jeu uniquement.</span><span class="sxs-lookup"><span data-stu-id="016e1-152">A node-set is converted to a `string` by taking the string value of only the first node in the set.</span></span> <span data-ttu-id="016e1-153">Pour être converti en type `number`, un élément node-set est d'abord converti en type `string`, puis le type `string` est converti en type `number`.</span><span class="sxs-lookup"><span data-stu-id="016e1-153">A node-set is converted to `number` by converting it to `string`, and then converting `string` to `number`.</span></span> <span data-ttu-id="016e1-154">Pour convertir un élément node-set en type `boolean`, vous devez d'abord le tester pour vérifier s'il existe.</span><span class="sxs-lookup"><span data-stu-id="016e1-154">A node-set is converted to `boolean` by testing for its existence.</span></span>  
  
> [!NOTE]  
>  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="016e1-155">ne procède à aucune sélection positionnelle sur les éléments node-set : par exemple, la requête XPath `Customer[3]` désigne le troisième client ; ce type de sélection positionnelle n'est pas pris en charge dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="016e1-155">does not perform positional selection on node-sets: for example, the XPath query `Customer[3]` means the third customer; this type of positional selection is not supported in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="016e1-156">Par conséquent, les conversions d'élément node-set en `string` ou d'élément node-set en `number`, telles que décrites dans la recommandation XPath, ne sont pas implémentées.</span><span class="sxs-lookup"><span data-stu-id="016e1-156">Therefore, the node-set-to-`string` or node-set-to-`number` conversions as described by the XPath specification are not implemented.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="016e1-157">utilise une sémantique « quelconque » partout où la recommandation XPath spécifie la « première » sémantique.</span><span class="sxs-lookup"><span data-stu-id="016e1-157">uses "any" semantics wherever the XPath specification specifies "first" semantics.</span></span> <span data-ttu-id="016e1-158">Par exemple, en fonction de la spécification XPath du W3C, la requête XPath `Order[OrderDetail/@UnitPrice > 10.0]` sélectionne les commandes avec le premier **OrderDetail** dont la valeur **UnitPrice** est supérieure à 10,0.</span><span class="sxs-lookup"><span data-stu-id="016e1-158">For example, based on the W3C XPath specification, the XPath query `Order[OrderDetail/@UnitPrice > 10.0]` selects those orders with the first **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span> <span data-ttu-id="016e1-159">Dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , cette requête XPath sélectionne les commandes avec un **OrderDetail** dont la valeur **UnitPrice** est supérieure à 10,0.</span><span class="sxs-lookup"><span data-stu-id="016e1-159">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], this XPath query selects those orders with any **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span>  
  
 <span data-ttu-id="016e1-160">La conversion en valeur `boolean` implique un test de vérification d'existence ; la requête XPath `Products[@Discontinued=true()]` équivaut donc à l'expression SQL « Products.Discontinued is not null » et non à l'expression SQL « Products.Discontinued = 1 ».</span><span class="sxs-lookup"><span data-stu-id="016e1-160">Conversion to `boolean` generates an existence test; therefore, the XPath query `Products[@Discontinued=true()]` is equivalent to the SQL expression "Products.Discontinued is not null", not the SQL expression "Products.Discontinued = 1".</span></span> <span data-ttu-id="016e1-161">Pour que la requête équivaille à la dernière expression SQL, convertissez avant tout l'élément node-set en type non `boolean`, tel que `number`.</span><span class="sxs-lookup"><span data-stu-id="016e1-161">To make the query equivalent to the latter SQL expression, first convert the node-set to a non-`boolean` type, such as `number`.</span></span> <span data-ttu-id="016e1-162">Par exemple, `Products[number(@Discontinued) = true()]`.</span><span class="sxs-lookup"><span data-stu-id="016e1-162">For example, `Products[number(@Discontinued) = true()]`.</span></span>  
  
 <span data-ttu-id="016e1-163">Du fait que la plupart des opérateurs sont définis pour être vrais (TRUE) s'ils le sont pour un nœud quelconque ou l'un des nœuds de l'élément node-set, ces opérations prennent toujours la valeur FALSE si l'élément node-set est vide.</span><span class="sxs-lookup"><span data-stu-id="016e1-163">Because most operators are defined to be TRUE if they are TRUE for any or one of the nodes in the node-set, these operations always evaluate to FALSE if the node-set is empty.</span></span> <span data-ttu-id="016e1-164">Ainsi donc, si A est vide, `A = B` et `A != B` ont tous les deux la valeur FALSE et `not(A=B)` et `not(A!=B)` ont la valeur TRUE.</span><span class="sxs-lookup"><span data-stu-id="016e1-164">Thus, if A is empty, both `A = B` and `A != B` are FALSE, and `not(A=B)` and `not(A!=B)` are TRUE.</span></span>  
  
 <span data-ttu-id="016e1-165">En règle générale, un attribut ou un élément mappé à une colonne existe si la valeur de cette colonne dans la base de données n'est pas `null`.</span><span class="sxs-lookup"><span data-stu-id="016e1-165">Usually, an attribute or element that maps to a column exists if the value of that column in the database is not `null`.</span></span> <span data-ttu-id="016e1-166">Les éléments mappés aux lignes existent si tous leurs enfants existent.</span><span class="sxs-lookup"><span data-stu-id="016e1-166">Elements that map to rows exist if any of their children exist.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="016e1-167">Les éléments annotés avec `is-constant` existent toujours.</span><span class="sxs-lookup"><span data-stu-id="016e1-167">Elements annotated with `is-constant` always exist.</span></span> <span data-ttu-id="016e1-168">Par conséquent, les prédicats XPath ne peuvent être utilisés dans des éléments `is-constant`.</span><span class="sxs-lookup"><span data-stu-id="016e1-168">Consequently, XPath predicates cannot be used on `is-constant` elements.</span></span>  
  
 <span data-ttu-id="016e1-169">Lorsque vous convertissez un élément node-set en type `string` ou `number`, son type XDR (le cas échéant) est examiné dans le schéma annoté et utilisé pour déterminer la conversion requise.</span><span class="sxs-lookup"><span data-stu-id="016e1-169">When a node-set is converted to `string` or `number`, its XDR type (if any) is inspected in the annotated schema and that type is used to determine the conversion that is required.</span></span>  
  
## <a name="mapping-xdr-data-types-to-xpath-data-types"></a><span data-ttu-id="016e1-170">Mappage des types de données XDR et XPath</span><span class="sxs-lookup"><span data-stu-id="016e1-170">Mapping XDR Data Types to XPath Data Types</span></span>  
 <span data-ttu-id="016e1-171">Le type de données XPath d’un nœud est dérivé du type de données XDR dans le schéma, comme indiqué dans le tableau suivant (le nœud **EmployeeID** est utilisé à des fins d’illustration).</span><span class="sxs-lookup"><span data-stu-id="016e1-171">The XPath data type of a node is derived from the XDR data type in the schema, as shown in the following table (the node **EmployeeID** is used for illustrative purpose).</span></span>  
  
|<span data-ttu-id="016e1-172">Type de données XDR</span><span class="sxs-lookup"><span data-stu-id="016e1-172">XDR data type</span></span>|<span data-ttu-id="016e1-173">Équivalent</span><span class="sxs-lookup"><span data-stu-id="016e1-173">Equivalent</span></span><br /><br /> <span data-ttu-id="016e1-174">Type de données XPath</span><span class="sxs-lookup"><span data-stu-id="016e1-174">XPath data type</span></span>|<span data-ttu-id="016e1-175">Conversion SQL Server utilisée</span><span class="sxs-lookup"><span data-stu-id="016e1-175">SQL Server conversion used</span></span>|  
|-------------------|------------------------------------|--------------------------------|  
|<span data-ttu-id="016e1-176">Nonebin.base64bin.hex</span><span class="sxs-lookup"><span data-stu-id="016e1-176">Nonebin.base64bin.hex</span></span>|<span data-ttu-id="016e1-177">N/A</span><span class="sxs-lookup"><span data-stu-id="016e1-177">N/A</span></span>|<span data-ttu-id="016e1-178">NoneEmployeeID</span><span class="sxs-lookup"><span data-stu-id="016e1-178">NoneEmployeeID</span></span>|  
|<span data-ttu-id="016e1-179">boolean</span><span class="sxs-lookup"><span data-stu-id="016e1-179">boolean</span></span>|<span data-ttu-id="016e1-180">boolean</span><span class="sxs-lookup"><span data-stu-id="016e1-180">boolean</span></span>|<span data-ttu-id="016e1-181">CONVERT(bit, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="016e1-181">CONVERT(bit, EmployeeID)</span></span>|  
|<span data-ttu-id="016e1-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span><span class="sxs-lookup"><span data-stu-id="016e1-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span></span>|<span data-ttu-id="016e1-183">nombre</span><span class="sxs-lookup"><span data-stu-id="016e1-183">number</span></span>|<span data-ttu-id="016e1-184">CONVERT(float(53), EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="016e1-184">CONVERT(float(53), EmployeeID)</span></span>|  
|<span data-ttu-id="016e1-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span><span class="sxs-lookup"><span data-stu-id="016e1-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span></span>|<span data-ttu-id="016e1-186">string</span><span class="sxs-lookup"><span data-stu-id="016e1-186">string</span></span>|<span data-ttu-id="016e1-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span><span class="sxs-lookup"><span data-stu-id="016e1-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span></span>|  
|<span data-ttu-id="016e1-188">fixed14.4</span><span class="sxs-lookup"><span data-stu-id="016e1-188">fixed14.4</span></span>|<span data-ttu-id="016e1-189">N/A (aucun type de données XPath n'équivaut au type de données XDR fixed14.4)</span><span class="sxs-lookup"><span data-stu-id="016e1-189">N/A(There is no data type in XPath that is equivalent to the fixed14.4 XDR data type)</span></span>|<span data-ttu-id="016e1-190">CONVERT(money, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="016e1-190">CONVERT(money, EmployeeID)</span></span>|  
|<span data-ttu-id="016e1-191">Date</span><span class="sxs-lookup"><span data-stu-id="016e1-191">date</span></span>|<span data-ttu-id="016e1-192">string</span><span class="sxs-lookup"><span data-stu-id="016e1-192">string</span></span>|<span data-ttu-id="016e1-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span><span class="sxs-lookup"><span data-stu-id="016e1-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span></span>|  
|<span data-ttu-id="016e1-194">time</span><span class="sxs-lookup"><span data-stu-id="016e1-194">time</span></span><br /><br /> <span data-ttu-id="016e1-195">time.tz</span><span class="sxs-lookup"><span data-stu-id="016e1-195">time.tz</span></span>|<span data-ttu-id="016e1-196">string</span><span class="sxs-lookup"><span data-stu-id="016e1-196">string</span></span>|<span data-ttu-id="016e1-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span><span class="sxs-lookup"><span data-stu-id="016e1-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span></span>|  
  
 <span data-ttu-id="016e1-198">Les conversions de date et d’heure sont conçues pour fonctionner, que la valeur soit stockée dans la base de données à l’aide du [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` type de données ou d’un `string` .</span><span class="sxs-lookup"><span data-stu-id="016e1-198">The date and time conversions are designed to work whether the value is stored in the database using the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type or a `string`.</span></span> <span data-ttu-id="016e1-199">Notez que le [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` type de données n’utilise pas `timezone` et a une précision inférieure à celle du `time` type de données XML.</span><span class="sxs-lookup"><span data-stu-id="016e1-199">Note that the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type does not use `timezone` and has a smaller precision than the XML `time` data type.</span></span> <span data-ttu-id="016e1-200">Pour inclure le type de données `timezone` ou apporter une précision supplémentaire, stockez les données dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] avec un type `string`.</span><span class="sxs-lookup"><span data-stu-id="016e1-200">To include the `timezone` data type or additional precision, store the data in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] using a `string` type.</span></span>  
  
 <span data-ttu-id="016e1-201">Lorsque vous convertissez un nœud du type de données XDR en type de données XPath, une conversion supplémentaire est parfois nécessaire (d'un type de données XPath vers un autre type de données XPath).</span><span class="sxs-lookup"><span data-stu-id="016e1-201">When a node is converted from its XDR data type to the XPath data type, additional conversion is sometimes necessary (from one XPath data type to another XPath data type).</span></span> <span data-ttu-id="016e1-202">Par exemple, imaginez la requête XPath suivante :</span><span class="sxs-lookup"><span data-stu-id="016e1-202">For example, consider this XPath query:</span></span>  
  
```  
(@m + 3) = 4  
```  
  
 <span data-ttu-id="016e1-203">Si @m est du `fixed14.4` type de données XDR, la conversion du type de données XDR en type de données XPath s’effectue à l’aide de :</span><span class="sxs-lookup"><span data-stu-id="016e1-203">If @m is of the `fixed14.4` XDR data type, the conversion from XDR data type to XPath data type is accomplished using:</span></span>  
  
```  
CONVERT(money, m)  
```  
  
 <span data-ttu-id="016e1-204">Dans le cadre de cette conversion, le nœud `m` passe du type `fixed14.4` au type `money`.</span><span class="sxs-lookup"><span data-stu-id="016e1-204">In this conversion, the node `m` is converted from `fixed14.4` to `money`.</span></span> <span data-ttu-id="016e1-205">Toutefois, l'ajout de la valeur 3 nécessite une autre conversion :</span><span class="sxs-lookup"><span data-stu-id="016e1-205">However, adding the value of 3, requires additional conversion:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m))  
```  
  
 <span data-ttu-id="016e1-206">L'expression XPath est évaluée comme suit :</span><span class="sxs-lookup"><span data-stu-id="016e1-206">The XPath expression is evaluated as:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m)) + CONVERT(float(53), 3) = CONVERT(float(53), 3)  
```  
  
 <span data-ttu-id="016e1-207">Comme le montre le tableau ci-dessous, il s'agit de la même conversion que celle appliquée à d'autres expressions XPath (telles que des littéraux ou des expressions composées).</span><span class="sxs-lookup"><span data-stu-id="016e1-207">As shown in the following table, this is the same conversion that is applied for other XPath expressions (such as literals or compound expressions).</span></span>  
  
||||||  
|-|-|-|-|-|  
||<span data-ttu-id="016e1-208">X est inconnu</span><span class="sxs-lookup"><span data-stu-id="016e1-208">X is unknown</span></span>|<span data-ttu-id="016e1-209">X est de type `string`</span><span class="sxs-lookup"><span data-stu-id="016e1-209">X is `string`</span></span>|<span data-ttu-id="016e1-210">X est de type `number`</span><span class="sxs-lookup"><span data-stu-id="016e1-210">X is `number`</span></span>|<span data-ttu-id="016e1-211">X est de type `boolean`</span><span class="sxs-lookup"><span data-stu-id="016e1-211">X is `boolean`</span></span>|  
|<span data-ttu-id="016e1-212">string(X)</span><span class="sxs-lookup"><span data-stu-id="016e1-212">string(X)</span></span>|<span data-ttu-id="016e1-213">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="016e1-213">CONVERT (nvarchar(4000), X, 126)</span></span>|-|<span data-ttu-id="016e1-214">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="016e1-214">CONVERT (nvarchar(4000), X, 126)</span></span>|<span data-ttu-id="016e1-215">CASE WHEN X THEN N'true' ELSE N'false' END</span><span class="sxs-lookup"><span data-stu-id="016e1-215">CASE WHEN X THEN N'true' ELSE N'false' END</span></span>|  
|<span data-ttu-id="016e1-216">number(X)</span><span class="sxs-lookup"><span data-stu-id="016e1-216">number(X)</span></span>|<span data-ttu-id="016e1-217">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="016e1-217">CONVERT (float(53), X)</span></span>|<span data-ttu-id="016e1-218">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="016e1-218">CONVERT (float(53), X)</span></span>|-|<span data-ttu-id="016e1-219">CASE WHEN X THEN 1 ELSE 0 END</span><span class="sxs-lookup"><span data-stu-id="016e1-219">CASE WHEN X THEN 1 ELSE 0 END</span></span>|  
|<span data-ttu-id="016e1-220">boolean(X)</span><span class="sxs-lookup"><span data-stu-id="016e1-220">boolean(X)</span></span>|-|<span data-ttu-id="016e1-221">LEN (X) > 0</span><span class="sxs-lookup"><span data-stu-id="016e1-221">LEN(X) > 0</span></span>|<span data-ttu-id="016e1-222">X != 0</span><span class="sxs-lookup"><span data-stu-id="016e1-222">X != 0</span></span>|-|  
  
## <a name="examples"></a><span data-ttu-id="016e1-223">Exemples</span><span class="sxs-lookup"><span data-stu-id="016e1-223">Examples</span></span>  
  
### <a name="a-convert-a-data-type-in-an-xpath-query"></a><span data-ttu-id="016e1-224">R.</span><span class="sxs-lookup"><span data-stu-id="016e1-224">A.</span></span> <span data-ttu-id="016e1-225">Convertir un type de données dans une requête XPath</span><span class="sxs-lookup"><span data-stu-id="016e1-225">Convert a data type in an XPath query</span></span>  
 <span data-ttu-id="016e1-226">Dans la requête XPath suivante spécifiée par rapport à un schéma XSD annoté, la requête sélectionne tous les nœuds **Employee** avec la valeur d’attribut **EmployeeID** de E-1, où « e- » est le préfixe spécifié à l’aide de l' `sql:id-prefix` annotation.</span><span class="sxs-lookup"><span data-stu-id="016e1-226">In the following XPath query specified against an annotated XSD schema, the query selects all **Employee** nodes with the **EmployeeID** attribute value of E-1, where "E-" is the prefix specified using the `sql:id-prefix` annotation.</span></span>  
  
 `Employee[@EmployeeID="E-1"]`  
  
 <span data-ttu-id="016e1-227">Le prédicat dans la requête équivaut à l'expression SQL suivante :</span><span class="sxs-lookup"><span data-stu-id="016e1-227">The predicate in the query is equivalent to the SQL expression:</span></span>  
  
 `N'E-' + CONVERT(nvarchar(4000), Employees.EmployeeID, 126) = N'E-1'`  
  
 <span data-ttu-id="016e1-228">**EmployeeID** étant l’une des `id` valeurs de `idref` type de données (,,,, etc. `idrefs` `nmtoken` `nmtokens` ) dans le schéma XSD, **EmployeeID** est converti en `string` type de données XPath à l’aide des règles de conversion décrites précédemment.</span><span class="sxs-lookup"><span data-stu-id="016e1-228">Because **EmployeeID** is one of the `id` (`idref`, `idrefs`, `nmtoken`, `nmtokens`, and so on) data type values in the XSD schema, **EmployeeID** is converted to the `string` XPath data type using the conversion rules described previously.</span></span>  
  
 `CONVERT(nvarchar(4000), Employees.EmployeeID, 126)`  
  
 <span data-ttu-id="016e1-229">Le préfixe  « E - » est ajouté à la chaîne et le résultat est ensuite comparé avec `N'E-1'`.</span><span class="sxs-lookup"><span data-stu-id="016e1-229">The "E-" prefix is added to the string, and the result is then compared with `N'E-1'`.</span></span>  
  
### <a name="b-perform-several-data-type-conversions-in-an-xpath-query"></a><span data-ttu-id="016e1-230">B.</span><span class="sxs-lookup"><span data-stu-id="016e1-230">B.</span></span> <span data-ttu-id="016e1-231">Effectuer plusieurs conversions de types de données dans une requête XPath.</span><span class="sxs-lookup"><span data-stu-id="016e1-231">Perform several data type conversions in an XPath query</span></span>  
 <span data-ttu-id="016e1-232">Examinez la requête XPath suivante définie par rapport à un schéma XSD annoté : `OrderDetail[@UnitPrice * @OrderQty > 98]`</span><span class="sxs-lookup"><span data-stu-id="016e1-232">Consider this XPath query specified against an annotated XSD schema: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span></span>  
  
 <span data-ttu-id="016e1-233">Cette requête XPath retourne tous les **\<OrderDetail>** éléments qui satisfont au prédicat `@UnitPrice * @OrderQty > 98` .</span><span class="sxs-lookup"><span data-stu-id="016e1-233">This XPath query returns all the **\<OrderDetail>** elements satisfying the predicate `@UnitPrice * @OrderQty > 98`.</span></span> <span data-ttu-id="016e1-234">Si **UnitPrice** est annoté avec un `fixed14.4` type de données dans le schéma annoté, ce prédicat équivaut à l’expression SQL :</span><span class="sxs-lookup"><span data-stu-id="016e1-234">If the **UnitPrice** is annotated with a `fixed14.4` data type in the annotated schema, this predicate is equivalent to the SQL expression:</span></span>  
  
 `CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice)) * CONVERT(float(53), OrderDetail.OrderQty) > CONVERT(float(53), 98)`  
  
 <span data-ttu-id="016e1-235">Lors de la conversion des valeurs dans la requête XPath, la première conversion convertit le type de données XDR en type de données XPath.</span><span class="sxs-lookup"><span data-stu-id="016e1-235">In converting the values in the XPath query, the first conversion converts the XDR data type to the XPath data type.</span></span> <span data-ttu-id="016e1-236">Étant donné que le type de données XSD de **UnitPrice** est `fixed14.4` , comme décrit dans le tableau précédent, il s’agit de la première conversion utilisée :</span><span class="sxs-lookup"><span data-stu-id="016e1-236">Because the XSD data type of **UnitPrice** is `fixed14.4`, as described in the previous table, this is the first conversion that is used:</span></span>  
  
```  
CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="016e1-237">Du fait que les opérateurs arithmétiques convertissent leurs opérandes en type de données XPath `number`, la deuxième conversion (d'un type de données XPath à un autre) est appliquée là où la valeur est convertie en `float(53)` (`float(53)` est très proche du type de données XPath `number`) :</span><span class="sxs-lookup"><span data-stu-id="016e1-237">Because the arithmetic operators convert their operands to the `number` XPath data type, the second conversion (from one XPath data type to another XPath data type) is applied in which the value is converted to `float(53)` (`float(53)` is close to the XPath `number` data type):</span></span>  
  
```  
CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="016e1-238">En supposant que l’attribut **OrderQty** n’a pas de type de données XSD, **OrderQty** est converti en `number` type de données XPath en une seule conversion :</span><span class="sxs-lookup"><span data-stu-id="016e1-238">Assuming the **OrderQty** attribute has no XSD data type, **OrderQty** is converted to a `number` XPath data type in a single conversion:</span></span>  
  
```  
CONVERT(float(53), OrderDetail.OrderQty)  
```  
  
 <span data-ttu-id="016e1-239">La valeur 98 est également convertie en type de données XPath `number` :</span><span class="sxs-lookup"><span data-stu-id="016e1-239">Similarly, the value 98 is converted to the `number` XPath data type:</span></span>  
  
```  
CONVERT(float(53), 98)  
```  
  
> [!NOTE]  
>  <span data-ttu-id="016e1-240">Si le type de données XSD appliqué au schéma est incompatible avec le type de données [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] sous-jacent dans la base de données, ou si une conversion de type de données XPath impossible est réalisée, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] peut retourner une erreur.</span><span class="sxs-lookup"><span data-stu-id="016e1-240">If the XSD data type used in the schema is incompatible with the underlying [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data type in the database, or if an impossible XPath data type conversion is performed, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] may return an error.</span></span> <span data-ttu-id="016e1-241">Par exemple, si l’attribut **EmployeeID** est annoté avec `id-prefix` annotation, le XPath `Employee[@EmployeeID=1]` génère une erreur, car **EmployeeID** possède l' `id-prefix` annotation et ne peut pas être converti en `number` .</span><span class="sxs-lookup"><span data-stu-id="016e1-241">For example, if the **EmployeeID** attribute is annotated with `id-prefix` annotation, the XPath `Employee[@EmployeeID=1]` generates an error, because **EmployeeID** has the `id-prefix` annotation and cannot be converted to `number`.</span></span>  
  
  
