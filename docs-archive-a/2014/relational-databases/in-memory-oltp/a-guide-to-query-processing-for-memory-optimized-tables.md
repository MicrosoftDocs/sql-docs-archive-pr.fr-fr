---
title: Guide du traitement des requêtes pour les tables optimisées en mémoire | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 065296fe-6711-4837-965e-252ef6c13a0f
author: rothja
ms.author: jroth
ms.openlocfilehash: 93489e5dea295964826005e081bcffe889cb7586
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87612829"
---
# <a name="a-guide-to-query-processing-for-memory-optimized-tables"></a><span data-ttu-id="6059a-102">Guide du traitement des requêtes pour les tables optimisées en mémoire</span><span class="sxs-lookup"><span data-stu-id="6059a-102">A Guide to Query Processing for Memory-Optimized Tables</span></span>
  <span data-ttu-id="6059a-103">L'OLTP en mémoire introduit les tables mémoire optimisées et les procédures stockées compilées en mode natif dans [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="6059a-103">In-Memory OLTP introduces memory-optimized tables and natively compiled stored procedures in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="6059a-104">Cet article présente le traitement des requêtes pour les tables mémoire optimisées et les procédures stockées compilées en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6059a-104">This article gives an overview of query processing for both memory-optimized tables and natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="6059a-105">Le document explique comment les requêtes sur les tables mémoire optimisées sont compilées et exécutées, notamment :</span><span class="sxs-lookup"><span data-stu-id="6059a-105">The document explains how queries on memory-optimized tables are compiled and executed, including:</span></span>  
  
-   <span data-ttu-id="6059a-106">Le pipeline de traitement des requêtes dans [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] pour les tables sur disque.</span><span class="sxs-lookup"><span data-stu-id="6059a-106">The query processing pipeline in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for disk-based tables.</span></span>  
  
-   <span data-ttu-id="6059a-107">Optimisation des requêtes : rôle des statistiques sur les tables mémoire optimisées et instructions de dépannage pour les plans de requête non optimaux.</span><span class="sxs-lookup"><span data-stu-id="6059a-107">Query optimization; the role of statistics on memory-optimized tables as well as guidelines for troubleshooting bad query plans.</span></span>  
  
-   <span data-ttu-id="6059a-108">L'utilisation du [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété pour accéder aux tables mémoire optimisées.</span><span class="sxs-lookup"><span data-stu-id="6059a-108">The use of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] to access memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="6059a-109">Considérations relatives à l'optimisation des requêtes pour l'accès aux tables mémoire optimisées.</span><span class="sxs-lookup"><span data-stu-id="6059a-109">Considerations about query optimization for memory-optimized table access.</span></span>  
  
-   <span data-ttu-id="6059a-110">Compilation et traitement d'une procédure stockée compilée en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6059a-110">Natively compiled stored procedure compilation and processing.</span></span>  
  
-   <span data-ttu-id="6059a-111">Statistiques utilisées pour l'estimation de coût par l'optimiseur.</span><span class="sxs-lookup"><span data-stu-id="6059a-111">Statistics that are used for cost estimation by the optimizer.</span></span>  
  
-   <span data-ttu-id="6059a-112">Méthodes pour corriger des plans de requête non optimaux.</span><span class="sxs-lookup"><span data-stu-id="6059a-112">Ways to fix bad query plans.</span></span>  
  
## <a name="example-query"></a><span data-ttu-id="6059a-113">Exemple de requête</span><span class="sxs-lookup"><span data-stu-id="6059a-113">Example Query</span></span>  
 <span data-ttu-id="6059a-114">L'exemple suivant est utilisé pour illustrer les concepts de traitement des requêtes décrits dans cet article.</span><span class="sxs-lookup"><span data-stu-id="6059a-114">The following example will be used to illustrate the query processing concepts discussed in this article.</span></span>  
  
 <span data-ttu-id="6059a-115">Prenons deux tables, Customer et Order.</span><span class="sxs-lookup"><span data-stu-id="6059a-115">We consider two tables, Customer and Order.</span></span> <span data-ttu-id="6059a-116">Le script [!INCLUDE[tsql](../../../includes/tsql-md.md)] suivant contient les définitions des deux tables et des index associés, sur disque (au format traditionnel) :</span><span class="sxs-lookup"><span data-stu-id="6059a-116">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains the definitions for these two tables and associated indexes, in their (traditional) disk-based form:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY,  
  ContactName nvarchar (30) NOT NULL   
)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY,  
  CustomerID nchar (5) NOT NULL,  
  OrderDate date NOT NULL  
)  
GO  
CREATE INDEX IX_CustomerID ON dbo.[Order](CustomerID)  
GO  
CREATE INDEX IX_OrderDate ON dbo.[Order](OrderDate)  
GO  
```  
  
 <span data-ttu-id="6059a-117">Pour créer les plans de requête illustrés dans cet article, les deux tables ont été remplies avec les exemples de données tirés de la base de données Northwind, que vous pouvez télécharger sur [Exemples de bases de données Northwind et pubs pour SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span><span class="sxs-lookup"><span data-stu-id="6059a-117">For constructing the query plans shown in this article, the two tables were populated with sample data from the Northwind sample database, which you can download from [Northwind and pubs Sample Databases for SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span></span>  
  
 <span data-ttu-id="6059a-118">La requête suivante joint les tables Customer et Order, et retourne l'ID de la commande et les informations client associées :</span><span class="sxs-lookup"><span data-stu-id="6059a-118">Consider the following query, which joins the tables Customer and Order and returns the ID of the order and the associated customer information:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="6059a-119">Le plan d'exécution estimé tel qu'affiché par [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] est le suivant :</span><span class="sxs-lookup"><span data-stu-id="6059a-119">The estimated execution plan as displayed by [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] is as follows</span></span>  
  
 <span data-ttu-id="6059a-120">![Plan de requête pour joindre des tables sur disque.](../../database-engine/media/hekaton-query-plan-1.gif "Plan de requête pour joindre des tables sur disque.")</span><span class="sxs-lookup"><span data-stu-id="6059a-120">![Query plan for join of disk-based tables.](../../database-engine/media/hekaton-query-plan-1.gif "Query plan for join of disk-based tables.")</span></span>  
<span data-ttu-id="6059a-121">Plan de requête pour joindre des tables sur disque.</span><span class="sxs-lookup"><span data-stu-id="6059a-121">Query plan for join of disk-based tables.</span></span>  
  
 <span data-ttu-id="6059a-122">À propos de ce plan de requête :</span><span class="sxs-lookup"><span data-stu-id="6059a-122">About this query plan:</span></span>  
  
-   <span data-ttu-id="6059a-123">Les lignes de la table Customer sont récupérées à partir de l'index cluster, qui est la structure de données principale et contient toutes les données de la table.</span><span class="sxs-lookup"><span data-stu-id="6059a-123">The rows from the Customer table are retrieved from the clustered index, which is the primary data structure and has the full table data.</span></span>  
  
-   <span data-ttu-id="6059a-124">Les données de la table Order sont récupérées à l’aide de l’index non-cluster dans la colonne CustomerID.</span><span class="sxs-lookup"><span data-stu-id="6059a-124">Data from the Order table is retrieved using the nonclustered index on the CustomerID column.</span></span> <span data-ttu-id="6059a-125">Cet index contient la colonne CustomerID utilisée pour la jointure, et la colonne de clé primaire OrderID qui est retournée à l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="6059a-125">This index contains both the CustomerID column, which is used for the join, and the primary key column OrderID, which is returned to the user.</span></span> <span data-ttu-id="6059a-126">Le retour de colonnes supplémentaires depuis la table Order nécessiterait des recherches dans l'index cluster de la table Order.</span><span class="sxs-lookup"><span data-stu-id="6059a-126">Returning additional columns from the Order table would require lookups in the clustered index for the Order table.</span></span>  
  
-   <span data-ttu-id="6059a-127">L'opérateur logique `Inner Join` est implémenté par l'opérateur physique `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="6059a-127">The logical operator `Inner Join` is implemented by the physical operator `Merge Join`.</span></span> <span data-ttu-id="6059a-128">Les autres types de jointures physiques sont `Nested Loops` et `Hash Join`.</span><span class="sxs-lookup"><span data-stu-id="6059a-128">The other physical join types are `Nested Loops` and `Hash Join`.</span></span> <span data-ttu-id="6059a-129">L'opérateur `Merge Join` tire parti du fait que les deux index sont triés sur la colonne de jointure CustomerID.</span><span class="sxs-lookup"><span data-stu-id="6059a-129">The `Merge Join` operator takes advantage of the fact that both indexes are sorted on the join column CustomerID.</span></span>  
  
 <span data-ttu-id="6059a-130">Examinons une légère variante de cette requête, qui retourne toutes les lignes de la table Order, et plus seulement OrderID :</span><span class="sxs-lookup"><span data-stu-id="6059a-130">Consider a slight variation on this query, which returns all rows from the Order table, not only OrderID:</span></span>  
  
```sql  
SELECT o.*, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="6059a-131">Le plan estimé pour cette requête est le suivant :</span><span class="sxs-lookup"><span data-stu-id="6059a-131">The estimated plan for this query is:</span></span>  
  
 <span data-ttu-id="6059a-132">![Plan de requête d'une jointure hachée des tables sur disque.](../../database-engine/media/hekaton-query-plan-2.gif "Plan de requête d'une jointure hachée des tables sur disque.")</span><span class="sxs-lookup"><span data-stu-id="6059a-132">![Query plan for a hash join of disk-based tables.](../../database-engine/media/hekaton-query-plan-2.gif "Query plan for a hash join of disk-based tables.")</span></span>  
<span data-ttu-id="6059a-133">Plan de requête d'une jointure hachée des tables sur disque.</span><span class="sxs-lookup"><span data-stu-id="6059a-133">Query plan for a hash join of disk-based tables.</span></span>  
  
 <span data-ttu-id="6059a-134">Dans cette requête, les lignes de la table Order sont récupérées à partir de l'index cluster.</span><span class="sxs-lookup"><span data-stu-id="6059a-134">In this query, rows from the Order table are retrieved using the clustered index.</span></span> <span data-ttu-id="6059a-135">L'opérateur physique `Hash Match` est maintenant utilisé pour `Inner Join`.</span><span class="sxs-lookup"><span data-stu-id="6059a-135">The `Hash Match` physical operator is now used for the `Inner Join`.</span></span> <span data-ttu-id="6059a-136">L'index cluster sur Order n'étant pas trié sur CustomerID, `Merge Join` nécessite un opérateur de tri, ce qui affecte les performances.</span><span class="sxs-lookup"><span data-stu-id="6059a-136">The clustered index on Order is not sorted on CustomerID, and so a `Merge Join` would require a sort operator, which would affect performance.</span></span> <span data-ttu-id="6059a-137">Notez le coût relatif de l'opérateur `Hash Match` (75 %) comparé au coût de l'opérateur `Merge Join` dans l'exemple précédent (46 %).</span><span class="sxs-lookup"><span data-stu-id="6059a-137">Note the relative cost of the `Hash Match` operator (75%) compared with the cost of the `Merge Join` operator in the previous example (46%).</span></span> <span data-ttu-id="6059a-138">L'optimiseur aurait pu utiliser l'opérateur `Hash Match` également dans l'exemple précédent, mais il a considéré que l'opérateur `Merge Join` fournirait de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="6059a-138">The optimizer would have considered the `Hash Match` operator also in the previous example, but concluded that the `Merge Join` operator gave better performance.</span></span>  
  
## <a name="ssnoversion-query-processing-for-disk-based-tables"></a>[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="6059a-139">Traitement des requêtes pour les tables sur disque</span><span class="sxs-lookup"><span data-stu-id="6059a-139">Query Processing for Disk-Based Tables</span></span>  
 <span data-ttu-id="6059a-140">Le diagramme suivant représente le flux de traitement des requêtes dans [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] pour les requêtes ad hoc :</span><span class="sxs-lookup"><span data-stu-id="6059a-140">The following diagram outlines the query processing flow in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for ad hoc queries:</span></span>  
  
 <span data-ttu-id="6059a-141">![Pipeline de traitement des requêtes SQL Server](../../database-engine/media/hekaton-query-plan-3.gif "Pipeline de traitement des requêtes SQL Server")</span><span class="sxs-lookup"><span data-stu-id="6059a-141">![SQL Server query processing pipeline.](../../database-engine/media/hekaton-query-plan-3.gif "SQL Server query processing pipeline.")</span></span>  
<span data-ttu-id="6059a-142">Pipeline de traitement des requêtes SQL Server</span><span class="sxs-lookup"><span data-stu-id="6059a-142">SQL Server query processing pipeline.</span></span>  
  
 <span data-ttu-id="6059a-143">Dans ce scénario :</span><span class="sxs-lookup"><span data-stu-id="6059a-143">In this scenario:</span></span>  
  
1.  <span data-ttu-id="6059a-144">L'utilisateur émet une requête.</span><span class="sxs-lookup"><span data-stu-id="6059a-144">The user issues a query.</span></span>  
  
2.  <span data-ttu-id="6059a-145">L'analyseur et l'algébriseur construisent une arborescence de requête avec des opérateurs logiques en fonction du texte [!INCLUDE[tsql](../../../includes/tsql-md.md)] soumis par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="6059a-145">The parser and algebrizer construct a query tree with logical operators based on the [!INCLUDE[tsql](../../../includes/tsql-md.md)] text submitted by the user.</span></span>  
  
3.  <span data-ttu-id="6059a-146">L'optimiseur crée un plan de requête optimisé qui contient les opérateurs physiques (par exemple, une jointure de boucle imbriquée).</span><span class="sxs-lookup"><span data-stu-id="6059a-146">The optimizer creates an optimized query plan containing physical operators (for example, nested-loops join).</span></span> <span data-ttu-id="6059a-147">Après l'optimisation, le plan peut être stocké dans le cache du plan.</span><span class="sxs-lookup"><span data-stu-id="6059a-147">After optimization, the plan may be stored in the plan cache.</span></span> <span data-ttu-id="6059a-148">Cette étape est ignorée si le cache du plan contient déjà un plan pour cette requête.</span><span class="sxs-lookup"><span data-stu-id="6059a-148">This step is bypassed if the plan cache already contains a plan for this query.</span></span>  
  
4.  <span data-ttu-id="6059a-149">Le moteur d'exécution de requête traite une interprétation du plan de requête.</span><span class="sxs-lookup"><span data-stu-id="6059a-149">The query execution engine processes an interpretation of the query plan.</span></span>  
  
5.  <span data-ttu-id="6059a-150">Pour chaque recherche d'index, analyse d'index et opérateur d'analyse de table, le moteur d'exécution demande des lignes aux structures d'index et de table respectives à partir des méthodes d'accès.</span><span class="sxs-lookup"><span data-stu-id="6059a-150">For each index seek, index scan, and table scan operator, the execution engine requests rows from the respective index and table structures from Access Methods.</span></span>  
  
6.  <span data-ttu-id="6059a-151">Les méthodes d'accès récupèrent les lignes de l'index et les pages de données dans le pool de mémoires tampons, et chargent les pages à partir du disque dans le pool de mémoires tampons si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="6059a-151">Access Methods retrieves the rows from the index and data pages in the buffer pool and loads pages from disk into the buffer pool as needed.</span></span>  
  
 <span data-ttu-id="6059a-152">Pour le premier exemple de requête, le moteur d’exécution demande des lignes à l’index cluster sur la table Customer, et à l’index non-cluster sur la table Order, à partir des méthodes d’accès.</span><span class="sxs-lookup"><span data-stu-id="6059a-152">For the first example query, the execution engine requests rows in the clustered index on Customer and the nonclustered index on Order from Access Methods.</span></span> <span data-ttu-id="6059a-153">Les méthodes d'accès parcourent les structures d'index B-tree pour récupérer les lignes demandées.</span><span class="sxs-lookup"><span data-stu-id="6059a-153">Access Methods traverses the B-tree index structures to retrieve the requested rows.</span></span> <span data-ttu-id="6059a-154">Dans ce cas, toutes les lignes sont récupérées lorsque le plan appelle des analyses d'index complètes.</span><span class="sxs-lookup"><span data-stu-id="6059a-154">In this case all rows are retrieved as the plan calls for full index scans.</span></span>  
  
## <a name="interpreted-tsql-access-to-memory-optimized-tables"></a><span data-ttu-id="6059a-155">Accès en [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété aux tables mémoire optimisées</span><span class="sxs-lookup"><span data-stu-id="6059a-155">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access to Memory-Optimized Tables</span></span>  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="6059a-156">Les lots ad hoc et procédures stockées sont également considérés comme du [!INCLUDE[tsql](../../../includes/tsql-md.md)]interprété.</span><span class="sxs-lookup"><span data-stu-id="6059a-156">ad hoc batches and stored procedures are also referred to as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="6059a-157">« Interprété » fait référence au fait que le plan de requête est interprété par le moteur d'exécution de requête pour chaque opérateur inclus dans le plan de requête.</span><span class="sxs-lookup"><span data-stu-id="6059a-157">Interpreted refers to the fact that the query plan is interpreted by the query execution engine for each operator in the query plan.</span></span> <span data-ttu-id="6059a-158">Le moteur d'exécution lit l'opérateur et ses paramètres, et effectue l'opération.</span><span class="sxs-lookup"><span data-stu-id="6059a-158">The execution engine reads the operator and its parameters and performs the operation.</span></span>  
  
 <span data-ttu-id="6059a-159">Le [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété peut être utilisé pour accéder aux tables mémoire optimisées et sur disque.</span><span class="sxs-lookup"><span data-stu-id="6059a-159">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] can be used to access both memory-optimized and disk-based tables.</span></span> <span data-ttu-id="6059a-160">L'illustration suivante montre le traitement des requêtes pour l'accès en [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété aux tables mémoire optimisées :</span><span class="sxs-lookup"><span data-stu-id="6059a-160">The following figure illustrates query processing for interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables:</span></span>  
  
 <span data-ttu-id="6059a-161">![Pipeline de traitement des requêtes pour le TSQL interprété.](../../database-engine/media/hekaton-query-plan-4.gif "Pipeline de traitement des requêtes pour le TSQL interprété.")</span><span class="sxs-lookup"><span data-stu-id="6059a-161">![Query processing pipeline for interpreted tsql.](../../database-engine/media/hekaton-query-plan-4.gif "Query processing pipeline for interpreted tsql.")</span></span>  
<span data-ttu-id="6059a-162">Pipeline de traitement des requêtes pour l'accès en Transact-SQL interprété aux tables mémoire optimisées.</span><span class="sxs-lookup"><span data-stu-id="6059a-162">Query processing pipeline for interpreted Transact-SQL access to memory-optimized tables.</span></span>  
  
 <span data-ttu-id="6059a-163">Comme illustré dans la figure, le pipeline de traitement des requêtes reste principalement inchangé :</span><span class="sxs-lookup"><span data-stu-id="6059a-163">As illustrated by the figure, the query processing pipeline remains mostly unchanged:</span></span>  
  
-   <span data-ttu-id="6059a-164">L'analyseur et l'algébriseur construisent l'arborescence de requête.</span><span class="sxs-lookup"><span data-stu-id="6059a-164">The parser and algebrizer construct the query tree.</span></span>  
  
-   <span data-ttu-id="6059a-165">L'optimiseur crée le plan d'exécution.</span><span class="sxs-lookup"><span data-stu-id="6059a-165">The optimizer creates the execution plan.</span></span>  
  
-   <span data-ttu-id="6059a-166">Le moteur d'exécution de requête interprète le plan d'exécution.</span><span class="sxs-lookup"><span data-stu-id="6059a-166">The query execution engine interprets the execution plan.</span></span>  
  
 <span data-ttu-id="6059a-167">La principale différence avec le pipeline de traitement des requêtes traditionnel (illustration 2) est que les lignes des tables mémoire optimisées ne sont pas récupérées à partir du pool de mémoires tampons avec des méthodes d'accès.</span><span class="sxs-lookup"><span data-stu-id="6059a-167">The main difference with the traditional query processing pipeline (figure 2) is that rows for memory-optimized tables are not retrieved from the buffer pool using Access Methods.</span></span> <span data-ttu-id="6059a-168">Ces lignes sont extraites des structures de données en mémoire par le moteur de l'OLTP en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6059a-168">Instead, rows are retrieved from the in-memory data structures through the In-Memory OLTP engine.</span></span> <span data-ttu-id="6059a-169">Les différences dans les structures de données obligent l'optimiseur à choisir des plans différents dans certains cas, comme illustré par l'exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="6059a-169">Differences in data structures cause the optimizer to pick different plans in some cases, as illustrated by the following example.</span></span>  
  
 <span data-ttu-id="6059a-170">Le script [!INCLUDE[tsql](../../../includes/tsql-md.md)] suivant contient les versions mémoire optimisées des tables Order et Customer, utilisant des index de hachage :</span><span class="sxs-lookup"><span data-stu-id="6059a-170">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains memory-optimized versions of the Order and Customer tables, using hash indexes:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY NONCLUSTERED,  
  ContactName nvarchar (30) NOT NULL   
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY NONCLUSTERED,  
  CustomerID nchar (5) NOT NULL INDEX IX_CustomerID HASH(CustomerID) WITH (BUCKET_COUNT=100000),  
  OrderDate date NOT NULL INDEX IX_OrderDate HASH(OrderDate) WITH (BUCKET_COUNT=100000)  
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
```  
  
 <span data-ttu-id="6059a-171">Imaginons la même requête exécutée sur des tables mémoire optimisées :</span><span class="sxs-lookup"><span data-stu-id="6059a-171">Consider the same query executed on memory-optimized tables:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="6059a-172">Le plan estimé est le suivant :</span><span class="sxs-lookup"><span data-stu-id="6059a-172">The estimated plan is as follows:</span></span>  
  
 <span data-ttu-id="6059a-173">![Plan de requête pour joindre des tables optimisées en mémoire.](../../database-engine/media/hekaton-query-plan-5.gif "Plan de requête pour joindre des tables mémoire optimisées.")</span><span class="sxs-lookup"><span data-stu-id="6059a-173">![Query plan for join of memory optimized tables.](../../database-engine/media/hekaton-query-plan-5.gif "Query plan for join of memory optimized tables.")</span></span>  
<span data-ttu-id="6059a-174">Plan de requête pour joindre des tables mémoire optimisées.</span><span class="sxs-lookup"><span data-stu-id="6059a-174">Query plan for join of memory-optimized tables.</span></span>  
  
 <span data-ttu-id="6059a-175">Observez les différences suivantes dans le plan pour la même requête sur des tables sur disque (figure 1) :</span><span class="sxs-lookup"><span data-stu-id="6059a-175">Observe the following differences with the plan for the same query on disk-based tables (figure 1):</span></span>  
  
-   <span data-ttu-id="6059a-176">Ce plan contient une analyse de table au lieu d'une analyse d'index cluster pour la table Customer :</span><span class="sxs-lookup"><span data-stu-id="6059a-176">This plan contains a table scan rather than a clustered index scan for the table Customer:</span></span>  
  
    -   <span data-ttu-id="6059a-177">La définition de la table ne contient pas d'index cluster.</span><span class="sxs-lookup"><span data-stu-id="6059a-177">The definition of the table does not contain a clustered index.</span></span>  
  
    -   <span data-ttu-id="6059a-178">Les index cluster ne sont pas pris en charge avec les tables mémoire optimisées.</span><span class="sxs-lookup"><span data-stu-id="6059a-178">Clustered indexes are not supported with memory-optimized tables.</span></span> <span data-ttu-id="6059a-179">À la place, chaque table mémoire optimisée doit avoir au moins un index non cluster et tous les index des tables mémoire optimisées accéder efficacement à toutes les colonnes de la table sans devoir les stocker dans l'index ou les référencer dans un index cluster.</span><span class="sxs-lookup"><span data-stu-id="6059a-179">Instead, every memory-optimized table must have at least one nonclustered index and all indexes on memory-optimized tables can efficiently access all columns in the table without having to store them in the index or refer to a clustered index.</span></span>  
  
-   <span data-ttu-id="6059a-180">Ce plan contient un `Hash Match` plutôt qu'un `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="6059a-180">This plan contains a `Hash Match` rather than a `Merge Join`.</span></span> <span data-ttu-id="6059a-181">Les index des tables Order et Customer sont des index de hachage, et ne sont donc pas triés.</span><span class="sxs-lookup"><span data-stu-id="6059a-181">The indexes on both the Order and the Customer table are hash indexes, and are thus not ordered.</span></span> <span data-ttu-id="6059a-182">`Merge Join` nécessiterait des opérateurs de tri qui diminueraient les performances.</span><span class="sxs-lookup"><span data-stu-id="6059a-182">A `Merge Join` would require sort operators that would decrease performance.</span></span>  
  
## <a name="natively-compiled-stored-procedures"></a><span data-ttu-id="6059a-183">procédures stockées compilées en mode natif</span><span class="sxs-lookup"><span data-stu-id="6059a-183">Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="6059a-184">Les procédures stockées compilées en mode natif sont des procédures stockées en [!INCLUDE[tsql](../../../includes/tsql-md.md)] qui sont compilées dans le code machine, au lieu d'être interprétées par le moteur d'exécution de requête.</span><span class="sxs-lookup"><span data-stu-id="6059a-184">Natively compiled stored procedures are [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures compiled to machine code, rather than interpreted by the query execution engine.</span></span> <span data-ttu-id="6059a-185">Le script suivant crée une procédure stockée compilée en mode natif qui exécute l'exemple de requête (dans la section Exemple de requête).</span><span class="sxs-lookup"><span data-stu-id="6059a-185">The following script creates a natively compiled stored procedure that runs the example query (from the Example Query section).</span></span>  
  
```sql  
CREATE PROCEDURE usp_SampleJoin  
WITH NATIVE_COMPILATION, SCHEMABINDING, EXECUTE AS OWNER  
AS BEGIN ATOMIC WITH   
(  TRANSACTION ISOLATION LEVEL = SNAPSHOT,  
  LANGUAGE = 'english')  
  
  SELECT o.OrderID, c.CustomerID, c.ContactName   
FROM dbo.[Order] o INNER JOIN dbo.[Customer] c   
  ON c.CustomerID = o.CustomerID  
  
END  
```  
  
 <span data-ttu-id="6059a-186">Les procédures stockées compilées en mode natif sont compilées lors de la création, tandis que les procédures stockées interprétées sont compilées lors de la première exécution.</span><span class="sxs-lookup"><span data-stu-id="6059a-186">Natively compiled stored procedures are compiled at create time, whereas interpreted stored procedures are compiled at first execution time.</span></span> <span data-ttu-id="6059a-187">(Une partie de la compilation, notamment l'analyse et l'algébrisation, a lieu au moment de la création.</span><span class="sxs-lookup"><span data-stu-id="6059a-187">(A portion of the compilation, particularly parsing and algebrization, take place at create.</span></span> <span data-ttu-id="6059a-188">Toutefois, pour les procédures stockées interprétées, l'optimisation des plans de requête a lieu à la première exécution.) La logique de recompilation est similaire.</span><span class="sxs-lookup"><span data-stu-id="6059a-188">However, for interpreted stored procedures, optimization of the query plans takes place at first execution.) The recompilation logic is similar.</span></span> <span data-ttu-id="6059a-189">Les procédures stockées compilées en mode natif sont recompilées lors de leur première exécution si le serveur est redémarré.</span><span class="sxs-lookup"><span data-stu-id="6059a-189">Natively compiled stored procedures are recompiled on first execution of the procedure if the server is restarted.</span></span> <span data-ttu-id="6059a-190">Les procédures stockées interprétées sont recompilées si le plan n'est plus dans le cache du plan.</span><span class="sxs-lookup"><span data-stu-id="6059a-190">Interpreted stored procedures are recompiled if the plan is no longer in the plan cache.</span></span> <span data-ttu-id="6059a-191">Le tableau suivant résume les scénarios de compilation et de recompilation pour les procédures stockées compilées en mode natif et les procédures stockées interprétées :</span><span class="sxs-lookup"><span data-stu-id="6059a-191">The following table summarizes compilation and recompilation cases for both natively compiled and interpreted stored procedures:</span></span>  
  
||<span data-ttu-id="6059a-192">Compilé en mode natif</span><span class="sxs-lookup"><span data-stu-id="6059a-192">Natively compiled</span></span>|<span data-ttu-id="6059a-193">Accès en</span><span class="sxs-lookup"><span data-stu-id="6059a-193">Interpreted</span></span>|  
|-|-----------------------|-----------------|  
|<span data-ttu-id="6059a-194">Compilation initiale</span><span class="sxs-lookup"><span data-stu-id="6059a-194">Initial compilation</span></span>|<span data-ttu-id="6059a-195">À la création.</span><span class="sxs-lookup"><span data-stu-id="6059a-195">At create time.</span></span>|<span data-ttu-id="6059a-196">À la première exécution.</span><span class="sxs-lookup"><span data-stu-id="6059a-196">At first execution.</span></span>|  
|<span data-ttu-id="6059a-197">Recompilation automatique</span><span class="sxs-lookup"><span data-stu-id="6059a-197">Automatic recompilation</span></span>|<span data-ttu-id="6059a-198">À la première exécution de la procédure après le redémarrage de la base de données ou du serveur.</span><span class="sxs-lookup"><span data-stu-id="6059a-198">Upon first execution of the procedure after a database or server restart.</span></span>|<span data-ttu-id="6059a-199">Au redémarrage du serveur.</span><span class="sxs-lookup"><span data-stu-id="6059a-199">On server restart.</span></span> <span data-ttu-id="6059a-200">Ou suppression du cache du plan, généralement en fonction des modifications du schéma ou des statistiques, ou de la sollicitation de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="6059a-200">Or, eviction from the plan cache, usually based on schema or stats changes, or memory pressure.</span></span>|  
|<span data-ttu-id="6059a-201">Recompilation manuelle</span><span class="sxs-lookup"><span data-stu-id="6059a-201">Manual recompilation</span></span>|<span data-ttu-id="6059a-202">Non pris en charge.</span><span class="sxs-lookup"><span data-stu-id="6059a-202">Not supported.</span></span> <span data-ttu-id="6059a-203">La solution consiste à supprimer et à recréer la procédure stockée.</span><span class="sxs-lookup"><span data-stu-id="6059a-203">The workaround is to drop and recreate the stored procedure.</span></span>|<span data-ttu-id="6059a-204">Utilisez `sp_recompile`.</span><span class="sxs-lookup"><span data-stu-id="6059a-204">Use `sp_recompile`.</span></span> <span data-ttu-id="6059a-205">Vous pouvez supprimer manuellement le plan du cache, par exemple via l'instruction DBCC FREEPROCCACHE.</span><span class="sxs-lookup"><span data-stu-id="6059a-205">You can manually evict the plan from the cache, for example through DBCC FREEPROCCACHE.</span></span> <span data-ttu-id="6059a-206">Vous pouvez également créer la procédure stockée WITH RECOMPILE qui sera recompilée à chaque exécution.</span><span class="sxs-lookup"><span data-stu-id="6059a-206">You can also create the stored procedure WITH RECOMPILE and the stored procedure will be recompiled at every execution.</span></span>|  
  
### <a name="compilation-and-query-processing"></a><span data-ttu-id="6059a-207">Compilation et traitement des requêtes</span><span class="sxs-lookup"><span data-stu-id="6059a-207">Compilation and Query Processing</span></span>  
 <span data-ttu-id="6059a-208">Le diagramme ci-dessous illustre le processus de compilation des procédures stockées compilées en mode natif :</span><span class="sxs-lookup"><span data-stu-id="6059a-208">The following diagram illustrates the compilation process for natively compiled stored procedures:</span></span>  
  
 <span data-ttu-id="6059a-209">![Procédures stockées compilées en mode natif.](../../database-engine/media/hekaton-query-plan-6.gif "Procédures stockées compilées en mode natif.")</span><span class="sxs-lookup"><span data-stu-id="6059a-209">![Native compilation of stored procedures.](../../database-engine/media/hekaton-query-plan-6.gif "Native compilation of stored procedures.")</span></span>  
<span data-ttu-id="6059a-210">Procédures stockées compilées en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6059a-210">Native compilation of stored procedures.</span></span>  
  
 <span data-ttu-id="6059a-211">Le processus se présente comme suit :</span><span class="sxs-lookup"><span data-stu-id="6059a-211">The process is described as,</span></span>  
  
1.  <span data-ttu-id="6059a-212">L'utilisateur envoie une instruction `CREATE PROCEDURE` à [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="6059a-212">The user issues a `CREATE PROCEDURE` statement to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
2.  <span data-ttu-id="6059a-213">L'analyseur et l'algébriseur créent un flux de traitement pour la procédure, ainsi que les arborescences des requêtes [!INCLUDE[tsql](../../../includes/tsql-md.md)] dans la procédure stockée.</span><span class="sxs-lookup"><span data-stu-id="6059a-213">The parser and algebrizer create the processing flow for the procedure, as well as query trees for the [!INCLUDE[tsql](../../../includes/tsql-md.md)] queries in the stored procedure.</span></span>  
  
3.  <span data-ttu-id="6059a-214">L'optimiseur crée des plans d'exécution de requête optimisés pour toutes les requêtes incluses dans la procédure stockée.</span><span class="sxs-lookup"><span data-stu-id="6059a-214">The optimizer creates optimized query execution plans for all the queries in the stored procedure.</span></span>  
  
4.  <span data-ttu-id="6059a-215">Le compilateur de l'OLTP en mémoire prend le flux de traitement avec les plans de requête optimisés et génère une DLL qui contient le code machine pour exécuter la procédure stockée.</span><span class="sxs-lookup"><span data-stu-id="6059a-215">The In-Memory OLTP compiler takes the processing flow with the embedded optimized query plans and generates a DLL that contains the machine code for executing the stored procedure.</span></span>  
  
5.  <span data-ttu-id="6059a-216">La DLL générée est chargée en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6059a-216">The generated DLL is loaded into memory.</span></span>  
  
 <span data-ttu-id="6059a-217">L'appel d'une procédure stockée compilée en mode natif se traduit par l'appel à une fonction dans la DLL.</span><span class="sxs-lookup"><span data-stu-id="6059a-217">Invocation of a natively compiled stored procedure translates to calling a function in the DLL.</span></span>  
  
 <span data-ttu-id="6059a-218">![Exécution de procédures stockées compilées en mode natif.](../../database-engine/media/hekaton-query-plan-7.gif "Exécution de procédures stockées compilées en mode natif.")</span><span class="sxs-lookup"><span data-stu-id="6059a-218">![Execution of natively compiled stored procedures.](../../database-engine/media/hekaton-query-plan-7.gif "Execution of natively compiled stored procedures.")</span></span>  
<span data-ttu-id="6059a-219">Exécution de procédures stockées compilées en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6059a-219">Execution of natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="6059a-220">L'appel d'une procédure stockée compilée en mode natif se présente comme suit :</span><span class="sxs-lookup"><span data-stu-id="6059a-220">Invocation of a natively compiled stored procedure is described as follows:</span></span>  
  
1.  <span data-ttu-id="6059a-221">L’utilisateur émet une `EXEC` instruction *usp_myproc* .</span><span class="sxs-lookup"><span data-stu-id="6059a-221">The user issues an `EXEC`*usp_myproc* statement.</span></span>  
  
2.  <span data-ttu-id="6059a-222">L'analyseur extrait le nom et les paramètres de la procédure stockée.</span><span class="sxs-lookup"><span data-stu-id="6059a-222">The parser extracts the name and stored procedure parameters.</span></span>  
  
     <span data-ttu-id="6059a-223">Si l'instruction a été préparée, par exemple via `sp_prep_exec`, l'analyseur n'a pas besoin d'extraire le nom de la procédure et les paramètres au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="6059a-223">If the statement was prepared, for example using `sp_prep_exec`, the parser does not need to extract the procedure name and parameters at execution time.</span></span>  
  
3.  <span data-ttu-id="6059a-224">L'exécution de l'OLTP en mémoire recherche le point d'entrée de la DLL pour la procédure stockée.</span><span class="sxs-lookup"><span data-stu-id="6059a-224">The In-Memory OLTP runtime locates the DLL entry point for the stored procedure.</span></span>  
  
4.  <span data-ttu-id="6059a-225">Le code machine dans la DLL est exécuté et les résultats sont retournés au client.</span><span class="sxs-lookup"><span data-stu-id="6059a-225">The machine code in the DLL is executed and the results of are returned to the client.</span></span>  
  
 <span data-ttu-id="6059a-226">**Détection des paramètres**</span><span class="sxs-lookup"><span data-stu-id="6059a-226">**Parameter sniffing**</span></span>  
  
 <span data-ttu-id="6059a-227">Les procédures stockées en [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété sont compilées à la première exécution, contrairement aux procédures stockées compilées en mode natif, qui sont compilées lors de la création.</span><span class="sxs-lookup"><span data-stu-id="6059a-227">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures are compiled at first execution, in contrast to natively compiled stored procedures, which are compiled at create time.</span></span> <span data-ttu-id="6059a-228">Lorsque des procédures stockées interprétées sont compilées au moment de l'appel, les valeurs des paramètres fournis pour cet appel sont utilisées par l'optimiseur lors de la génération du plan d'exécution.</span><span class="sxs-lookup"><span data-stu-id="6059a-228">When interpreted stored procedures are compiled at invocation, the values of the parameters supplied for this invocation are used by the optimizer when generating the execution plan.</span></span> <span data-ttu-id="6059a-229">Cette utilisation des paramètres lors de la compilation est appelée « détection des paramètres ».</span><span class="sxs-lookup"><span data-stu-id="6059a-229">This use of parameters during compilation is called parameter sniffing.</span></span>  
  
 <span data-ttu-id="6059a-230">La détection des paramètres n'est pas utilisée pour compiler des procédures stockées compilées en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6059a-230">Parameter sniffing is not used for compiling natively compiled stored procedures.</span></span> <span data-ttu-id="6059a-231">Tous les paramètres de la procédure stockée sont considérés comme ayant des valeurs UNKNOWN.</span><span class="sxs-lookup"><span data-stu-id="6059a-231">All parameters to the stored procedure are considered to have UNKNOWN values.</span></span> <span data-ttu-id="6059a-232">À l'instar des procédures stockées interprétées, les procédures stockées compilées en mode natif prennent également en charge l'indicateur `OPTIMIZE FOR`.</span><span class="sxs-lookup"><span data-stu-id="6059a-232">Like interpreted stored procedures, natively compiled stored procedures also support the `OPTIMIZE FOR` hint.</span></span> <span data-ttu-id="6059a-233">Pour plus d’informations, consultez [Indicateurs de requête &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span><span class="sxs-lookup"><span data-stu-id="6059a-233">For more information, see [Query Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span></span>  
  
### <a name="retrieving-a-query-execution-plan-for-natively-compiled-stored-procedures"></a><span data-ttu-id="6059a-234">Récupération d'un plan d'exécution de requêtes pour les procédures stockées compilées en mode natif</span><span class="sxs-lookup"><span data-stu-id="6059a-234">Retrieving a Query Execution Plan for Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="6059a-235">Vous pouvez récupérer le plan d’exécution de requêtes pour une procédure stockée compilée en mode natif en utilisant le **plan d’exécution estimé** dans [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)], ou en utilisant l’option SHOWPLAN_XML dans [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="6059a-235">The query execution plan for a natively compiled stored procedure can be retrieved using **Estimated Execution Plan** in [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)], or using the SHOWPLAN_XML option in [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="6059a-236">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="6059a-236">For example:</span></span>  
  
```sql  
SET SHOWPLAN_XML ON  
GO  
EXEC dbo.usp_myproc  
GO  
SET SHOWPLAN_XML OFF  
GO  
```  
  
 <span data-ttu-id="6059a-237">Le plan d'exécution généré par l'optimiseur de requête comprend une arborescence avec les opérateurs de requête sur les nœuds et les feuilles.</span><span class="sxs-lookup"><span data-stu-id="6059a-237">The execution plan generated by the query optimizer consists of a tree with query operators on the nodes and leaves of the tree.</span></span> <span data-ttu-id="6059a-238">La structure de l'arborescence détermine l'interaction (le flux des lignes d'un opérateur vers un autre) entre les opérateurs.</span><span class="sxs-lookup"><span data-stu-id="6059a-238">The structure of the tree determines the interaction (the flow of rows from one operator to another) between the operators.</span></span> <span data-ttu-id="6059a-239">Dans la vue graphique de [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], le flux est de droite à gauche.</span><span class="sxs-lookup"><span data-stu-id="6059a-239">In the graphical view of [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], the flow is from right to left.</span></span> <span data-ttu-id="6059a-240">Par exemple, le plan de requête sur la figure 1 contient deux opérateurs d'analyse d'index, qui fournissent des lignes à un opérateur de jointure de fusion.</span><span class="sxs-lookup"><span data-stu-id="6059a-240">For example, the query plan in figure 1 contains two index scan operators, which supplies rows to a merge join operator.</span></span> <span data-ttu-id="6059a-241">L'opérateur de jointure de fusion fournit des lignes à un opérateur de sélection.</span><span class="sxs-lookup"><span data-stu-id="6059a-241">The merge join operator supplies rows to a select operator.</span></span> <span data-ttu-id="6059a-242">Enfin, l'opérateur de sélection retourne les lignes au client.</span><span class="sxs-lookup"><span data-stu-id="6059a-242">The select operator, finally, returns the rows to the client.</span></span>  
  
### <a name="query-operators-in-natively-compiled-stored-procedures"></a><span data-ttu-id="6059a-243">Opérateurs de requête dans des procédures stockées compilées en mode natif</span><span class="sxs-lookup"><span data-stu-id="6059a-243">Query Operators in Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="6059a-244">Le tableau suivant récapitule les opérateurs de requête pris en charge dans les procédures stockées compilées en mode natif :</span><span class="sxs-lookup"><span data-stu-id="6059a-244">The following table summarizes the query operators supported inside natively compiled stored procedures:</span></span>  
  
|<span data-ttu-id="6059a-245">Opérateur</span><span class="sxs-lookup"><span data-stu-id="6059a-245">Operator</span></span>|<span data-ttu-id="6059a-246">Exemple de requête</span><span class="sxs-lookup"><span data-stu-id="6059a-246">Sample query</span></span>|  
|--------------|------------------|  
|<span data-ttu-id="6059a-247">SELECT</span><span class="sxs-lookup"><span data-stu-id="6059a-247">SELECT</span></span>|`SELECT OrderID FROM dbo.[Order]`|  
|<span data-ttu-id="6059a-248">INSERT</span><span class="sxs-lookup"><span data-stu-id="6059a-248">INSERT</span></span>|`INSERT dbo.Customer VALUES ('abc', 'def')`|  
|<span data-ttu-id="6059a-249">UPDATE</span><span class="sxs-lookup"><span data-stu-id="6059a-249">UPDATE</span></span>|`UPDATE dbo.Customer SET ContactName='ghi' WHERE CustomerID='abc'`|  
|<span data-ttu-id="6059a-250">Suppression</span><span class="sxs-lookup"><span data-stu-id="6059a-250">DELETE</span></span>|`DELETE dbo.Customer WHERE CustomerID='abc'`|  
|<span data-ttu-id="6059a-251">Compute Scalar</span><span class="sxs-lookup"><span data-stu-id="6059a-251">Compute Scalar</span></span>|<span data-ttu-id="6059a-252">Cet opérateur est utilisé pour les fonctions intrinsèques et les conversions de type.</span><span class="sxs-lookup"><span data-stu-id="6059a-252">This operator is used both for intrinsic functions and type conversions.</span></span> <span data-ttu-id="6059a-253">Certaines fonctions et conversions de type ne sont pas prises en charge à l'intérieur des procédures stockées compilées en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6059a-253">Not all functions and type conversions are supported inside natively compiled stored procedures.</span></span><br /><br /> `SELECT OrderID+1 FROM dbo.[Order]`|  
|<span data-ttu-id="6059a-254">Jointures de boucles imbriquées</span><span class="sxs-lookup"><span data-stu-id="6059a-254">Nested Loops Join</span></span>|<span data-ttu-id="6059a-255">Les boucles imbriquées sont le seul opérateur de jointure pris en charge dans les procédures stockées compilées en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6059a-255">Nested Loops is the only join operator supported in natively compiled stored procedures.</span></span> <span data-ttu-id="6059a-256">Tous les plans qui contiennent des jointures utilisent l'opérateur Nested Loops, même si le plan pour la même requête exécutée en [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété contient un hachage ou une jointure de fusion.</span><span class="sxs-lookup"><span data-stu-id="6059a-256">All plans that contain joins will use the Nested Loops operator, even if the plan for same query executed as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] contains a hash or merge join.</span></span><br /><br /> `SELECT o.OrderID, c.CustomerID`  <br /> `FROM dbo.[Order] o INNER JOIN dbo.[Customer] c`|  
|<span data-ttu-id="6059a-257">Trier</span><span class="sxs-lookup"><span data-stu-id="6059a-257">Sort</span></span>|`SELECT ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="6059a-258">TOP</span><span class="sxs-lookup"><span data-stu-id="6059a-258">Top</span></span>|`SELECT TOP 10 ContactName FROM dbo.Customer`|  
|<span data-ttu-id="6059a-259">Top-sort</span><span class="sxs-lookup"><span data-stu-id="6059a-259">Top-sort</span></span>|<span data-ttu-id="6059a-260">L'expression `TOP` (nombre de lignes à renvoyer) ne peut pas dépasser 8 000 lignes.</span><span class="sxs-lookup"><span data-stu-id="6059a-260">The `TOP` expression (the number of rows to be returned) cannot exceed 8,000 rows.</span></span> <span data-ttu-id="6059a-261">Moins s'il existe également des opérateurs de jointure et d'agrégation dans la requête.</span><span class="sxs-lookup"><span data-stu-id="6059a-261">Fewer if there are also join and aggregation operators in the query.</span></span> <span data-ttu-id="6059a-262">Les jointures et l'agrégation réduisent généralement le nombre de lignes à trier, par rapport au nombre de lignes des tables de base.</span><span class="sxs-lookup"><span data-stu-id="6059a-262">Joins and aggregation do typically reduce the number of rows to be sorted, compared with the row count of the base tables.</span></span><br /><br /> `SELECT TOP 10 ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="6059a-263">Agrégation de flux</span><span class="sxs-lookup"><span data-stu-id="6059a-263">Stream Aggregate</span></span>|<span data-ttu-id="6059a-264">Notez que l'opérateur Hash Match n'est pas pris en charge pour l'agrégation.</span><span class="sxs-lookup"><span data-stu-id="6059a-264">Note that the Hash Match operator is not supported for aggregation.</span></span> <span data-ttu-id="6059a-265">Par conséquent, toutes les agrégations dans les procédures stockées compilées en mode natif utilisent l'opérateur Stream Aggregate, même si le plan pour la même requête en [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété utilise l'opérateur Hash Match.</span><span class="sxs-lookup"><span data-stu-id="6059a-265">Therefore, all aggregation in natively compiled stored procedures uses the Stream Aggregate operator, even if the plan for the same query in interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] uses the Hash Match operator.</span></span><br /><br /> `SELECT count(CustomerID) FROM dbo.Customer`|  
  
## <a name="column-statistics-and-joins"></a><span data-ttu-id="6059a-266">Statistiques et jointures de colonne</span><span class="sxs-lookup"><span data-stu-id="6059a-266">Column Statistics and Joins</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="6059a-267">conserve les statistiques des valeurs des colonnes clés d’index pour vous aider à estimer le coût de certaines opérations, comme les analyses d’index et les recherches d’index.</span><span class="sxs-lookup"><span data-stu-id="6059a-267">maintains statistics on values in index key columns to help estimate the cost of certain operations, such as index scan and index seeks.</span></span> <span data-ttu-id="6059a-268">([!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] crée également des statistiques sur les colonnes clés qui ne sont pas des index si vous les créez explicitement ou si l’optimiseur de requête les crée en réponse à une requête avec un prédicat). La mesure principale de l'estimation de coût est le nombre de lignes traitées par un seul opérateur.</span><span class="sxs-lookup"><span data-stu-id="6059a-268">( [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also creates statistics on non-index key columns if you explicitly create them or if the query optimizer creates them in response to a query with a predicate.) The main metric in cost estimation is the number of rows processed by a single operator.</span></span> <span data-ttu-id="6059a-269">Notez que pour les tables sur disque, le nombre de pages auxquelles un opérateur spécifique accède est important pour l'estimation du coût.</span><span class="sxs-lookup"><span data-stu-id="6059a-269">Note that for disk-based tables, the number of pages accessed by a particular operator is significant in cost estimation.</span></span> <span data-ttu-id="6059a-270">Toutefois, comme le nombre de pages n'est pas important pour les tables mémoire optimisées (il est toujours de zéro), cette description se focalisera sur le nombre de lignes.</span><span class="sxs-lookup"><span data-stu-id="6059a-270">However, as page count is not important for memory-optimized tables (it is always zero), this discussion focuses on row count.</span></span> <span data-ttu-id="6059a-271">L'estimation démarre avec les opérateurs de recherche d'index et d'analyse dans le plan, et est ensuite étendue pour inclure les autres opérateurs, comme l'opérateur de jointure.</span><span class="sxs-lookup"><span data-stu-id="6059a-271">The estimation starts with the index seek and scan operators in the plan, and is then extended to include the other operators, like the join operator.</span></span> <span data-ttu-id="6059a-272">Le nombre estimé de lignes à traiter par un opérateur de jointure dépend de l'estimation des opérateurs d'index, de recherche et d'analyse sous-jacents.</span><span class="sxs-lookup"><span data-stu-id="6059a-272">The estimated number of rows to be processed by a join operator is based on the estimation for the underlying index, seek, and scan operators.</span></span> <span data-ttu-id="6059a-273">Pour l'accès [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété aux tables mémoire optimisées, vous pouvez observer le plan d'exécution réel pour voir la différence entre le nombre de lignes estimé et le nombre de lignes réel pour les opérateurs du plan.</span><span class="sxs-lookup"><span data-stu-id="6059a-273">For interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables, you can observe the actual execution plan to see the difference between the estimated and actual row counts for the operators in the plan.</span></span>  
  
 <span data-ttu-id="6059a-274">Exemple de la figure 1 :</span><span class="sxs-lookup"><span data-stu-id="6059a-274">For the example in figure 1,</span></span>  
  
-   <span data-ttu-id="6059a-275">L'analyse d'index cluster sur la table Customer a estimé 91 lignes, pour 91 réelles.</span><span class="sxs-lookup"><span data-stu-id="6059a-275">The clustered index scan on Customer has estimated 91; actual 91.</span></span>  
  
-   <span data-ttu-id="6059a-276">L'analyse d'index non cluster sur la table CustomerID a estimé 830 lignes, pour 830 réelles.</span><span class="sxs-lookup"><span data-stu-id="6059a-276">The nonclustered index scan on CustomerID has estimated 830; actual 830.</span></span>  
  
-   <span data-ttu-id="6059a-277">L'opérateur Merge Join a estimé 815 lignes, pour 830 réelles.</span><span class="sxs-lookup"><span data-stu-id="6059a-277">The Merge Join operator has estimated 815; actual 830.</span></span>  
  
 <span data-ttu-id="6059a-278">Les estimations des analyses d'index sont exactes.</span><span class="sxs-lookup"><span data-stu-id="6059a-278">The estimates for the index scans are accurate.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="6059a-279">conserve le nombre de lignes pour les tables sur disque.</span><span class="sxs-lookup"><span data-stu-id="6059a-279">maintains the row count for disk-based tables.</span></span> <span data-ttu-id="6059a-280">Les estimations des analyses complètes de la table et de l'index sont toujours exactes.</span><span class="sxs-lookup"><span data-stu-id="6059a-280">Estimates for full table and index scans are always accurate.</span></span> <span data-ttu-id="6059a-281">L'estimation de la jointure est aussi relativement exacte.</span><span class="sxs-lookup"><span data-stu-id="6059a-281">The estimate for the join is fairly accurate, too.</span></span>  
  
 <span data-ttu-id="6059a-282">Si ces estimations changent, le coût des différents choix de plan change aussi.</span><span class="sxs-lookup"><span data-stu-id="6059a-282">If these estimates change, the cost considerations for different plan alternatives change as well.</span></span> <span data-ttu-id="6059a-283">Par exemple, si un des côtés de la jointure a un nombre estimé de lignes de 1, ou seulement quelques lignes, l'utilisation de jointures de boucles imbriquées est moins coûteuse.</span><span class="sxs-lookup"><span data-stu-id="6059a-283">For example, if one of the sides of the join has an estimated row count of 1 or just a few rows, using a nested loops joins is less expensive.</span></span>  
  
 <span data-ttu-id="6059a-284">Voici le plan de la requête :</span><span class="sxs-lookup"><span data-stu-id="6059a-284">The following is the plan for the query:</span></span>  
  
```  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="6059a-285">Après la suppression de toutes les lignes, à part une dans la table Customer :</span><span class="sxs-lookup"><span data-stu-id="6059a-285">After deleting all rows but one in the table Customer:</span></span>  
  
 <span data-ttu-id="6059a-286">![Statistiques et jointures de colonne.](../../database-engine/media/hekaton-query-plan-9.gif "Statistiques et jointures de colonne.")</span><span class="sxs-lookup"><span data-stu-id="6059a-286">![Column statistics and joins.](../../database-engine/media/hekaton-query-plan-9.gif "Column statistics and joins.")</span></span>  
  
 <span data-ttu-id="6059a-287">À propos de ce plan de requête :</span><span class="sxs-lookup"><span data-stu-id="6059a-287">Regarding this query plan:</span></span>  
  
-   <span data-ttu-id="6059a-288">L'opérateur Hash Match a été remplacé par un opérateur de jointure physique Nested Loops.</span><span class="sxs-lookup"><span data-stu-id="6059a-288">The Hash Match has been replaced with a Nested Loops physical join operator.</span></span>  
  
-   <span data-ttu-id="6059a-289">L'analyse complète d'un index sur IX_CustomerID a été remplacée par une recherche d'index.</span><span class="sxs-lookup"><span data-stu-id="6059a-289">The full index scan on IX_CustomerID has been replaced with an index seek.</span></span> <span data-ttu-id="6059a-290">Cela a abouti à l'analyse de 5 lignes, au lieu des 830 lignes requises pour l'analyse complète de l'index.</span><span class="sxs-lookup"><span data-stu-id="6059a-290">This resulted in scanning 5 rows, instead of the 830 rows required for the full index scan.</span></span>  
  
### <a name="statistics-and-cardinality-for-memory-optimized-tables"></a><span data-ttu-id="6059a-291">Statistiques et cardinalité pour les tables mémoire optimisées</span><span class="sxs-lookup"><span data-stu-id="6059a-291">Statistics and Cardinality for Memory-Optimized Tables</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="6059a-292">conserve les statistiques des colonnes pour les tables mémoire optimisées.</span><span class="sxs-lookup"><span data-stu-id="6059a-292">maintains column-level statistics for memory-optimized tables.</span></span> <span data-ttu-id="6059a-293">En outre, le nombre réel de lignes de la table est conservé.</span><span class="sxs-lookup"><span data-stu-id="6059a-293">In addition, it maintains the actual row count of the table.</span></span> <span data-ttu-id="6059a-294">Toutefois, contrairement aux tables sur disque, les statistiques des tables mémoire optimisées ne sont pas mises à jour automatiquement.</span><span class="sxs-lookup"><span data-stu-id="6059a-294">However, in contrast to disk-based tables, the statistics for memory-optimized tables are not automatically updated.</span></span> <span data-ttu-id="6059a-295">Par conséquent, les statistiques doivent être mises à jour manuellement après des modifications significatives dans les tables.</span><span class="sxs-lookup"><span data-stu-id="6059a-295">Therefore, statistics need to be manually updated after significant changes in the tables.</span></span> <span data-ttu-id="6059a-296">Pour plus d’informations, consultez [Statistiques pour les tables optimisées en mémoire](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="6059a-296">For more information, see [Statistics for Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6059a-297">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="6059a-297">See Also</span></span>  
 [<span data-ttu-id="6059a-298">Tables à mémoire optimisée</span><span class="sxs-lookup"><span data-stu-id="6059a-298">Memory-Optimized Tables</span></span>](memory-optimized-tables.md)  
  
  
