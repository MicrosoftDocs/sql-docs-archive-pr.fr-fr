---
title: Introduction aux tables optimisées en mémoire | Microsoft Docs
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87709463"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="6cdb8-102">Introduction aux tables optimisées en mémoire</span><span class="sxs-lookup"><span data-stu-id="6cdb8-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="6cdb8-103">Les tables optimisées en mémoire sont des tables créées à l’aide de [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="6cdb8-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="6cdb8-104">Les tables optimisés en mémoire résident en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="6cdb8-105">Les lignes de la table sont lues et écrites dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="6cdb8-106">L'ensemble de la table réside dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-106">The entire table resides in memory.</span></span> <span data-ttu-id="6cdb8-107">Une deuxième copie des données de la table est conservée sur le disque, mais uniquement pour la durabilité.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="6cdb8-108">L'OLTP en mémoire est intégré à [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] pour offrir une expérience transparente dans tous les domaines, tels que le développement, le déploiement, la gestion et la prise en charge.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="6cdb8-109">Une base de données peut contenir des objets en mémoire et sur disque.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="6cdb8-110">Les lignes des tables optimisées en mémoire ont un contrôle de version.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="6cdb8-111">Cela signifie que chaque ligne de la table a potentiellement plusieurs versions.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="6cdb8-112">Toutes les versions de ligne sont conservées dans la même structure de données de la table.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="6cdb8-113">Le contrôle de version de ligne est utilisé pour autoriser les lectures et les écritures simultanées sur la même ligne.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="6cdb8-114">Pour plus d'informations sur les lectures et les écritures simultanées sur la même ligne, consultez [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="6cdb8-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="6cdb8-115">La figure ci-dessous illustre les contrôles de version multiples.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="6cdb8-116">Elle représente une table de trois lignes ayant chacune plusieurs versions.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="6cdb8-117">![Contrôles de version multiples.](../../database-engine/media/hekaton-tables-1.gif "Contrôles de version multiples.")</span><span class="sxs-lookup"><span data-stu-id="6cdb8-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="6cdb8-118">La table a trois lignes : r1, r2 et r3.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="6cdb8-119">r1 a trois versions, r2 a deux versions, et r3 a quatre versions.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="6cdb8-120">Notez que les différentes versions de la même ligne n'occupent pas nécessairement des emplacements de mémoire consécutifs.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="6cdb8-121">Les différentes versions de ligne peuvent être dispersées dans l'ensemble de la structure de données de la table.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="6cdb8-122">La structure de données des tables optimisées en mémoire peut être considérée comme une collection de versions de ligne.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="6cdb8-123">Les lignes d'une table sur disque sont organisées dans des pages et des extensions, et les lignes individuelles sont traitées sur la base du numéro et du décalage de la page, les versions de ligne dans les tables optimisées en mémoire sont traitées à l'aide de pointeurs de mémoire à huit octets.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="6cdb8-124">Durabilité</span><span class="sxs-lookup"><span data-stu-id="6cdb8-124">Durability</span></span>  
 <span data-ttu-id="6cdb8-125">Les tables optimisées en mémoire sont durables par défaut, et tout comme les transactions sur des tables sur disque (traditionnelles), les transactions durables sur les tables optimisées en mémoire présentent toutes les propriétés ACID (atomicité, cohérence, isolation et durabilité).</span><span class="sxs-lookup"><span data-stu-id="6cdb8-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="6cdb8-126">Les tables optimisées en mémoire et les procédures stockées compilées en mode natif prennent en charge un sous-ensemble de [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="6cdb8-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="6cdb8-127">L'OLTP en mémoire prend en charge les tables durables avec durabilité retardée des transactions.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="6cdb8-128">Les transactions durables retardées sont enregistrées sur disque peu après la validation de la transaction.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="6cdb8-129">En revanche, les transactions validées qui n'ont pas été enregistrées sur le disque sont perdues en cas de défaillance ou de basculement du serveur.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="6cdb8-130">Outre les tables optimisées en mémoire durables par défaut, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] prend également en charge les tables optimisées en mémoire non durables, qui ne sont pas enregistrées et dont les données ne sont pas rendues persistantes sur disque.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="6cdb8-131">Cela signifie que les transactions sur ces tables ne nécessitent aucune E/S disque, mais que les données ne sont pas récupérées suite à un incident ou à une défaillance du serveur.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="6cdb8-132">Accès aux données des tables optimisées en mémoire</span><span class="sxs-lookup"><span data-stu-id="6cdb8-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="6cdb8-133">Les données des tables optimisées en mémoire sont accessibles de deux manières :</span><span class="sxs-lookup"><span data-stu-id="6cdb8-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="6cdb8-134">Via le [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété (en dehors d'une procédure stockée compilée en mode natif).</span><span class="sxs-lookup"><span data-stu-id="6cdb8-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="6cdb8-135">Ces instructions [!INCLUDE[tsql](../../../includes/tsql-md.md)] peuvent être dans des procédures stockées interprétées ou des instructions [!INCLUDE[tsql](../../../includes/tsql-md.md)] ad hoc.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="6cdb8-136">Via des procédures stockées compilées en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="6cdb8-137">Les tables optimisées en mémoire sont plus efficacement accessibles à partir des procédures stockées compilées en mode natif ([Procédures stockées compilées en mode natif](natively-compiled-stored-procedures.md)).</span><span class="sxs-lookup"><span data-stu-id="6cdb8-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="6cdb8-138">Elles peuvent également être accédées via du [!INCLUDE[tsql](../../../includes/tsql-md.md)]traditionnel et interprète.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="6cdb8-139">Le terme [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété fait référence à l'accès aux tables optimisées en mémoire sans procédure stockée compilée en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="6cdb8-140">Parmi les exemples d'accès en [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété figure l'accès à une table optimisée en mémoire à partir d'un déclencheur DML ou d'un traitement, d'une vue ou d'une fonction table [!INCLUDE[tsql](../../../includes/tsql-md.md)] ad hoc.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="6cdb8-141">Le tableau suivant résume l'accès natif et l'accès en [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété pour différents objets.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="6cdb8-142">Fonctionnalité</span><span class="sxs-lookup"><span data-stu-id="6cdb8-142">Feature</span></span>|<span data-ttu-id="6cdb8-143">Accès à l'aide d'une procédure stockée compilée en mode natif</span><span class="sxs-lookup"><span data-stu-id="6cdb8-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="6cdb8-144">Accès en [!INCLUDE[tsql](../../../includes/tsql-md.md)] interprété</span><span class="sxs-lookup"><span data-stu-id="6cdb8-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="6cdb8-145">Accès CLR</span><span class="sxs-lookup"><span data-stu-id="6cdb8-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="6cdb8-146">Tables optimisées en mémoire</span><span class="sxs-lookup"><span data-stu-id="6cdb8-146">Memory-optimized tables</span></span>|<span data-ttu-id="6cdb8-147">Oui</span><span class="sxs-lookup"><span data-stu-id="6cdb8-147">Yes</span></span>|<span data-ttu-id="6cdb8-148">Oui</span><span class="sxs-lookup"><span data-stu-id="6cdb8-148">Yes</span></span>|<span data-ttu-id="6cdb8-149">Non <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="6cdb8-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="6cdb8-150">Variables de table optimisée en mémoire</span><span class="sxs-lookup"><span data-stu-id="6cdb8-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="6cdb8-151">Oui</span><span class="sxs-lookup"><span data-stu-id="6cdb8-151">Yes</span></span>|<span data-ttu-id="6cdb8-152">Oui</span><span class="sxs-lookup"><span data-stu-id="6cdb8-152">Yes</span></span>|<span data-ttu-id="6cdb8-153">Non</span><span class="sxs-lookup"><span data-stu-id="6cdb8-153">No</span></span>|  
|[<span data-ttu-id="6cdb8-154">Procédures stockées compilées en mode natif</span><span class="sxs-lookup"><span data-stu-id="6cdb8-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="6cdb8-155">Vous ne pouvez pas utiliser l'instruction EXECUTE pour exécuter une procédure stockée à partir d'une procédure stockée compilée en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="6cdb8-156">Oui</span><span class="sxs-lookup"><span data-stu-id="6cdb8-156">Yes</span></span>|<span data-ttu-id="6cdb8-157">Non <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="6cdb8-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="6cdb8-158"><sup>1</sup> vous ne pouvez pas accéder à une table optimisée en mémoire ou à une procédure stockée compilée en mode natif à partir de la connexion contextuelle (connexion à partir de lors de l' [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] exécution d’un module CLR).</span><span class="sxs-lookup"><span data-stu-id="6cdb8-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="6cdb8-159">Cependant, vous pouvez créer et ouvrir une autre connexion à partir de laquelle vous accédez aux tables optimisées en mémoire et aux procédures stockées compilées en mode natif.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="6cdb8-160">Pour plus d’informations, consultez [connexions régulières et contextuelles](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span><span class="sxs-lookup"><span data-stu-id="6cdb8-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="6cdb8-161">Performances et extensibilité</span><span class="sxs-lookup"><span data-stu-id="6cdb8-161">Performance and Scalability</span></span>  
 <span data-ttu-id="6cdb8-162">Les facteurs suivants affectent les gains de performance pouvant être obtenus avec l'OLTP en mémoire :</span><span class="sxs-lookup"><span data-stu-id="6cdb8-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="6cdb8-163">La communication</span><span class="sxs-lookup"><span data-stu-id="6cdb8-163">Communication</span></span>  
 <span data-ttu-id="6cdb8-164">Une application comportant de nombreux appels à des procédures stockées courtes aura un moindre gain de performances par rapport à une application comportant moins d'appels et plus de fonctionnalités implémentées dans chaque procédure stockée.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="6cdb8-165">Exécution</span><span class="sxs-lookup"><span data-stu-id="6cdb8-165">Execution</span></span>  
 <span data-ttu-id="6cdb8-166">L'OLTP en mémoire offre des performances optimales si vous utilisez des procédures stockées compilées en mode natif plutôt que des procédures stockées interprétées ou l'exécution de requêtes.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="6cdb8-167">Les procédures stockées qui exécutent d'autres procédures stockées ne peuvent pas être compilées en mode natif, mais elles sont avantageuses pour l'accès aux tables optimisées en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="6cdb8-168">Comparaison entre l'analyse de plage et la recherche de points</span><span class="sxs-lookup"><span data-stu-id="6cdb8-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="6cdb8-169">Les index non cluster mémoire optimisés prennent en charge les analyses de plage et les analyses triées.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="6cdb8-170">Pour les recherches de points, les index de hachage optimisés en mémoire offrent de meilleures performances que les index non cluster optimisés en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="6cdb8-171">Les index non cluster optimisés en mémoire offrent de meilleures performances que les index sur disque.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="6cdb8-172">Les opérations d'index ne sont pas stockées et existent uniquement en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="6cdb8-173">Accès concurrentiel</span><span class="sxs-lookup"><span data-stu-id="6cdb8-173">Concurrency</span></span>  
 <span data-ttu-id="6cdb8-174">Pour les applications dont les performances sont affectées par l'accès simultané au niveau du moteur, tel que la contention de verrous internes ou le blocage, les performances s'améliorent de façon significative lorsque l'application passe à l'OLTP en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="6cdb8-175">Le tableau suivant répertorie les problèmes de performance et d'extensibilité couramment rencontrés dans les bases de données relationnelles et indique comment l'OLTP peut améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="6cdb8-176">Problème</span><span class="sxs-lookup"><span data-stu-id="6cdb8-176">Issue</span></span>|<span data-ttu-id="6cdb8-177">Impact sur l'OLTP en mémoire</span><span class="sxs-lookup"><span data-stu-id="6cdb8-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="6cdb8-178">Performances</span><span class="sxs-lookup"><span data-stu-id="6cdb8-178">Performance</span></span><br /><br /> <span data-ttu-id="6cdb8-179">Utilisation importante des ressources (UC, E/S, réseau ou mémoire).</span><span class="sxs-lookup"><span data-stu-id="6cdb8-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="6cdb8-180">UC</span><span class="sxs-lookup"><span data-stu-id="6cdb8-180">CPU</span></span><br /> <span data-ttu-id="6cdb8-181">Les procédures stockées compilées en mode natif peuvent réduire de façon significative l'utilisation de l'UC, car elles nécessitent moins d'instructions pour exécuter une instruction [!INCLUDE[tsql](../../../includes/tsql-md.md)] que les procédures stockées interprétées.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="6cdb8-182">L'OLTP en mémoire peut vous aider à réduire l'investissement en matériel dans des charges de travail avec montée en puissance parallèle, car un serveur peut assurer à lui seul le débit de cinq à dix serveurs.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="6cdb8-183">E/S</span><span class="sxs-lookup"><span data-stu-id="6cdb8-183">I/O</span></span><br /> <span data-ttu-id="6cdb8-184">Si vous observez un goulot d'étranglement des E/S à partir du traitement des données ou des pages d'index, l'OLTP en mémoire peut l'atténuer.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="6cdb8-185">En outre, les points de contrôle des objets OLTP en mémoire sont continus et n'entraînent pas une hausse soudaine des opérations d'E/S.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="6cdb8-186">Toutefois, si la plage de travail des tables critiques pour les performances ne tient pas en mémoire, l'OLTP en mémoire n'améliore pas les performances, car il nécessite que les données résident en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="6cdb8-187">Si vous observez un goulot d'étranglement des E/S lors de la journalisation, l'OLTP en mémoire l'atténue, car il nécessite moins d'opérations de journalisation.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="6cdb8-188">Si une ou plusieurs tables optimisées en mémoire sont configurées en tant que tables non durables, supprimez la journalisation des données.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="6cdb8-189">Mémoire</span><span class="sxs-lookup"><span data-stu-id="6cdb8-189">Memory</span></span><br /> <span data-ttu-id="6cdb8-190">L'OLTP en mémoire ne procure aucun gain de performance.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="6cdb8-191">Il peut en effet solliciter davantage la mémoire, car les objets doivent résider en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="6cdb8-192">Réseau</span><span class="sxs-lookup"><span data-stu-id="6cdb8-192">Network</span></span><br /> <span data-ttu-id="6cdb8-193">L'OLTP en mémoire ne procure aucun gain de performance.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="6cdb8-194">Les données doivent être communiquées de la couche Données à la couche Application.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="6cdb8-195">Extensibilité</span><span class="sxs-lookup"><span data-stu-id="6cdb8-195">Scalability</span></span><br /><br /> <span data-ttu-id="6cdb8-196">La plupart des problèmes de mise à l'échelle dans les applications [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] sont dus à des problèmes d'accès concurrentiel tels que la contention dans les verrous, les verrous internes et les verrouillages tournants.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="6cdb8-197">Contention de verrous internes</span><span class="sxs-lookup"><span data-stu-id="6cdb8-197">Latch Contention</span></span><br /> <span data-ttu-id="6cdb8-198">Un scénario typique est la contention dans la dernière page d'un index lors de l'insertion simultanée de lignes dans l'ordre des clés.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="6cdb8-199">Étant donné que l'OLTP en mémoire ne prend pas de verrou interne lors de l'accès aux données, il n'y a plus de problèmes d'extensibilité liés à la contention de verrous internes.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="6cdb8-200">Contention de verrouillage tournant</span><span class="sxs-lookup"><span data-stu-id="6cdb8-200">Spinlock Contention</span></span><br /> <span data-ttu-id="6cdb8-201">Étant donné que l'OLTP en mémoire ne prend pas de verrou interne lors de l'accès aux données, il n'y a plus de problèmes d'extensibilité liés à la contention de verrouillage tournant.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="6cdb8-202">Contention liée au verrouillage</span><span class="sxs-lookup"><span data-stu-id="6cdb8-202">Locking Related Contention</span></span><br /> <span data-ttu-id="6cdb8-203">Si votre application de base de données rencontre des problèmes de blocage entre les opérations de lecture et d'écriture, l'OLTP en mémoire les supprime, car il utilise une nouvelle forme de contrôle d'accès concurrentiel optimiste pour implémenter tous les niveaux d'isolation des transactions.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="6cdb8-204">L'OLTP en mémoire n'utilise pas TempDB pour stocker les versions de ligne.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="6cdb8-205">Si le problème de mise à l'échelle est provoqué par un conflit entre deux opérations d'écriture, telles que deux transactions simultanées tentant de mettre à jour la même ligne, l'OLTP en mémoire laisse une transaction aboutir et fait échouer l'autre.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="6cdb8-206">La transaction en échec doit être retentée par un nouvel envoi explicite ou implicite.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="6cdb8-207">Dans les deux cas, vous devez apporter des modifications à l'application.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="6cdb8-208">Si votre application crée des conflits fréquents entre deux opérations d'écriture, la valeur du verrouillage optimiste est diminuée.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="6cdb8-209">L'application ne convient pas pour l'OLTP en mémoire.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="6cdb8-210">La plupart des applications OLTP ne connaissent pas de conflits d’écriture à moins que le conflit ne soit induit par une escalade de verrous.</span><span class="sxs-lookup"><span data-stu-id="6cdb8-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="6cdb8-211">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="6cdb8-211">See Also</span></span>  
 [<span data-ttu-id="6cdb8-212">OLTP en mémoire &#40;Optimisation en mémoire&#41;</span><span class="sxs-lookup"><span data-stu-id="6cdb8-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  
