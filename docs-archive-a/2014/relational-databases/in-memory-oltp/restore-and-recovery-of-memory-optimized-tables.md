---
title: Restauration et récupération de tables optimisées en mémoire | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 294975b7-e7d1-491b-b66a-fdb1100d2acc
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 5e702798ea68745a038407fb65af7726a5c5d50e
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87612328"
---
# <a name="restore-and-recovery-of-memory-optimized-tables"></a><span data-ttu-id="af8c5-102">Restauration et récupération de tables mémoire optimisées</span><span class="sxs-lookup"><span data-stu-id="af8c5-102">Restore and Recovery of Memory-Optimized Tables</span></span>
  <span data-ttu-id="af8c5-103">Le mécanisme de base utilisé pour récupérer ou restaurer une base de données avec des tables mémoire optimisées est similaire à celui utilisé pour les bases de données avec uniquement des tables sur disque.</span><span class="sxs-lookup"><span data-stu-id="af8c5-103">The basic mechanism to recover or restore a database with memory-optimized tables is similar to databases with only disk-based tables.</span></span> <span data-ttu-id="af8c5-104">Mais à la différence des tables sur disque, les tables mémoire optimisées doivent être chargées dans la mémoire avant que la base de données soit disponible pour l'accès utilisateur.</span><span class="sxs-lookup"><span data-stu-id="af8c5-104">But unlike disk-based tables, memory-optimized tables must be loaded into memory before database is available for user access.</span></span> <span data-ttu-id="af8c5-105">Cela ajoute une nouvelle étape à la récupération de la base de données.</span><span class="sxs-lookup"><span data-stu-id="af8c5-105">This adds a new step in the database recovery.</span></span> <span data-ttu-id="af8c5-106">Les étapes de récupération de bases de données sont modifiées comme suit :</span><span class="sxs-lookup"><span data-stu-id="af8c5-106">The modified steps in database recovery are changed as follows:</span></span>

 <span data-ttu-id="af8c5-107">Lorsque [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] redémarre, chaque base de données passe via une phase de récupération qui comprend les trois phases suivantes :</span><span class="sxs-lookup"><span data-stu-id="af8c5-107">When the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] restarts, each database goes through a recovery phase that consists of the following three phases:</span></span>

1.  <span data-ttu-id="af8c5-108">Phase d'analyse.</span><span class="sxs-lookup"><span data-stu-id="af8c5-108">The analysis phase.</span></span> <span data-ttu-id="af8c5-109">Pendant cette phase, un test est effectué sur les journaux des transactions actifs pour détecter les transactions validées et enregistrées.</span><span class="sxs-lookup"><span data-stu-id="af8c5-109">During this phase, a pass is made on the active transaction logs to detect committed and uncommitted transactions.</span></span> <span data-ttu-id="af8c5-110">Le moteur OLTP en mémoire identifie le point de contrôle à charger et précharge ses entrées de journal de table système.</span><span class="sxs-lookup"><span data-stu-id="af8c5-110">The In-Memory OLTP engine identifies the checkpoint to load and preloads its system table log entries.</span></span> <span data-ttu-id="af8c5-111">Il traite également certains enregistrements du journal d'allocation de fichier.</span><span class="sxs-lookup"><span data-stu-id="af8c5-111">It will also process some file allocation log records.</span></span>

2.  <span data-ttu-id="af8c5-112">Phase de restauration par progression.</span><span class="sxs-lookup"><span data-stu-id="af8c5-112">The redo phase.</span></span> <span data-ttu-id="af8c5-113">Cette étape est exécutée simultanément sur les tables sur disque et sur les tables mémoire optimisées.</span><span class="sxs-lookup"><span data-stu-id="af8c5-113">This phase is run concurrently on both disk-based and memory-optimized tables.</span></span>

     <span data-ttu-id="af8c5-114">Pour les tables sur disque, la base de données est déplacée à la date et heure actuelles et obtient les verrous pris par les transactions non validées.</span><span class="sxs-lookup"><span data-stu-id="af8c5-114">For disk-based tables, the database is moved to the current point in time and acquires locks taken by uncommitted transactions.</span></span>

     <span data-ttu-id="af8c5-115">Pour les tables mémoire optimisées, les données des paires de fichiers de données et delta sont chargées dans la mémoire puis mises à jour avec le journal des transactions actif en fonction du dernier point de contrôle durable.</span><span class="sxs-lookup"><span data-stu-id="af8c5-115">For memory-optimized tables, data from the data and delta file pairs are loaded into memory and then update the data with the active transaction log based on the last durable checkpoint.</span></span>

     <span data-ttu-id="af8c5-116">Lorsque les opérations sur les tables sur disque et sur les tables mémoire optimisées sont terminées, la base de données est accessible.</span><span class="sxs-lookup"><span data-stu-id="af8c5-116">When the above operations on disk-based and memory-optimized tables are complete, the database is available for access.</span></span>

3.  <span data-ttu-id="af8c5-117">Phase de restauration.</span><span class="sxs-lookup"><span data-stu-id="af8c5-117">The undo phase.</span></span> <span data-ttu-id="af8c5-118">Au cours de cette phase, les transactions non validées sont restaurées.</span><span class="sxs-lookup"><span data-stu-id="af8c5-118">In this phase, the uncommitted transactions are rolled back.</span></span>

 <span data-ttu-id="af8c5-119">Le chargement des tables mémoire optimisées dans la mémoire peut affecter les performances de l'objectif de temps de récupération (RTO).</span><span class="sxs-lookup"><span data-stu-id="af8c5-119">Loading memory-optimized tables into memory can affect performance of the recovery time objective (RTO).</span></span> <span data-ttu-id="af8c5-120">Pour améliorer le temps de chargement des données mémoire optimisées à partir des fichiers de données et des fichiers delta, le moteur de l'OLTP en mémoire charge les fichiers de données/delta en parallèle, comme suit :</span><span class="sxs-lookup"><span data-stu-id="af8c5-120">To improve the load time of memory-optimized data from data and delta files, the In-Memory OLTP engine loads the data/delta files in parallel as follows:</span></span>

-   <span data-ttu-id="af8c5-121">Création d'un filtre de mappage de delta.</span><span class="sxs-lookup"><span data-stu-id="af8c5-121">Creating a Delta Map Filter.</span></span> <span data-ttu-id="af8c5-122">Le magasin de fichiers delta référence les lignes supprimées.</span><span class="sxs-lookup"><span data-stu-id="af8c5-122">Delta files store references to the deleted rows.</span></span> <span data-ttu-id="af8c5-123">Un thread par conteneur lit les fichiers delta et crée un filtre de mappage de delta.</span><span class="sxs-lookup"><span data-stu-id="af8c5-123">One thread per container reads the delta files and creates a delta map filter.</span></span> <span data-ttu-id="af8c5-124">(Un groupe de fichiers de données mémoire optimisé peut avoir un ou plusieurs conteneurs.)</span><span class="sxs-lookup"><span data-stu-id="af8c5-124">(A memory optimized data filegroup can have one or more containers.)</span></span>

-   <span data-ttu-id="af8c5-125">Flux des fichiers de données.</span><span class="sxs-lookup"><span data-stu-id="af8c5-125">Streaming the data files.</span></span>  <span data-ttu-id="af8c5-126">Une fois le filtre de mappage de delta créé, les fichiers de données sont lus en utilisant autant de thread qu'il existe d'UC logiques.</span><span class="sxs-lookup"><span data-stu-id="af8c5-126">Once the delta-map filter is created, data files are read using as many threads as there are logical CPUs.</span></span> <span data-ttu-id="af8c5-127">Chaque thread qui lit le fichier de données lit les lignes de données, vérifie le mappage de delta associé et insère la ligne dans la table uniquement si cette ligne n'a pas été marquée comme supprimée.</span><span class="sxs-lookup"><span data-stu-id="af8c5-127">Each thread reading the data file reads the data rows, checks the associated delta map and only inserts the row into table if this row has not been marked deleted.</span></span> <span data-ttu-id="af8c5-128">Cette partie de la récupération peut être liée à l'UC dans certains cas, comme indiqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="af8c5-128">This part of recovery can be CPU bound in some cases as noted below.</span></span>

 <span data-ttu-id="af8c5-129">![Tables optimisées en mémoire.](../../database-engine/media/memory-optimized-tables.gif "Tables à mémoire optimisée.")</span><span class="sxs-lookup"><span data-stu-id="af8c5-129">![Memory-optimized tables.](../../database-engine/media/memory-optimized-tables.gif "Memory-optimized tables.")</span></span>

 <span data-ttu-id="af8c5-130">Les tables mémoire optimisées peuvent généralement être chargées dans la mémoire à la vitesse des E/S mais dans certains cas, le chargement des lignes de données dans la mémoire est plus lent.</span><span class="sxs-lookup"><span data-stu-id="af8c5-130">Memory-optimized tables can generally be loaded into memory at the speed of I/O but there are cases when loading data rows into memory will be slower.</span></span> <span data-ttu-id="af8c5-131">Les cas spécifiques sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="af8c5-131">Specific cases are:</span></span>

-   <span data-ttu-id="af8c5-132">Un nombre de compartiments faible pour l'index de hachage peut entraîner une collision excessive ralentissant les insertions des lignes de données.</span><span class="sxs-lookup"><span data-stu-id="af8c5-132">Low bucket count for hash index can lead to excessive collision causing data row inserts to be slower.</span></span> <span data-ttu-id="af8c5-133">Cela entraîne généralement une très forte utilisation du processeur tout le long, et en particulier à la fin de la récupération.</span><span class="sxs-lookup"><span data-stu-id="af8c5-133">This generally results in very high CPU utilization throughout, and especially towards the end of recovery.</span></span> <span data-ttu-id="af8c5-134">Si vous avez configuré l'index de hachage correctement, il ne devrait pas affecter le temps de récupération.</span><span class="sxs-lookup"><span data-stu-id="af8c5-134">If you configured the hash index correctly, it should not impact the recovery time.</span></span>

-   <span data-ttu-id="af8c5-135">Dans les tables mémoire optimisées avec un ou plusieurs index non cluster, contrairement à un index de hachage dont le nombre de compartiments est dimensionné lors de la création, les index non cluster augmentent dynamiquement, ce qui entraîne une forte utilisation de l'UC.</span><span class="sxs-lookup"><span data-stu-id="af8c5-135">Large memory-optimized tables with one or more nonclustered indexes, unlike a hash index whose bucket count is sized at create time, the nonclustered indexes grow dynamically, resulting in high CPU utilization.</span></span>

## <a name="restoring-a-database-with-memory-optimized-tables"></a><span data-ttu-id="af8c5-136">Restauration d'une base de données avec des tables mémoire optimisées</span><span class="sxs-lookup"><span data-stu-id="af8c5-136">Restoring a Database with Memory-optimized tables</span></span>
 <span data-ttu-id="af8c5-137">Vous savez que vous avez suffisamment de mémoire sur le serveur pour restaurer une base de données, mais il est nécessaire que la mémoire requise par la base de données soit prise en compte dans le cadre d'un pool de ressources existant.</span><span class="sxs-lookup"><span data-stu-id="af8c5-137">You know that you have sufficient memory on the server to restore a database, but there's a requirement  that the memory needed by the database is accounted for as part of an existing Resource Pool.</span></span>  <span data-ttu-id="af8c5-138">Vous savez que vous ne pouvez pas créer la liaison au pool de ressources avant que la base de données n’existe, et vous effectuez donc la restauration avec NORECOVERY.</span><span class="sxs-lookup"><span data-stu-id="af8c5-138">You know that you cannot create the binding to the resource pool before the database exists, so you perform the restore WITH NORECOVERY.</span></span>  <span data-ttu-id="af8c5-139">Cela entraîne la restauration de l’image disque de la base de données et la création de la base de données, mais la mémoire OLTP en mémoire n'est nullement utilisée, car la base de données n'est pas mise en ligne.</span><span class="sxs-lookup"><span data-stu-id="af8c5-139">This causes the disk image of the database to be restored and the database to be created, but no In-Memory OLTP memory is consumed because the database is not brought online.</span></span>

 <span data-ttu-id="af8c5-140">À ce stade, vous pouvez créer la liaison du pool de ressources à la base de données, puis utiliser RESTORE WITH RECOVERY pour mettre en ligne la base de données restaurée.</span><span class="sxs-lookup"><span data-stu-id="af8c5-140">At this point, you can create the Resource Pool to Database binding, and then use RESTORE WITH RECOVERY to bring the restored database online.</span></span>  <span data-ttu-id="af8c5-141">La liaison étant en place avant que la base de données ne soit mise en ligne, sa consommation de mémoire OLTP en mémoire est correctement pris en compte.</span><span class="sxs-lookup"><span data-stu-id="af8c5-141">Since the binding is in place before the database is brought online, its In-Memory OLTP memory consumption is properly accounted for.</span></span> <span data-ttu-id="af8c5-142">Cela nécessite de restaurer la base de données une seule fois.</span><span class="sxs-lookup"><span data-stu-id="af8c5-142">This requires restoring the database only once.</span></span> <span data-ttu-id="af8c5-143">La première commande RESTORE est une commande d'information qui lit uniquement l'en-tête de sauvegarde, et la dernière commande déclenche simplement la récupération, sans restaurer de bits.</span><span class="sxs-lookup"><span data-stu-id="af8c5-143">The first RESTORE command is an informational command that only reads the backup header, and the last command simply triggers recovery without actually restoring any bits.</span></span>

## <a name="see-also"></a><span data-ttu-id="af8c5-144">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="af8c5-144">See Also</span></span>
 [<span data-ttu-id="af8c5-145">Sauvegarder, restaurer et récupérer des tables optimisées en mémoire</span><span class="sxs-lookup"><span data-stu-id="af8c5-145">Backup, Restore, and Recovery of Memory-Optimized Tables</span></span>](memory-optimized-tables.md)


