---
title: Utilisations des paramètres table ODBC | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- table-valued parameters (ODBC), scenarios
- ODBC, table-valued parameters
ms.assetid: f1b73932-4570-4a8a-baa0-0f229d9c32ee
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b128246f7c4ed9a9cec5e28698c743877f9873d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87708247"
---
# <a name="uses-of-odbc-table-valued-parameters"></a><span data-ttu-id="888d2-102">Scénarios d'utilisation des paramètres table ODBC</span><span class="sxs-lookup"><span data-stu-id="888d2-102">Uses of ODBC Table-Valued Parameters</span></span>
  <span data-ttu-id="888d2-103">Cette rubrique présente les principaux scénarios utilisateur dans lesquels des paramètres table sont utilisés avec ODBC :</span><span class="sxs-lookup"><span data-stu-id="888d2-103">This topic discusses the primary user scenarios for using table-valued parameters with ODBC:</span></span>  
  
-   <span data-ttu-id="888d2-104">Paramètre table avec mémoires tampons multilignes entièrement liées (envoyer des données en tant que paramètre table avec toutes les valeurs en mémoire)</span><span class="sxs-lookup"><span data-stu-id="888d2-104">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
  
-   <span data-ttu-id="888d2-105">Paramètre table avec diffusion de lignes en continu (envoyer des données en tant que paramètre table à l'aide de données en cours d'exécution)</span><span class="sxs-lookup"><span data-stu-id="888d2-105">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
  
-   <span data-ttu-id="888d2-106">Récupération des métadonnées de paramètre table du catalogue système</span><span class="sxs-lookup"><span data-stu-id="888d2-106">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
  
-   <span data-ttu-id="888d2-107">Récupération des métadonnées de paramètre table pour une instruction préparée</span><span class="sxs-lookup"><span data-stu-id="888d2-107">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
  
## <a name="table-valued-parameter-with-fully-bound-multirow-buffers-send-data-as-a-tvp-with-all-values-in-memory"></a><span data-ttu-id="888d2-108">Paramètre table avec mémoires tampons multilignes entièrement liées (envoyer des données en tant que paramètre table avec toutes les valeurs en mémoire)</span><span class="sxs-lookup"><span data-stu-id="888d2-108">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
 <span data-ttu-id="888d2-109">Lorsqu'elles sont utilisées avec des mémoires tampons multilignes entièrement liées, toutes les valeurs de paramètres sont disponibles en mémoire.</span><span class="sxs-lookup"><span data-stu-id="888d2-109">When used with fully bound multirow buffers, all parameter values are available in memory.</span></span> <span data-ttu-id="888d2-110">Ce comportement est classique d'une transaction OLTP par exemple, dans laquelle les paramètres table peuvent être insérés dans une procédure stockée unique.</span><span class="sxs-lookup"><span data-stu-id="888d2-110">This is typical, for example, of an OLTP transaction, in which table-valued parameters can be packaged into a single stored procedure.</span></span> <span data-ttu-id="888d2-111">Sans paramètres table, il serait nécessaire de générer dynamiquement un lot à instructions multiples complexe ou d'effectuer plusieurs appels au serveur.</span><span class="sxs-lookup"><span data-stu-id="888d2-111">Without table-valued parameters, this would involve either generating a complex multi-statement batch dynamically, or making multiple calls to the server.</span></span>  
  
 <span data-ttu-id="888d2-112">Le paramètre table lui-même est lié à l’aide de [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) avec les autres paramètres.</span><span class="sxs-lookup"><span data-stu-id="888d2-112">The table-valued parameter itself is bound by using [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) along with the other parameters.</span></span> <span data-ttu-id="888d2-113">Une fois que tous les paramètres ont été liés, l’application définit l’attribut focus du paramètre, SQL_SOPT_SS_PARAM_FOCUS, sur chaque paramètre table et appelle SQLBindParameter pour les colonnes du paramètre table.</span><span class="sxs-lookup"><span data-stu-id="888d2-113">After all parameters have been bound, the application sets the parameter focus attribute, SQL_SOPT_SS_PARAM_FOCUS, on each table-valued parameter and calls SQLBindParameter for the columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="888d2-114">Le type de serveur d'un paramètre table est un nouveau type spécifique à [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], SQL_SS_TABLE.</span><span class="sxs-lookup"><span data-stu-id="888d2-114">The server type for a table-valued parameter is a new [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-specific type, SQL_SS_TABLE.</span></span> <span data-ttu-id="888d2-115">Le type C de liaison pour SQL_SS_TABLE doit toujours être SQL_C_DEFAULT.</span><span class="sxs-lookup"><span data-stu-id="888d2-115">The binding C type for SQL_SS_TABLE must always be SQL_C_DEFAULT.</span></span> <span data-ttu-id="888d2-116">Aucune donnée n'est transférée pour le paramètre lié au paramètre table ; il est utilisé pour passer les métadonnées de table et contrôler comment passer des données dans les colonnes qui constituent le paramètre table.</span><span class="sxs-lookup"><span data-stu-id="888d2-116">No data is transferred for the table-valued parameter bound parameter; it is used to pass table metadata and to control how to pass data in the constituent columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="888d2-117">La longueur du paramètre table est définie sur le nombre de lignes qui sont envoyées au serveur.</span><span class="sxs-lookup"><span data-stu-id="888d2-117">The length of the table-valued parameter is set to the number of rows being sent to the server.</span></span> <span data-ttu-id="888d2-118">Le paramètre *Column* de SQLBindParameter pour un paramètre table spécifie le nombre maximal de lignes qui peuvent être envoyées ; Il s’agit de la taille de tableau des mémoires tampons de colonne.</span><span class="sxs-lookup"><span data-stu-id="888d2-118">The *ColumnSize* parameter of SQLBindParameter for a table-valued parameter specifies the maximum number of rows that can be sent; this is the array size of the column buffers.</span></span> <span data-ttu-id="888d2-119">*ParameterValuePtr* est la mémoire tampon des paramètres, pour un paramètre table dans SQLBindParameter.</span><span class="sxs-lookup"><span data-stu-id="888d2-119">*ParameterValuePtr* is the parameter buffer,for a table-valued parameter in SQLBindParameter.</span></span> <span data-ttu-id="888d2-120">*ParameterValuePtr* et ses *BufferLength* associés sont utilisés pour passer le nom de type du paramètre table si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="888d2-120">*ParameterValuePtr* and its associated *BufferLength* are used to pass the type name of the table-valued parameter when required.</span></span> <span data-ttu-id="888d2-121">Le nom de type n'est pas requis pour les appels de procédure stockée, mais il est requis pour les instructions SQL.</span><span class="sxs-lookup"><span data-stu-id="888d2-121">The type name is not required for stored procedure calls, but it is required for SQL statements.</span></span>  
  
 <span data-ttu-id="888d2-122">Lorsqu’un nom de type de paramètre table est spécifié sur un appel à SQLBindParameter, il doit toujours être spécifié en tant que valeur Unicode, même dans les applications générées en tant qu’applications ANSI.</span><span class="sxs-lookup"><span data-stu-id="888d2-122">When a table-valued parameter type name is specified on a call to SQLBindParameter, it must always be specified as a Unicode value, even in applications that are built as ANSI applications.</span></span> <span data-ttu-id="888d2-123">Lorsque vous spécifiez un nom de type de paramètre table à l’aide de SQLSetDescField, vous pouvez utiliser un littéral qui est conforme à la façon dont l’application est générée.</span><span class="sxs-lookup"><span data-stu-id="888d2-123">When you specify a table-valued parameter type name by using SQLSetDescField, you can use a literal that conforms to the way the application is built.</span></span> <span data-ttu-id="888d2-124">Le Gestionnaire de pilotes ODBC effectuera toute conversion Unicode requise.</span><span class="sxs-lookup"><span data-stu-id="888d2-124">The ODBC Driver Manager will perform any required Unicode conversion.</span></span>  
  
 <span data-ttu-id="888d2-125">Les métadonnées pour les paramètres table et les colonnes de paramètre table peuvent être manipulées individuellement et explicitement à l’aide de SQLGetDescRec, SQLSetDescRec, SQLGetDescField et SQLSetDescField.</span><span class="sxs-lookup"><span data-stu-id="888d2-125">Metadata for table-valued parameters and table-valued parameter columns can be manipulated individually and explicitly by using SQLGetDescRec, SQLSetDescRec, SQLGetDescField, and SQLSetDescField.</span></span> <span data-ttu-id="888d2-126">Toutefois, la surcharge de SQLBindParameter est généralement plus pratique et ne nécessite pas d’accès explicite au descripteur dans la plupart des cas.</span><span class="sxs-lookup"><span data-stu-id="888d2-126">However, overloading SQLBindParameter is usually more convenient and does not require explicit descriptor access in most cases.</span></span> <span data-ttu-id="888d2-127">Cette approche est cohérente avec la définition de SQLBindParameter pour d’autres types de données, sauf que pour un paramètre table, les champs de descripteur affectés sont légèrement différents.</span><span class="sxs-lookup"><span data-stu-id="888d2-127">This approach is consistent with the definition of SQLBindParameter for other data types, except that for a table-valued parameter the affected descriptor fields are slightly different.</span></span>  
  
 <span data-ttu-id="888d2-128">Une application utilise parfois un paramètre table avec Dynamic SQL et le nom de type du paramètre table doit être fourni.</span><span class="sxs-lookup"><span data-stu-id="888d2-128">Sometimes, an application uses a table-valued parameter with dynamic SQL and the type name of the table-valued parameter must be supplied.</span></span> <span data-ttu-id="888d2-129">Si c’est le cas et si le paramètre table n’est pas défini dans le schéma par défaut actuel de la connexion, SQL_CA_SS_TYPE_CATALOG_NAME et SQL_CA_SS_TYPE_SCHEMA_NAME doivent être définis à l’aide de SQLSetDescField.</span><span class="sxs-lookup"><span data-stu-id="888d2-129">If this is the case and the table-valued parameter is not defined in the current default schema for the connection, SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME must be set by using SQLSetDescField.</span></span> <span data-ttu-id="888d2-130">Dans la mesure où les définitions de type de table et les paramètres table doivent se trouver dans la même base de données, SQL_CA_SS_TYPE_CATALOG_NAME ne doit pas être défini si l'application utilise des paramètres table.</span><span class="sxs-lookup"><span data-stu-id="888d2-130">Because table type definitions and table-valued parameters must be in the same database, SQL_CA_SS_TYPE_CATALOG_NAME must not be set if the application uses table-valued parameters.</span></span> <span data-ttu-id="888d2-131">Sinon, SQLSetDescField signale une erreur.</span><span class="sxs-lookup"><span data-stu-id="888d2-131">Otherwise, SQLSetDescField will report an error.</span></span>  
  
 <span data-ttu-id="888d2-132">L’exemple de code pour ce scénario est décrit dans la procédure `demo_fixed_TVP_binding` [utilisation des paramètres table &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="888d2-132">Sample code for this scenario is in the procedure `demo_fixed_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="table-valued-parameter-with-row-streaming-send-data-as-a-tvp-using-data-at-execution"></a><span data-ttu-id="888d2-133">Paramètre table avec diffusion de lignes en continu (envoyer des données en tant que paramètre table à l'aide de données en cours d'exécution)</span><span class="sxs-lookup"><span data-stu-id="888d2-133">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
 <span data-ttu-id="888d2-134">Dans ce scénario, l'application fournit des lignes au pilote quand il les lui demande et ces lignes sont transmises en continu au serveur.</span><span class="sxs-lookup"><span data-stu-id="888d2-134">In this scenario, the application supplies rows to the driver as it requests them and they are streamed to the server.</span></span> <span data-ttu-id="888d2-135">Ainsi, il n'est pas nécessaire que toutes les lignes soient mises en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="888d2-135">This avoids having to buffer all rows in memory.</span></span> <span data-ttu-id="888d2-136">Ceci est représentatif des scénarios d'insertion/mise à jour en bloc.</span><span class="sxs-lookup"><span data-stu-id="888d2-136">This is representative of bulk insert/update scenarios.</span></span> <span data-ttu-id="888d2-137">Les performances des paramètres table se situent entre les tableaux de paramètres et la copie en bloc.</span><span class="sxs-lookup"><span data-stu-id="888d2-137">Table-valued parameters provide a performance point somewhere between parameter arrays and bulk copy.</span></span> <span data-ttu-id="888d2-138">Autrement dit, les paramètres table sont pratiquement aussi faciles à programmer que les tableaux de paramètres, mais offrent une souplesse supérieure au niveau du serveur.</span><span class="sxs-lookup"><span data-stu-id="888d2-138">That is, table-valued parameters are about as easy to program as parameter arrays, but they provide greater flexibility at the server.</span></span>  
  
 <span data-ttu-id="888d2-139">Le paramètre table et ses colonnes sont liés comme discuté dans la section précédente, Paramètre table avec mémoires tampons multilignes entièrement liées, mais l'indicateur de longueur du paramètre table lui-même est défini sur SQL_DATA_AT_EXEC.</span><span class="sxs-lookup"><span data-stu-id="888d2-139">The table-valued parameter and its columns are bound as discussed in the previous section, Table-Valued Parameter with Fully Bound Multirow Buffers, but the length indicator of the table-valued parameter itself is set to SQL_DATA_AT_EXEC.</span></span> <span data-ttu-id="888d2-140">Le pilote répond à SQLExecute ou SQLExecuteDirect de la façon habituelle pour les paramètres de données en cours d’exécution, autrement dit, en retournant SQL_NEED_DATA.</span><span class="sxs-lookup"><span data-stu-id="888d2-140">The driver responds to SQLExecute or SQLExecuteDirect in the usual way for data-at-execution parameters-that is, by returning SQL_NEED_DATA.</span></span> <span data-ttu-id="888d2-141">Lorsque le pilote est prêt à accepter des données pour un paramètre table, SQLParamData retourne la valeur de *ParameterValuePtr* dans SQLBindParameter.</span><span class="sxs-lookup"><span data-stu-id="888d2-141">When the driver is ready to accept data for a table-valued parameter, SQLParamData returns the value of *ParameterValuePtr* in SQLBindParameter.</span></span>  
  
 <span data-ttu-id="888d2-142">Une application utilise SQLPutData pour un paramètre table pour indiquer la disponibilité des données pour les colonnes constituant des paramètres table.</span><span class="sxs-lookup"><span data-stu-id="888d2-142">An application uses SQLPutData for a table-valued parameter to indicate the availability of data for table-valued parameter constituent columns.</span></span> <span data-ttu-id="888d2-143">Lorsque SQLPutData est appelé pour un paramètre table, *DataPtr* doit toujours avoir la valeur null et *StrLen_Or_Ind* doit avoir la valeur 0 ou un nombre inférieur ou égal à la taille du tableau spécifié pour les tampons de paramètre table (paramètre *Column* de SQLBindParameter).</span><span class="sxs-lookup"><span data-stu-id="888d2-143">When SQLPutData is called for a table-valued parameter, *DataPtr* must always be null and *StrLen_or_Ind* must be either 0 or a number less than or equal to the array size specified for table-valued parameter buffers (the *ColumnSize* parameter of SQLBindParameter).</span></span> <span data-ttu-id="888d2-144">0 signifie qu'il n'y a plus de lignes pour le paramètre table et que le pilote passera au traitement du paramètre de procédure réel suivant.</span><span class="sxs-lookup"><span data-stu-id="888d2-144">0 signifies that there are no more rows for the table-valued parameter, and the driver will proceed to process to the next actual procedure parameter.</span></span> <span data-ttu-id="888d2-145">Lorsque *StrLen_Or_Ind* n’a pas la valeur 0, le pilote traite les colonnes constituantes du paramètre table de la même façon que les paramètres liés à un paramètre non table : chaque colonne de paramètre table peut spécifier sa longueur de données réelle, SQL_NULL_DATA, ou elle peut spécifier des données au moment de l’exécution par le biais de sa mémoire tampon de longueur/indicateur.</span><span class="sxs-lookup"><span data-stu-id="888d2-145">When *StrLen_or_Ind* is not 0, the driver will process the table-valued parameter constituent columns in the same way as non-table-valued parameter bound parameters: Each table-valued parameter column can specify its actual data length, SQL_NULL_DATA, or it can specify data at execution via its length/indicator buffer.</span></span> <span data-ttu-id="888d2-146">Les valeurs de colonne de paramètre table peuvent être transmises par des appels répétés à SQLPutData comme d’habitude lorsqu’une valeur de caractère ou binaire doit être passée en plusieurs parties.</span><span class="sxs-lookup"><span data-stu-id="888d2-146">Table-valued parameter column values can be passed by repeated calls to SQLPutData as usual when a character or binary value is to be passed in pieces.</span></span>  
  
 <span data-ttu-id="888d2-147">Une fois toutes les colonnes de paramètre table traitées, le pilote revient au paramètre table pour traiter d'autres lignes de données de paramètre table.</span><span class="sxs-lookup"><span data-stu-id="888d2-147">When all table-valued parameter columns have been processed, the driver returns to the table-valued parameter to process further rows of table-valued parameter data.</span></span> <span data-ttu-id="888d2-148">Par conséquent, pour les paramètres table de données en cours d'exécution, le pilote ne suit pas l'analyse séquentielle habituelle des paramètres liés.</span><span class="sxs-lookup"><span data-stu-id="888d2-148">Therefore, for data-at-execution table-valued parameters, the driver does not follow the usual sequential scan of bound parameters.</span></span> <span data-ttu-id="888d2-149">Un paramètre table lié est interrogé jusqu’à ce que SQLPutData soit appelé avec *StrLen_Or_IndPtr* égal à 0, auquel le pilote ignore les colonnes de paramètre table et passe au paramètre de procédure stockée réel suivant.</span><span class="sxs-lookup"><span data-stu-id="888d2-149">A bound table-valued parameter will be polled until SQLPutData is called with *StrLen_Or_IndPtr* equal to 0, at which time the driver skips table-valued parameter columns and moves to the next actual stored procedure parameter.</span></span>  <span data-ttu-id="888d2-150">Lorsque SQLPutData passe une valeur d’indicateur supérieure ou égale à 1, le pilote traite les lignes et les colonnes de paramètre table de façon séquentielle jusqu’à ce qu’il ait des valeurs pour toutes les lignes et colonnes liées.</span><span class="sxs-lookup"><span data-stu-id="888d2-150">When SQLPutData passes an indicator value greater than or equal to 1, the driver processes table-valued parameter columns and rows sequentially until it has values for all bound rows and columns.</span></span> <span data-ttu-id="888d2-151">Le pilote revient ensuite au paramètre table.</span><span class="sxs-lookup"><span data-stu-id="888d2-151">Then the driver returns to the table-valued parameter.</span></span> <span data-ttu-id="888d2-152">Entre la réception du jeton pour le paramètre table de SQLParamData et l’appel de SQLPutData (hstmt, NULL, n) pour un paramètre table, l’application doit définir des données de colonne constitutives de paramètre table et le contenu de la mémoire tampon d’indicateur pour la ou les lignes suivantes à transmettre au serveur.</span><span class="sxs-lookup"><span data-stu-id="888d2-152">Between receiving the token for the table-valued parameter from SQLParamData and calling SQLPutData(hstmt, NULL, n) for a table-valued parameter, the application must set table-valued parameter constituent column data and indicator buffer contents for the next row or rows to be passed to the server.</span></span>  
  
 <span data-ttu-id="888d2-153">L’exemple de code de ce scénario se trouve dans la routine `demo_variable_TVP_binding` dans [utiliser des paramètres table &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="888d2-153">Sample code for this scenario is in the routine `demo_variable_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-from-the-system-catalog"></a><span data-ttu-id="888d2-154">Récupération des métadonnées de paramètre table du catalogue système</span><span class="sxs-lookup"><span data-stu-id="888d2-154">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
 <span data-ttu-id="888d2-155">Quand une application appelle SQLProcedureColumns pour une procédure qui a des paramètres de paramètre table, DATA_TYPE est retourné comme SQL_SS_TABLE et TYPE_NAME est le nom du type de table pour le paramètre table.</span><span class="sxs-lookup"><span data-stu-id="888d2-155">When an application calls SQLProcedureColumns for a procedure that has table-valued parameter parameters, DATA_TYPE is returned as SQL_SS_TABLE and TYPE_NAME is the name of the table type for the table-valued parameter.</span></span> <span data-ttu-id="888d2-156">Deux colonnes supplémentaires sont ajoutées au jeu de résultats retourné par SQLProcedureColumns : SS_TYPE_CATALOG_NAME retourne le nom du catalogue où le type de table du paramètre table est défini, et SS_TYPE_SCHEMA_NAME retourne le nom du schéma où le type de table du paramètre table a la valeur defined.</span><span class="sxs-lookup"><span data-stu-id="888d2-156">Two additional columns are added to the result set returned by SQLProcedureColumns: SS_TYPE_CATALOG_NAME returns the name of the catalog where the table type of the table-value parameter is defined, and SS_TYPE_SCHEMA_NAME returns the name of the schema where the where the table type of the table-value parameter is defined.</span></span> <span data-ttu-id="888d2-157">Conformément à la spécification ODBC, SS_TYPE_CATALOG_NAME et SS_TYPE_SCHEMA_NAME apparaissent avant toutes les colonnes spécifiques au pilote qui ont été ajoutées dans les versions antérieures de [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] et après toutes les colonnes mandatées par ODBC lui-même.</span><span class="sxs-lookup"><span data-stu-id="888d2-157">In conformance with the ODBC specification, SS_TYPE_CATALOG_NAME and SS_TYPE_SCHEMA_NAME appear before all driver specific columns that were added in previous versions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and after all columns mandated by ODBC itself.</span></span>  
  
 <span data-ttu-id="888d2-158">Les nouvelles colonnes seront remplies à la fois pour les paramètres table, mais aussi pour les paramètres du type CLR défini par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="888d2-158">The new columns will be populated not only for table-valued parameters, but also for CLR user-defined type parameters.</span></span> <span data-ttu-id="888d2-159">Les colonnes de schéma et de catalogue existantes des paramètres définis par l'utilisateur continuent d'être remplies, mais le fait de disposer de colonnes de schéma et de catalogue communes pour les types de données qui en ont besoin simplifie le développement d'applications dans le futur.</span><span class="sxs-lookup"><span data-stu-id="888d2-159">The existing schema and catalog columns of UDT parameters will still be populated, but having common schema and catalog columns for data types that require them will simplify application development in the future.</span></span> <span data-ttu-id="888d2-160">(Notez que les collections de schémas XML sont quelque peu différentes et ne sont pas incluses dans cette modification.)</span><span class="sxs-lookup"><span data-stu-id="888d2-160">(Note that XML schema collections are somewhat different and are not included in this change.)</span></span>  
  
 <span data-ttu-id="888d2-161">Une application utilise les SQLTables pour déterminer les noms des types de table de la même façon que pour les tables persistantes, les tables système et les vues.</span><span class="sxs-lookup"><span data-stu-id="888d2-161">An application uses SQLTables to determine the names of table types the same way it does for persistent tables, system tables, and views.</span></span> <span data-ttu-id="888d2-162">Un nouveau type de table, TABLE TYPE, est introduit pour permettre à une application d'identifier les types de tables associés aux paramètres table.</span><span class="sxs-lookup"><span data-stu-id="888d2-162">A new table type, TABLE TYPE, is introduced to enable an application to identify table types associated with table-valued parameters.</span></span> <span data-ttu-id="888d2-163">Les types de tables et les tables standard utilisent des espaces de noms différents.</span><span class="sxs-lookup"><span data-stu-id="888d2-163">Table types and regular tables use different namespaces.</span></span> <span data-ttu-id="888d2-164">Cela signifie que vous pouvez utiliser le même nom pour un type de table et pour une table réelle.</span><span class="sxs-lookup"><span data-stu-id="888d2-164">This means that you can use the same name for both a table type and an actual table.</span></span> <span data-ttu-id="888d2-165">À cet effet, un nouvel attribut d'instruction, SQL_SOPT_SS_NAME_SCOPE, a été introduit.</span><span class="sxs-lookup"><span data-stu-id="888d2-165">To handle this, a new statement attribute, SQL_SOPT_SS_NAME_SCOPE, has been introduced.</span></span> <span data-ttu-id="888d2-166">Cet attribut spécifie si SQLTables et d’autres fonctions de catalogue qui prennent un nom de table en tant que paramètre doivent interpréter le nom de la table comme le nom d’une table réelle ou le nom d’un type de table.</span><span class="sxs-lookup"><span data-stu-id="888d2-166">This attribute specifies whether SQLTables and other catalog functions that take a table name as a parameter should interpret the table name as the name of an actual table or the name of a table type.</span></span>  
  
 <span data-ttu-id="888d2-167">Une application utilise SQLColumns pour déterminer les colonnes d’un type de table de la même façon que pour les tables persistantes, mais elle doit d’abord définir SQL_SOPT_SS_NAME_SCOPE pour indiquer qu’elle utilise des types de tables plutôt que des tables réelles.</span><span class="sxs-lookup"><span data-stu-id="888d2-167">An application uses SQLColumns to determine the columns for a table type in the same way it does for persistent tables, but must first set SQL_SOPT_SS_NAME_SCOPE to indicate that it is working with table types rather than actual tables.</span></span> <span data-ttu-id="888d2-168">SQLPrimaryKeys peut également être utilisé avec des types de tables, à l’aide de SQL_SOPT_SS_NAME_SCOPE.</span><span class="sxs-lookup"><span data-stu-id="888d2-168">SQLPrimaryKeys can also be used with table types, again using SQL_SOPT_SS_NAME_SCOPE.</span></span>  
  
 <span data-ttu-id="888d2-169">L’exemple de code de ce scénario se trouve dans la routine `demo_metadata_from_catalog_APIs` dans [utiliser des paramètres table &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="888d2-169">Sample code for this scenario is in the routine `demo_metadata_from_catalog_APIs` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-for-a-prepared-statement"></a><span data-ttu-id="888d2-170">Récupération des métadonnées de paramètre table pour une instruction préparée</span><span class="sxs-lookup"><span data-stu-id="888d2-170">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
 <span data-ttu-id="888d2-171">Dans ce scénario, une application utilise SQLNumParameters et SQLDescribeParam pour récupérer les métadonnées des paramètres table.</span><span class="sxs-lookup"><span data-stu-id="888d2-171">In this scenario, an application uses SQLNumParameters and SQLDescribeParam to retrieve metadata for table-valued parameters.</span></span>  
  
 <span data-ttu-id="888d2-172">Le champ IPD SQL_CA_SS_TYPE_NAME est utilisé pour récupérer le nom du type du paramètre table.</span><span class="sxs-lookup"><span data-stu-id="888d2-172">The IPD field SQL_CA_SS_TYPE_NAME is used to retrieve the type name for the table-valued parameter.</span></span> <span data-ttu-id="888d2-173">Les champs IPD SQL_CA_SS_TYPE_SCHEMA_NAME et SQL_CA_SS_TYPE_CATALOG_NAME sont utilisés pour récupérer respectivement son catalogue et son schéma.</span><span class="sxs-lookup"><span data-stu-id="888d2-173">The IPD fields SQL_CA_SS_TYPE_SCHEMA_NAME and SQL_CA_SS_TYPE_CATALOG_NAME are used to retrieve its catalog and schema, respectively.</span></span>  
  
 <span data-ttu-id="888d2-174">Les définitions de types de tables et les paramètres table doivent se trouver dans la même base de données.</span><span class="sxs-lookup"><span data-stu-id="888d2-174">Table type definitions and table-valued parameters must be in the same database.</span></span> <span data-ttu-id="888d2-175">SQLSetDescField signale une erreur si une application définit SQL_CA_SS_TYPE_CATALOG_NAME lors de l’utilisation de paramètres table.</span><span class="sxs-lookup"><span data-stu-id="888d2-175">SQLSetDescField will report an error if an application sets SQL_CA_SS_TYPE_CATALOG_NAME when using table-valued parameters.</span></span>  
  
 <span data-ttu-id="888d2-176">SQL_CA_SS_TYPE_CATALOG_NAME et SQL_CA_SS_TYPE_SCHEMA_NAME peuvent également être utilisés pour récupérer le catalogue et le schéma associés aux paramètres du type CLR défini par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="888d2-176">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME can also be used to retrieve the catalog and schema associated with CLR user-defined type parameters.</span></span> <span data-ttu-id="888d2-177">SQL_CA_SS_TYPE_CATALOG_NAME et SQL_CA_SS_TYPE_SCHEMA_NAME sont des alternatives aux attributs existants de schéma de catalogue spécifiques au type pour les types CLR définis par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="888d2-177">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME are alternatives to the existing type specific catalog schema attributes for CLR UDT types.</span></span>  
  
 <span data-ttu-id="888d2-178">Une application utilise SQLColumns pour récupérer des métadonnées de colonne pour un paramètre table dans ce scénario, car SQLDescribeParam ne retourne pas de métadonnées pour les colonnes d’une colonne de paramètre table.</span><span class="sxs-lookup"><span data-stu-id="888d2-178">An application uses SQLColumns to retrieve column metadata for a table-valued parameter in this scenario, too, because SQLDescribeParam does not return metadata for the columns of a table-valued parameter column.</span></span>  
  
 <span data-ttu-id="888d2-179">Voici un exemple de code pour ce cas d’usage : dans la routine `demo_metadata_from_prepared_statement` , [Utilisez des paramètres table &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="888d2-179">Sample code for this use case is in the routine `demo_metadata_from_prepared_statement` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="888d2-180">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="888d2-180">See Also</span></span>  
 [<span data-ttu-id="888d2-181">Paramètres table &#40;ODBC&#41;</span><span class="sxs-lookup"><span data-stu-id="888d2-181">Table-Valued Parameters &#40;ODBC&#41;</span></span>](table-valued-parameters-odbc.md)  
  
  
