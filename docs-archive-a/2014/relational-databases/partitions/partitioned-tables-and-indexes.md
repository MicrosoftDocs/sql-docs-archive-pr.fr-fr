---
title: Tables et index partitionnés | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- partitioned tables [SQL Server], about partitioned tables
- partitioned indexes [SQL Server], architecture
- partitioned tables [SQL Server], architecture
- partitioned indexes [SQL Server], about partitioned indexes
ms.assetid: cc5bf181-18a0-44d5-8bd7-8060d227c927
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: e8d041abcfe491f311e38bc8dab4be4ea253e37c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87707419"
---
# <a name="partitioned-tables-and-indexes"></a><span data-ttu-id="dc708-102">Partitioned Tables and Indexes</span><span class="sxs-lookup"><span data-stu-id="dc708-102">Partitioned Tables and Indexes</span></span>
  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="dc708-103">prend en charge le partitionnement des tables et des index.</span><span class="sxs-lookup"><span data-stu-id="dc708-103">supports table and index partitioning.</span></span> <span data-ttu-id="dc708-104">Les données des tables et des index partitionnés sont divisées en unités qui peuvent être réparties sur plusieurs groupes de fichiers d'une base de données.</span><span class="sxs-lookup"><span data-stu-id="dc708-104">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database.</span></span> <span data-ttu-id="dc708-105">Les données sont partitionnées horizontalement, de sorte que les groupes de lignes sont mappés à des partitions individuelles.</span><span class="sxs-lookup"><span data-stu-id="dc708-105">The data is partitioned horizontally, so that groups of rows are mapped into individual partitions.</span></span> <span data-ttu-id="dc708-106">Toutes les partitions d'un index ou d'une table unique doivent résider dans la même base de données.</span><span class="sxs-lookup"><span data-stu-id="dc708-106">All partitions of a single index or table must reside in the same database.</span></span> <span data-ttu-id="dc708-107">La table ou l'index est traité en tant qu'entité logique unique lorsque des requêtes ou des mises à jour sont effectuées sur les données.</span><span class="sxs-lookup"><span data-stu-id="dc708-107">The table or index is treated as a single logical entity when queries or updates are performed on the data.</span></span> <span data-ttu-id="dc708-108">Les tables et les index partitionnés ne sont pas disponibles dans toutes les éditions de [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="dc708-108">Partitioned tables and indexes are not available in every edition of [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="dc708-109">Pour obtenir une liste des fonctionnalités prises en charge par les éditions de [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], consultez [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span><span class="sxs-lookup"><span data-stu-id="dc708-109">For a list of features that are supported by the editions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>  
  
> [!IMPORTANT]  
>  [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] <span data-ttu-id="dc708-110">prend en charge jusqu'à 15 000 partitions par défaut.</span><span class="sxs-lookup"><span data-stu-id="dc708-110">supports up to 15,000 partitions by default.</span></span> <span data-ttu-id="dc708-111">Dans les versions antérieures à [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], le nombre de partitions était limité à 1 000 par défaut. Sur les systèmes x86, la création d'une table ou d'un index contenant plus de 1 000 partitions est possible, mais n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="dc708-111">In versions earlier than [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], the number of partitions was limited to 1,000 by default.On x86-based systems, creating a table or index with more than 1000 partitions is possible, but is not supported.</span></span>  
  
## <a name="benefits-of-partitioning"></a><span data-ttu-id="dc708-112">Avantages du partitionnement</span><span class="sxs-lookup"><span data-stu-id="dc708-112">Benefits of Partitioning</span></span>  
 <span data-ttu-id="dc708-113">Le partitionnement des tables ou des index peut offrir les avantages suivants en matière de gestion et de performances.</span><span class="sxs-lookup"><span data-stu-id="dc708-113">Partitioning large tables or indexes can have the following manageability and performance benefits.</span></span>  
  
-   <span data-ttu-id="dc708-114">Vous pouvez créer des sous-ensembles de données et y accéder facilement et efficacement, tout en conservant l'intégrité d'une collection de données.</span><span class="sxs-lookup"><span data-stu-id="dc708-114">You can transfer or access subsets of data quickly and efficiently, while maintaining the integrity of a data collection.</span></span> <span data-ttu-id="dc708-115">Par exemple, une opération telle que le chargement des données d'un système OLTP vers un système OLAP ne prend que quelques secondes au lieu des minutes et des heures qu'elle exige lorsque les données ne sont pas partitionnées.</span><span class="sxs-lookup"><span data-stu-id="dc708-115">For example, an operation such as loading data from an OLTP to an OLAP system takes only seconds, instead of the minutes and hours the operation takes when the data is not partitioned.</span></span>  
  
-   <span data-ttu-id="dc708-116">Vous pouvez effectuer des opérations de maintenance sur une ou plusieurs partitions plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="dc708-116">You can perform maintenance operations on one or more partitions more quickly.</span></span> <span data-ttu-id="dc708-117">Les opérations sont plus efficaces car elles ne ciblent que ces sous-ensembles de données, au lieu de la totalité de la table.</span><span class="sxs-lookup"><span data-stu-id="dc708-117">The operations are more efficient because they target only these data subsets, instead of the whole table.</span></span> <span data-ttu-id="dc708-118">Par exemple, vous pouvez choisir de compresser les données dans une ou plusieurs partitions ou de reconstruire une ou plusieurs partitions d'un index.</span><span class="sxs-lookup"><span data-stu-id="dc708-118">For example, you can choose to compress data in one or more partitions or rebuild one or more partitions of an index.</span></span>  
  
-   <span data-ttu-id="dc708-119">Suivant les types de requêtes fréquemment exécutées et la configuration matérielle, vous pouvez améliorer les performances des requêtes.</span><span class="sxs-lookup"><span data-stu-id="dc708-119">You may improve query performance, based on the types of queries you frequently run and on your hardware configuration.</span></span> <span data-ttu-id="dc708-120">Par exemple, l'optimiseur de requête peut traiter les requêtes d'équijointure entre plusieurs tables partitionnées plus rapidement lorsque les colonnes de partitionnement dans les tables sont identiques, car les partitions elles-mêmes peuvent être jointes.</span><span class="sxs-lookup"><span data-stu-id="dc708-120">For example, the query optimizer can process equi-join queries between two or more partitioned tables faster when the partitioning columns in the tables are the same, because the partitions themselves can be joined.</span></span>  
  
     <span data-ttu-id="dc708-121">Lorsque [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] trie des données pour des opérations d'entrée/sortie, il trie d'abord les données par partition.</span><span class="sxs-lookup"><span data-stu-id="dc708-121">When [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs data sorting for I/O operations, it sorts the data first by partition.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="dc708-122">accède à un lecteur à la fois, ce qui peut réduire les performances.</span><span class="sxs-lookup"><span data-stu-id="dc708-122">accesses one drive at a time, and this might reduce performance.</span></span> <span data-ttu-id="dc708-123">Pour améliorer les performances de tri des données, distribuez les fichiers de données des partitions sur plusieurs disques en définissant un volume RAID.</span><span class="sxs-lookup"><span data-stu-id="dc708-123">To improve data sorting performance, stripe the data files of your partitions across more than one disk by setting up a RAID.</span></span> <span data-ttu-id="dc708-124">Ainsi, bien que [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] trie toujours les données par partition, il peut accéder à tous les lecteurs de chaque partition au même moment.</span><span class="sxs-lookup"><span data-stu-id="dc708-124">In this way, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] still sorts data by partition, it can access all the drives of each partition at the same time.</span></span>  
  
     <span data-ttu-id="dc708-125">De plus, il est possible d'améliorer les performances en activant l'escalade de verrous au niveau de la partition plutôt qu'au niveau de la table entière.</span><span class="sxs-lookup"><span data-stu-id="dc708-125">In addition, you can improve performance by enabling lock escalation at the partition level instead of a whole table.</span></span> <span data-ttu-id="dc708-126">Cela peut réduire les conflits de verrouillage de la table.</span><span class="sxs-lookup"><span data-stu-id="dc708-126">This can reduce lock contention on the table.</span></span>  
  
## <a name="components-and-concepts"></a><span data-ttu-id="dc708-127">Composants et concepts</span><span class="sxs-lookup"><span data-stu-id="dc708-127">Components and Concepts</span></span>  
 <span data-ttu-id="dc708-128">Les termes suivants s'appliquent aux partitionnement de table et d'index.</span><span class="sxs-lookup"><span data-stu-id="dc708-128">The following terms are applicable to table and index partitioning.</span></span>  
  
 <span data-ttu-id="dc708-129">Fonction de partition</span><span class="sxs-lookup"><span data-stu-id="dc708-129">Partition function</span></span>  
 <span data-ttu-id="dc708-130">Objet de base de données qui définit comment les lignes d'une table ou d'un index sont mappées à un ensemble de partitions en fonction des valeurs de certaines colonnes, appelées « colonnes de partitionnement ».</span><span class="sxs-lookup"><span data-stu-id="dc708-130">A database object that defines how the rows of a table or index are mapped to a set of partitions based on the values of certain column, called a partitioning column.</span></span> <span data-ttu-id="dc708-131">Autrement dit, la fonction de partition définit le nombre de partitions qu'aura la table, ainsi que la façon dont les limites des partitions sont définies.</span><span class="sxs-lookup"><span data-stu-id="dc708-131">That is, the partition function defines the number of partitions that the table will have and how the boundaries of the partitions are defined.</span></span> <span data-ttu-id="dc708-132">Prenons l'exemple d'une table qui contient des données de commande client ; vous pouvez partitionner la table en douze partitions (mensuellement) en fonction d'une colonne `datetime`, telle qu'une date de vente.</span><span class="sxs-lookup"><span data-stu-id="dc708-132">For example, given a table that contains sales order data, you may want to partition the table into twelve (monthly) partitions based on a `datetime` column such as a sales date.</span></span>  
  
 <span data-ttu-id="dc708-133">Schéma de partition</span><span class="sxs-lookup"><span data-stu-id="dc708-133">Partition scheme</span></span>  
 <span data-ttu-id="dc708-134">Objet de base de données qui mappe les partitions d'une fonction de partition à un ensemble de groupes de fichiers.</span><span class="sxs-lookup"><span data-stu-id="dc708-134">A database object that maps the partitions of a partition function to a set of filegroups.</span></span> <span data-ttu-id="dc708-135">Le principal motif de placement des partitions sur des groupes de fichiers distincts est la possibilité de réaliser des opérations de sauvegarde indépendantes sur les partitions.</span><span class="sxs-lookup"><span data-stu-id="dc708-135">The primary reason for placing your partitions on separate filegroups is to make sure that you can independently perform backup operations on partitions.</span></span> <span data-ttu-id="dc708-136">En effet, vous pouvez réaliser des sauvegardes sur des groupes de fichiers spécifiques.</span><span class="sxs-lookup"><span data-stu-id="dc708-136">This is because you can perform backups on individual filegroups.</span></span>  
  
 <span data-ttu-id="dc708-137">Colonne de partitionnement</span><span class="sxs-lookup"><span data-stu-id="dc708-137">Partitioning column</span></span>  
 <span data-ttu-id="dc708-138">Colonne d'une table ou d'un index utilisée par une fonction de partition pour partitionner la table ou l'index.</span><span class="sxs-lookup"><span data-stu-id="dc708-138">The column of a table or index that a partition function uses to partition the table or index.</span></span> <span data-ttu-id="dc708-139">Les colonnes calculées qui font partie d'une fonction de partition doivent présenter l'attribut PERSISTED.</span><span class="sxs-lookup"><span data-stu-id="dc708-139">Computed columns that participate in a partition function must be explicitly marked PERSISTED.</span></span> <span data-ttu-id="dc708-140">Tous les types de données autorisés dans les colonnes d'index peuvent être utilisés dans la colonne de partitionnement, sauf `timestamp`.</span><span class="sxs-lookup"><span data-stu-id="dc708-140">All data types that are valid for use as index columns can be used as a partitioning column, except `timestamp`.</span></span> <span data-ttu-id="dc708-141">Les types de données `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)` ou `varbinary(max)` ne peuvent pas être spécifiés.</span><span class="sxs-lookup"><span data-stu-id="dc708-141">The `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types cannot be specified.</span></span> <span data-ttu-id="dc708-142">Le type défini par l’utilisateur CLR (Common Langage Runtime) Microsoft .NET Framework et les colonnes de type de données alias ne peuvent pas être non plus spécifiés.</span><span class="sxs-lookup"><span data-stu-id="dc708-142">Also, Microsoft .NET Framework common language runtime (CLR) user-defined type and alias data type columns cannot be specified.</span></span>  
  
 <span data-ttu-id="dc708-143">Index aligné</span><span class="sxs-lookup"><span data-stu-id="dc708-143">Aligned index</span></span>  
 <span data-ttu-id="dc708-144">Index créé sur le même schéma de partition que la table qui lui correspond.</span><span class="sxs-lookup"><span data-stu-id="dc708-144">An index that is built on the same partition scheme as its corresponding table.</span></span> <span data-ttu-id="dc708-145">Lorsqu'une table et ses index sont alignés, SQL Server peut commuter rapidement et efficacement les partitions tout en préservant leur structure aussi bien dans la table que dans les index.</span><span class="sxs-lookup"><span data-stu-id="dc708-145">When a table and its indexes are in alignment, SQL Server can switch partitions quickly and efficiently while maintaining the partition structure of both the table and its indexes.</span></span> <span data-ttu-id="dc708-146">Un index n'a pas besoin de participer à la même fonction de partition nommée pour être aligné avec sa table de base.</span><span class="sxs-lookup"><span data-stu-id="dc708-146">An index does not have to participate in the same named partition function to be aligned with its base table.</span></span> <span data-ttu-id="dc708-147">Toutefois, la fonction de partition de l'index et celle de la table de base doivent être identique de trois points de vue : 1) les arguments des fonctions de partition ont le même type de données, 2) elles définissent le même nombre de partitions et 3) elles définissent les mêmes valeurs limites pour les partitions.</span><span class="sxs-lookup"><span data-stu-id="dc708-147">However, the partition function of the index and the base table must be essentially the same, in that 1) the arguments of the partition functions have the same data type, 2) they define the same number of partitions, and 3) they define the same boundary values for partitions.</span></span>  
  
 <span data-ttu-id="dc708-148">Index non aligné</span><span class="sxs-lookup"><span data-stu-id="dc708-148">Nonaligned index</span></span>  
 <span data-ttu-id="dc708-149">Index partitionné indépendamment de la table correspondante.</span><span class="sxs-lookup"><span data-stu-id="dc708-149">An index partitioned independently from its corresponding table.</span></span> <span data-ttu-id="dc708-150">Autrement dit, l'index a un schéma de partition différent ou il est placé dans un groupe de fichiers différent de la table de base.</span><span class="sxs-lookup"><span data-stu-id="dc708-150">That is, the index has a different partition scheme or is placed on a separate filegroup from the base table.</span></span> <span data-ttu-id="dc708-151">La conception d'un index partitionné non aligné peut être utile dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="dc708-151">Designing an nonaligned partitioned index can be useful in the following cases:</span></span>  
  
-   <span data-ttu-id="dc708-152">la table de base n'a pas été partitionnée ;</span><span class="sxs-lookup"><span data-stu-id="dc708-152">The base table has not been partitioned.</span></span>  
  
-   <span data-ttu-id="dc708-153">la clé d'index est unique et elle ne doit pas contenir la colonne de partitionnement de la table ;</span><span class="sxs-lookup"><span data-stu-id="dc708-153">The index key is unique and it does not contain the partitioning column of the table.</span></span>  
  
-   <span data-ttu-id="dc708-154">vous souhaitez que la table de base soit impliquée dans des jointures communes à plusieurs tables en utilisant différentes colonnes de jointure.</span><span class="sxs-lookup"><span data-stu-id="dc708-154">You want the base table to participate in collocated joins with more tables using different join columns.</span></span>  
  
 <span data-ttu-id="dc708-155">Élimination de partition</span><span class="sxs-lookup"><span data-stu-id="dc708-155">Partition elimination</span></span>  
 <span data-ttu-id="dc708-156">Processus par lequel l'optimiseur de requête accède uniquement aux partitions pertinentes pour satisfaire les critères de la requête.</span><span class="sxs-lookup"><span data-stu-id="dc708-156">The process by which the query optimizer accesses only the relevant partitions to satisfy the filter criteria of the query.</span></span>  
  
## <a name="performance-guidelines"></a><span data-ttu-id="dc708-157">Recommandations relatives aux performances</span><span class="sxs-lookup"><span data-stu-id="dc708-157">Performance Guidelines</span></span>  
 <span data-ttu-id="dc708-158">La nouvelle limite plus élevée de 15 000 partitions affecte la mémoire, les opérations d'index partitionnés, les commandes DBCC et les requêtes.</span><span class="sxs-lookup"><span data-stu-id="dc708-158">The new, higher limit of 15,000 partitions affects memory, partitioned index operations, DBCC commands, and queries.</span></span> <span data-ttu-id="dc708-159">Cette section décrit les implications en matière de performances de l'augmentation du nombre de partitions au-delà de 1000 et fournit des solutions de contournement si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="dc708-159">This section describes the performance implications of increasing the number of partitions above 1,000 and provides workarounds as needed.</span></span> <span data-ttu-id="dc708-160">La quantité maximale de partitions étant passée à 15 000, vous pouvez stocker des données pendant plus longtemps.</span><span class="sxs-lookup"><span data-stu-id="dc708-160">With the limit on the maximum number of partitions being increased to 15,000, you can store data for a longer time.</span></span> <span data-ttu-id="dc708-161">Toutefois, vous devez conserver les données uniquement pendant la durée nécessaire et obtenir un compromis entre les performances et le nombre de partitions.</span><span class="sxs-lookup"><span data-stu-id="dc708-161">However, you should retain data only for as long as it is needed and maintain a balance between performance and number of partitions.</span></span>  
  
### <a name="memory-usage-and-guidelines"></a><span data-ttu-id="dc708-162">Utilisation de la mémoire et recommandations</span><span class="sxs-lookup"><span data-stu-id="dc708-162">Memory Usage and Guidelines</span></span>  
 <span data-ttu-id="dc708-163">Nous vous recommandons d'utiliser au moins 16 Go de RAM si un grand nombre de partitions sont en cours d'utilisation.</span><span class="sxs-lookup"><span data-stu-id="dc708-163">We recommend that you use at least 16 GB of RAM if a large number of partitions are in use.</span></span> <span data-ttu-id="dc708-164">Si le système n'a pas assez de mémoire, les instructions DML (Data Manipulation Language), les instructions DDL (Data Definition Language) et d'autres opérations peuvent échouer en raison d'une insuffisance de mémoire.</span><span class="sxs-lookup"><span data-stu-id="dc708-164">If the system does not have enough memory, Data Manipulation Language (DML) statements, Data Definition Language (DDL) statements and other operations can fail due to insufficient memory.</span></span> <span data-ttu-id="dc708-165">Les systèmes avec 16 Go de RAM qui exécutent un grand nombre de processus nécessitant beaucoup de mémoire risque de ne pas disposer de suffisamment de mémoire lors des opérations qui s'exécutent sur un grand nombre de partitions.</span><span class="sxs-lookup"><span data-stu-id="dc708-165">Systems with 16 GB of RAM that run many memory-intensive processes may run out of memory on operations that run on a large number of partitions.</span></span> <span data-ttu-id="dc708-166">Par conséquent, plus vous disposez de mémoire au-delà de 16 Go, moins vous risquez de rencontrer des problèmes de performances et de mémoire.</span><span class="sxs-lookup"><span data-stu-id="dc708-166">Therefore, the more memory you have over 16 GB, the less likely you are to encounter performance and memory issues.</span></span>  
  
 <span data-ttu-id="dc708-167">Les limitations de mémoire peuvent affecter les performances de SQL Server ou sa capacité à créer un index partitionné.</span><span class="sxs-lookup"><span data-stu-id="dc708-167">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="dc708-168">C'est le cas notamment lorsque l'index n'est pas aligné avec sa table de base ou son index cluster, si un index cluster a été appliqué à la table.</span><span class="sxs-lookup"><span data-stu-id="dc708-168">This is especially the case when the index is not aligned with its base table or is not aligned with its clustered index, if the table already has a clustered index applied to it.</span></span>  
  
### <a name="partitioned-index-operations"></a><span data-ttu-id="dc708-169">Opérations d'index partitionné</span><span class="sxs-lookup"><span data-stu-id="dc708-169">Partitioned Index Operations</span></span>  
 <span data-ttu-id="dc708-170">Les limitations de mémoire peuvent affecter les performances de SQL Server ou sa capacité à créer un index partitionné.</span><span class="sxs-lookup"><span data-stu-id="dc708-170">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="dc708-171">C'est notamment le cas avec des index non alignés.</span><span class="sxs-lookup"><span data-stu-id="dc708-171">This is especially the case with nonaligned indexes.</span></span> <span data-ttu-id="dc708-172">La création et la reconstruction des index non alignés sur une table contenant plus de 1 000 partitions sont possibles, mais ne sont pas prises en charge.</span><span class="sxs-lookup"><span data-stu-id="dc708-172">Creating and rebuilding nonaligned indexes on a table with more than 1,000 partitions is possible, but is not supported.</span></span> <span data-ttu-id="dc708-173">Ces opérations peuvent entraîner une dégradation des performances ou une consommation de mémoire excessive.</span><span class="sxs-lookup"><span data-stu-id="dc708-173">Doing so may cause degraded performance or excessive memory consumption during these operations.</span></span>  
  
 <span data-ttu-id="dc708-174">La création et la reconstruction d'index alignés peuvent exiger davantage de temps à mesure que le nombre de partitions augmente.</span><span class="sxs-lookup"><span data-stu-id="dc708-174">Creating and rebuilding aligned indexes could take longer to execute as the number of partitions increases.</span></span> <span data-ttu-id="dc708-175">Nous vous recommandons de ne pas exécuter simultanément plusieurs commandes de création et de reconstruction d'index, car vous risquez de rencontrer des problèmes de performances et de mémoire.</span><span class="sxs-lookup"><span data-stu-id="dc708-175">We recommend that you do not run multiple create and rebuild index commands at the same time as you may run into performance and memory issues.</span></span>  
  
 <span data-ttu-id="dc708-176">Lorsque SQL Server effectue un tri pour créer des index partitionnés, il commence par créer une table de tri pour chaque partition.</span><span class="sxs-lookup"><span data-stu-id="dc708-176">When SQL Server performs sorting to build partitioned indexes, it first builds one sort table for each partition.</span></span> <span data-ttu-id="dc708-177">Ensuite, il génère les tables de tri soit dans le groupe de fichiers de chaque partition, soit dans `tempdb`, si l'option d'index SORT_IN_TEMPDB est spécifiée.</span><span class="sxs-lookup"><span data-stu-id="dc708-177">It then builds the sort tables either in the respective filegroup of each partition or in `tempdb`, if the SORT_IN_TEMPDB index option is specified.</span></span> <span data-ttu-id="dc708-178">La création de chaque table de tri nécessite une quantité minimale de mémoire.</span><span class="sxs-lookup"><span data-stu-id="dc708-178">Each sort table requires a minimum amount of memory to build.</span></span> <span data-ttu-id="dc708-179">Lorsque vous créez un index partitionné qui est aligné avec sa table de base, les tables de tri sont créées une par une, ce qui utilise moins de mémoire.</span><span class="sxs-lookup"><span data-stu-id="dc708-179">When you are building a partitioned index that is aligned with its base table, sort tables are built one at a time, using less memory.</span></span> <span data-ttu-id="dc708-180">Toutefois, lorsque vous créez un index partitionné non aligné, les tables de tri sont produites en même temps.</span><span class="sxs-lookup"><span data-stu-id="dc708-180">However, when you are building a nonaligned partitioned index, the sort tables are built at the same time.</span></span> <span data-ttu-id="dc708-181">De ce fait, il doit y avoir assez de mémoire pour gérer ces tri simultanés.</span><span class="sxs-lookup"><span data-stu-id="dc708-181">As a result, there must be sufficient memory to handle these concurrent sorts.</span></span> <span data-ttu-id="dc708-182">Plus il y a de partitions, plus il faut de mémoire.</span><span class="sxs-lookup"><span data-stu-id="dc708-182">The larger the number of partitions, the more memory required.</span></span> <span data-ttu-id="dc708-183">La taille minimale pour chaque table de tri, pour chaque partition, est de 40 pages, à raison de 8 kilo-octets par page.</span><span class="sxs-lookup"><span data-stu-id="dc708-183">The minimum size for each sort table, for each partition, is 40 pages, with 8 kilobytes per page.</span></span> <span data-ttu-id="dc708-184">Par exemple, un index partitionné non aligné avec 100 partitions nécessite une quantité de mémoire suffisante pour trier en série 4 000 (40 \* 100) pages à la fois.</span><span class="sxs-lookup"><span data-stu-id="dc708-184">For example, a nonaligned partitioned index with 100 partitions requires sufficient memory to serially sort 4,000 (40 \* 100) pages at the same time.</span></span> <span data-ttu-id="dc708-185">Si cette mémoire est disponible, l'opération de création réussit, mais les performances risquent d'en pâtir.</span><span class="sxs-lookup"><span data-stu-id="dc708-185">If this memory is available, the build operation will succeed, but performance may suffer.</span></span> <span data-ttu-id="dc708-186">Sinon, la création échoue.</span><span class="sxs-lookup"><span data-stu-id="dc708-186">If this memory is not available, the build operation will fail.</span></span> <span data-ttu-id="dc708-187">À l'inverse, un index partitionné aligné avec 100 partitions n'a besoin que de la mémoire suffisante pour trier 40 pages, parce que les tris ne sont pas effectués en même temps.</span><span class="sxs-lookup"><span data-stu-id="dc708-187">Alternatively, an aligned partitioned index with 100 partitions requires only sufficient memory to sort 40 pages, because the sorts are not performed at the same time.</span></span>  
  
 <span data-ttu-id="dc708-188">Pour les deux types d'index, alignés et non alignés, la mémoire requise peut être beaucoup plus importante si SQL Server applique divers degrés de parallélisme à l'opération de création sur un ordinateur multiprocesseur.</span><span class="sxs-lookup"><span data-stu-id="dc708-188">For both aligned and nonaligned indexes, the memory requirement can be greater if SQL Server is applying degrees of parallelism to the build operation on a multiprocessor computer.</span></span> <span data-ttu-id="dc708-189">En effet, plus il y a de degrés de parallélisme, plus il faut de mémoire.</span><span class="sxs-lookup"><span data-stu-id="dc708-189">This is because the greater the degrees of parallelism, the greater the memory requirement.</span></span> <span data-ttu-id="dc708-190">Par exemple, si SQL Server affecte aux degrés de parallélisme la valeur 4, un index partitionné non aligné avec 100 partitions a besoin d'une quantité de mémoire suffisante pour que quatre processeurs puissent trier 4 000 pages à la fois, soit 16 000 pages.</span><span class="sxs-lookup"><span data-stu-id="dc708-190">For example, if SQL Server sets degrees of parallelism to 4, a nonaligned partitioned index with 100 partitions requires sufficient memory for four processors to sort 4,000 pages at the same time, or 16,000 pages.</span></span> <span data-ttu-id="dc708-191">Si l'index partitionné est aligné, la mémoire requise est moins importante puisqu'il en faut pour quatre processeurs triant 40 pages ou 160 (4 \* 40) pages.</span><span class="sxs-lookup"><span data-stu-id="dc708-191">If the partitioned index is aligned, the memory requirement is reduced to four processors sorting 40 pages, or 160 (4 \* 40) pages.</span></span> <span data-ttu-id="dc708-192">Vous pouvez utiliser l'option d'index MAXDOP pour réduire manuellement les degrés de parallélisme.</span><span class="sxs-lookup"><span data-stu-id="dc708-192">You can use the MAXDOP index option to manually reduce the degrees of parallelism.</span></span>  
  
### <a name="dbcc-commands"></a><span data-ttu-id="dc708-193">Commandes DBCC</span><span class="sxs-lookup"><span data-stu-id="dc708-193">DBCC Commands</span></span>  
 <span data-ttu-id="dc708-194">Avec un plus grand nombre de partitions, l'exécution des commandes DBCC peut exiger davantage de temps à mesure que le nombre de partitions augmente.</span><span class="sxs-lookup"><span data-stu-id="dc708-194">With a larger number of partitions, DBCC commands could take longer to execute as the number of partitions increases.</span></span>  
  
### <a name="queries"></a><span data-ttu-id="dc708-195">Requêtes</span><span class="sxs-lookup"><span data-stu-id="dc708-195">Queries</span></span>  
 <span data-ttu-id="dc708-196">Les requêtes qui utilisent l'élimination de partition peuvent présenter des performances comparables ou meilleures avec un plus grand nombre de partitions.</span><span class="sxs-lookup"><span data-stu-id="dc708-196">Queries that use partition elimination could have comparable or improved performance with larger number of partitions.</span></span> <span data-ttu-id="dc708-197">Les requêtes qui n'utilisent pas l'élimination de partition peuvent être plus longues à mesure que le nombre de partitions augmente.</span><span class="sxs-lookup"><span data-stu-id="dc708-197">Queries that do not use partition elimination could take longer to execute as the number of partitions increases.</span></span>  
  
 <span data-ttu-id="dc708-198">Par exemple, supposons qu'une table a 100 millions de lignes et de colonnes `A`, `B`et `C`.</span><span class="sxs-lookup"><span data-stu-id="dc708-198">For example, assume a table has 100 million rows and columns `A`, `B`, and `C`.</span></span> <span data-ttu-id="dc708-199">Dans le scénario 1, la table est divisée en 1 000 partitions sur la colonne `A`.</span><span class="sxs-lookup"><span data-stu-id="dc708-199">In scenario 1, the table is divided into 1000 partitions on column `A`.</span></span> <span data-ttu-id="dc708-200">Dans le scénario 2, la table est divisée en 10 000 partitions sur la colonne `A`.</span><span class="sxs-lookup"><span data-stu-id="dc708-200">In scenario 2, the table is divided into 10,000 partitions on column `A`.</span></span> <span data-ttu-id="dc708-201">Une requête sur la table qui contient une clause WHERE filtrant sur la colonne `A` effectuera une élimination de partition et analysera une partition.</span><span class="sxs-lookup"><span data-stu-id="dc708-201">A query on the table that has a WHERE clause filtering on column `A` will perform partition elimination and scan one partition.</span></span> <span data-ttu-id="dc708-202">Il se peut que cette même requête s'exécute plus rapidement dans le scénario 2 car il y a moins de lignes à analyser dans une partition.</span><span class="sxs-lookup"><span data-stu-id="dc708-202">That same query may run faster in scenario 2 as there are fewer rows to scan in a partition.</span></span> <span data-ttu-id="dc708-203">Une requête qui contient une clause WHERE filtrant sur la colonne B analyse toutes les partitions.</span><span class="sxs-lookup"><span data-stu-id="dc708-203">A query that has a WHERE clause filtering on column B will scan all partitions.</span></span> <span data-ttu-id="dc708-204">Il se peut que cette requête s'exécute plus rapidement dans le scénario 1 que dans le scénario 2 car il y a moins de partitions à analyser.</span><span class="sxs-lookup"><span data-stu-id="dc708-204">The query may run faster in scenario 1 than in scenario 2 as there are fewer partitions to scan.</span></span>  
  
 <span data-ttu-id="dc708-205">Les requêtes qui utilisent des opérateurs tels que TOP ou MAX/MIN sur des colonnes autres que la colonne de partitionnement peuvent enregistrer une baisse des performances lors du partitionnement, du fait que toutes les partitions doivent être évaluées.</span><span class="sxs-lookup"><span data-stu-id="dc708-205">Queries that use operators such as TOP or MAX/MIN on columns other than the partitioning column may experience reduced performance with partitioning because all partitions must be evaluated.</span></span>  
  
## <a name="behavior-changes-in-statistics-computation-during-partitioned-index-operations"></a><span data-ttu-id="dc708-206">Changements de comportement dans le calcul des statistiques pour les opérations d'index partitionnés</span><span class="sxs-lookup"><span data-stu-id="dc708-206">Behavior Changes in Statistics Computation During Partitioned Index Operations</span></span>  
 <span data-ttu-id="dc708-207">À partir de [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], les statistiques ne sont pas créées en analysant toutes les lignes de la table lorsqu'un index partitionné est créé ou reconstruit.</span><span class="sxs-lookup"><span data-stu-id="dc708-207">Beginning with [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], statistics are not created by scanning all the rows in the table when a partitioned index is created or rebuilt.</span></span> <span data-ttu-id="dc708-208">Au lieu de cela, l'optimiseur de requête utilise l'algorithme d'échantillonnage par défaut pour générer des statistiques.</span><span class="sxs-lookup"><span data-stu-id="dc708-208">Instead, the query optimizer uses the default sampling algorithm to generate statistics.</span></span> <span data-ttu-id="dc708-209">Après la mise à niveau d'une base de données avec des index partitionnés, vous pouvez remarquer une différence dans les données d'histogramme pour ces index.</span><span class="sxs-lookup"><span data-stu-id="dc708-209">After upgrading a database with partitioned indexes, you may notice a difference in the histogram data for these indexes.</span></span> <span data-ttu-id="dc708-210">Cette modification du comportement peut ne pas affecter les performances des requêtes.</span><span class="sxs-lookup"><span data-stu-id="dc708-210">This change in behavior may not affect query performance.</span></span> <span data-ttu-id="dc708-211">Pour obtenir des statistiques sur les index partitionnés en analysant toutes les lignes de la table, utilisez CREATE STATISTICS ou UPDATE STATISTICS avec la clause FULLSCAN.</span><span class="sxs-lookup"><span data-stu-id="dc708-211">To obtain statistics on partitioned indexes by scanning all the rows in the table, use CREATE STATISTICS or UPDATE STATISTICS with the FULLSCAN clause.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="dc708-212">Tâches associées</span><span class="sxs-lookup"><span data-stu-id="dc708-212">Related Tasks</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="dc708-213">**Tâches**</span><span class="sxs-lookup"><span data-stu-id="dc708-213">**Tasks**</span></span>|<span data-ttu-id="dc708-214">**Rubrique**</span><span class="sxs-lookup"><span data-stu-id="dc708-214">**Topic**</span></span>|  
|<span data-ttu-id="dc708-215">Décrit comment créer des fonctions de partition et des schémas de partition et les appliquer ensuite à une table ou à un index.</span><span class="sxs-lookup"><span data-stu-id="dc708-215">Describes how to create partition functions and partition schemes and then apply these to a table and index.</span></span>|[<span data-ttu-id="dc708-216">Créer des tables et des index partitionnés</span><span class="sxs-lookup"><span data-stu-id="dc708-216">Create Partitioned Tables and Indexes</span></span>](create-partitioned-tables-and-indexes.md)|  
|||  
  
## <a name="related-content"></a><span data-ttu-id="dc708-217">Contenu associé</span><span class="sxs-lookup"><span data-stu-id="dc708-217">Related Content</span></span>  
 <span data-ttu-id="dc708-218">Les livres blancs suivants relatifs aux stratégies et implémentations de tables et index partitionnés pourront se révéler utiles.</span><span class="sxs-lookup"><span data-stu-id="dc708-218">You may find the following white papers on partitioned table and index strategies and implementations useful.</span></span>  
  
-   <span data-ttu-id="dc708-219">[Stratégies de tables et d’index partitionnés avec SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span><span class="sxs-lookup"><span data-stu-id="dc708-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span></span>  
  
-   <span data-ttu-id="dc708-220">[Comment implémenter une fenêtre glissante automatique](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span><span class="sxs-lookup"><span data-stu-id="dc708-220">[How to Implement an Automatic Sliding Window](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span></span>  
  
-   [<span data-ttu-id="dc708-221">Chargement en masse dans une table partitionnée</span><span class="sxs-lookup"><span data-stu-id="dc708-221">Bulk Loading into a Partitioned Table</span></span>](https://msdn.microsoft.com/library/cc966380.aspx)  
  
-   [<span data-ttu-id="dc708-222">Améliorations du traitement des requêtes sur les tables et les index partitionnés</span><span class="sxs-lookup"><span data-stu-id="dc708-222">Query Processing Enhancements on Partitioned Tables and Indexes</span></span>](https://msdn.microsoft.com/library/ms345599.aspx)  
  
-   [<span data-ttu-id="dc708-223">10 meilleures pratiques pour générer un entrepôt de données relationnelles à grande échelle</span><span class="sxs-lookup"><span data-stu-id="dc708-223">Top 10 Best Practices for Building a Large Scale Relational Data Warehouse</span></span>](http://sqlcat.com/top10lists/archive/2008/02/06/top-10-best-practices-for-building-a-large-scale-relational-data-warehouse.aspx)  
  
  
