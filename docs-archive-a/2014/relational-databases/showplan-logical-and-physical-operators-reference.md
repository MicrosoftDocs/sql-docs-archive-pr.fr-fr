---
title: Guide de référence des opérateurs Showplan logiques et physiques
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87702600"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Guide de référence des opérateurs Showplan logiques et physiques
  Les opérateurs décrivent comment [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] exécute une requête ou une instruction DML (Data Manipulation Language). L'optimiseur de requête utilise des opérateurs pour construire un plan de requête qui crée le résultat spécifié dans la requête ou pour exécuter l'opération spécifiée dans l'instruction DML. Le plan de requête est une arborescence composée d'opérateurs physiques. Vous pouvez afficher le plan de requête à l'aide des instructions SET SHOWPLAN, des options plan d'exécution graphique dans [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]ou des classes d'événements Showplan de SQL Server Profiler.  
  
 Les opérateurs sont classés en opérateurs logiques et physiques.  
  
 **Opérateurs logiques**  
 Les opérateurs logiques décrivent l'opération algébrique relationnelle utilisée pour traiter une instruction. En d'autres termes, les opérateurs logiques décrivent de manière conceptuelle les opérations à exécuter.  
  
 **Opérateurs physiques**  
 Les opérateurs physiques mettent en œuvre l'opération décrite par des opérateurs logiques. Chaque opérateur physique désigne un objet ou une routine chargée d'effectuer une opération. Par exemple, certains opérateurs physiques permettent d'accéder à des colonnes ou des lignes à partir d'une table, d'un index ou d'une vue. D'autres opérateurs physiques exécutent d'autres opérations telles que des calculs, des agrégations, des contrôles de l'intégrité des données vérifie ou des jointures. Des coûts sont associés aux opérateurs physiques.  
  
 Les opérateurs physiques s'initialisent, collectent des données et se ferment. En particulier, l'opérateur physique peut répondre aux trois méthodes d'appel suivantes :  
  
-   **Init()** : La méthode **Init()** fait qu’un opérateur physique s’initialise lui-même et configure les structures de données nécessaires. Il arrive que l’opérateur physique reçoive beaucoup d’appels **Init()** , bien qu’en général il n’en reçoive qu’un.  
  
-   **GetNext()** : La méthode **GetNext()** fait que l’opérateur physique récupère la première ligne de données ou la suivante. L’opérateur physique peut recevoir zéro ou de nombreux appels **GetNext()** .  
  
-   **Close()**  : La méthode **Close()** fait que l’opérateur physique effectue certaines opérations de nettoyage et se ferme elle-même. Un opérateur physique reçoit un seul appel **Close()** .  
  
 La méthode **GetNext()** renvoie une ligne de données, et le nombre d’appels qu’elle reçoit s’affiche sous **ActualRows** dans le résultat Showplan produit au moyen de SET STATISTICS PROFILE ON ou SET STATISTICS XML ON. Pour plus d’informations sur ces options SET, consultez [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) et [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 Les compteurs **ActualRebinds** et **ActualRewinds** qui s’affichent dans le résultat de Showplan indiquent le nombre de fois que la méthode **Init()** est appelée. Sauf si un opérateur se trouve sur le côté intérieur d'une jointure de boucles, **ActualRebinds** est égal à un et **ActualRewinds** est égal à zéro. Si un opérateur se trouve sur le côté intérieur d'une jointure de boucles, le nombre total de reliaisons et de rembobinages doit être égal au nombre de ligne traitées sur le côté extérieur de la jointure. Une reliaison signifie qu'un ou plusieurs des paramètres corrélés de la jointure ont changé, et que le côté intérieur doit être réévalué. Un rembobinage signifie qu'aucun des paramètres corrélés n'a changé, et que l'ancien jeu de résultats interne peut être réutilisé.  
  
 **ActualRebinds** et **ActualRewinds** sont présents dans le résultat de Showplan XML produit en utilisant SET STATISTICS XML ON. Ils sont uniquement remplis pour les opérateurs de **mise en file d’attente d’index non cluster**,, de mise en file d’attente du nombre de `Remote Query` **lignes**, de `Sort` **table spool**et de **fonction table** . **ActualRebinds** et **ActualRewinds** peuvent également être remplis pour les `Assert` opérateurs de **filtre** et lorsque l’attribut **StartupExpression** a la valeur true.  
  
 Lorsque **ActualRebinds** et **ActualRewinds** sont présents dans un Showplan XML, ils sont comparables à **EstimateRebinds** et **EstimateRewinds**. S’ils sont absents, le nombre estimé de lignes (**EstimateRows**) est comparable au nombre réel de lignes (**ActualRows**). Sachez que le résultat du Showplan graphique réel affiche des zéros pour les reliaisons réelles et les rembobinages réels lorsqu'ils sont absents.  
  
 Un compteur apparenté, **ActualEndOfScans**, est disponible uniquement si le résultat de Showplan est produit au moyen de SET STATISTICS XML ON. Chaque fois qu'un opérateur physique atteint la fin de son flux de données, le compteur est incrémenté de un. Un opérateur physique peut atteindre la fin de son flux de données zéro, une ou de nombreuses fois. Comme pour les reliaisons et les rembobinages, le nombre de fins d'analyses ne peut être supérieur à un que si l'opérateur se situe sur le côté intérieur d'une jointure de boucles. Le nombre de fins d'analyses doit être inférieur ou égal au nombre total des reliaisons et des rembobinages.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mappage d'opérateurs physiques et logiques  
 L'optimiseur de requête crée un plan de requête sous forme d'arborescence d'opérateurs logiques. Après avoir créé le plan, l'optimiseur de requête choisit l'opérateur physique le plus efficace pour chaque opérateur logique. L'optimiseur de requête utilise une approche basée sur les coûts pour déterminer l'opérateur physique qui mettra en œuvre un opérateur logique.  
  
 Généralement, une opération logique peut être mise en œuvre par plusieurs opérateurs physiques. Toutefois, en de rares occasions, un opérateur physique peut également mettre en œuvre plusieurs opérations logiques.  
  
## <a name="operator-descriptions"></a>Description des opérateurs  
 Cette section contient la description des opérateurs logiques et physiques.  
  
|Icône du plan d'exécution graphique|Opérateur Showplan|Description|  
|-----------------------------------|-----------------------|-----------------|  
|None|`Aggregate`|L'opérateur `Aggregate` calcule une expression contenant MIN, MAX, SUM, COUNT ou AVG. L'opérateur `Aggregate` peut être un opérateur logique ou physique.|  
|![Icône d’opérateur d’expression arithmétique](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Icône d’opérateur d’expression arithmétique")|`Arithmetic Expression`|L'opérateur `Arithmetic Expression` calcule une nouvelle valeur à partir de valeurs existantes dans une ligne. `Arithmetic Expression` n'est pas utilisé dans [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icône d’opérateur d’assertion](../../2014/database-engine/media/assert-32x.gif "Icône d’opérateur d’assertion")|`Assert`|L'opérateur `Assert` vérifie une condition. Par exemple, il valide l'intégrité référentielle ou garantit qu'une sous-requête scalaire retourne une ligne. Pour chaque ligne d’entrée, l' `Assert` opérateur évalue l’expression dans la `Argument` colonne du plan d’exécution. Si cette expression a pour résultat NULL, l'opérateur `Assert` passe la ligne et la requête d'exécution se poursuit. Si cette expression a pour résultat une valeur non NULL, l'erreur correspondante est levée. L'opérateur `Assert` est un opérateur physique.|  
|![Icône d’élément d’attribution de langue](../../2014/database-engine/media/assign-32.gif "Icône d’élément d’attribution de langue")|`Assign`|L'opérateur `Assign` assigne la valeur d'une expression ou une constante à une variable. `Assign` est un élément de langage.|  
|None|`Asnyc Concat`|L'opérateur `Asnyc Concat` sert uniquement dans le cadre des requêtes distantes (requêtes distribuées). Elle a *n* enfants et un nœud parent. En règle générale, certains des enfants sont des ordinateurs distants qui participent à une requête distribuée. `Asnyc Concat` émet des appels `open()` à tous les enfants simultanément et applique ensuite une bitmap à chacun d'eux. Pour chaque bit à 1, `Async Concat` envoie à la demande les lignes obtenues au nœud parent.|  
|![Icône d’opérateur bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icône d’opérateur bitmap")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]utilise l' `Bitmap` opérateur pour implémenter le filtrage Bitmap dans les plans de requête parallèles. Le filtrage Bitmap accélère l’exécution des requêtes en éliminant les lignes contenant des valeurs de clés qui ne peuvent pas produire d’enregistrements de jointure avant de passer des lignes à un autre opérateur tel que l' `Parallelism` opérateur. Un filtre Bitmap utilise une représentation compacte d'un ensemble de valeurs d'une table dans une partie de l'arborescence de l'opérateur pour filtrer les lignes d'une seconde table dans une autre partie de l'arborescence. Avec la suppression des lignes inutiles tôt dans la requête, les opérateurs suivants ont moins de lignes à traiter et les performances globales de la requête sont améliorées. L'optimiseur détermine quand un filtre Bitmap est suffisamment sélectif pour être utile et dans quels opérateurs le filtre doit être appliqué. `Bitmap` est un opérateur physique.|  
|![Icône d’opérateur bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icône d’opérateur bitmap")|`Bitmap Create`|L'opérateur `Bitmap Create` apparaît dans la sortie de plan d'exécution de requêtes où les bitmaps sont construites. `Bitmap Create` est un opérateur logique.|  
|![Icône d’opérateur Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icône d’opérateur Bookmark Lookup")|`Bookmark Lookup`|L'opérateur `Bookmark Lookup` utilise un signet (ID de ligne ou clé de clustering) pour rechercher la ligne correspondante dans la table ou l'index cluster. La `Argument` colonne contient l’étiquette de signet utilisée pour rechercher la ligne dans la table ou l’index cluster. La `Argument` colonne contient également le nom de la table ou de l’index cluster dans lequel la ligne est recherchée. Si la clause WITH prefetch apparaît dans la `Argument` colonne, le processeur de requêtes a déterminé qu’il est optimal d’utiliser la prérécupération asynchrone (lecture anticipée) lors de la recherche de signets dans la table ou l’index cluster.<br /><br /> `Bookmark Lookup` n'est pas utilisé dans [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. À la place, `Clustered Index Seek` et `RID Lookup` fournissent des fonctionnalités de recherche de signet. L'opérateur `Key Lookup` fournit également ces fonctionnalités.|  
|None|`Branch Repartition`|Dans un plan de requête parallèle, il existe parfois des régions conceptuelles composées d'itérateurs. Tous les itérateurs de ces régions peuvent être exécutés par des threads parallèles. Les régions elles-mêmes doivent être exécutées séquentiellement. Certains itérateurs `Parallelism` d'une région distincte sont appelés `Branch Repartition`. L'itérateur `Parallelism` situé à la limite de deux régions de ce type est appelé `Segment Repartition`. `Branch Repartition` et `Segment Repartition` sont des opérateurs logiques.|  
|None|`Broadcast`|`Broadcast`possède un nœud enfant et *n* nœuds parents. `Broadcast` envoie ses lignes d'entrée à plusieurs consommateurs à la demande. Chaque consommateur obtient toutes les lignes. Par exemple, si tous les consommateurs se trouvent des côtés construction d'une jointure de hachage, *n* copies des tables de hachage sont générées.|  
|![Icône d’opérateur de hachage de génération](../../2014/database-engine/media/build-hash.gif "Icône d’opérateur de hachage de génération")|`Build Hash`|Indique la création d'une table de hachage de lot pour un index columnstore optimisé en mémoire xVelocity.|  
|None|`Cache`|`Cache`est une version spécialisée de l’opérateur **spool** . Il ne stocke qu'une seule ligne de données. `Cache` est un opérateur logique. `Cache` n'est pas utilisé dans [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icône d’opérateur de suppression d’index cluster](../../2014/database-engine/media/clustered-index-delete-32x.gif "Icône d’opérateur de suppression d’index cluster")|`Clustered Index Delete`|L'opérateur `Clustered Index Delete` supprime des lignes de l'index cluster spécifié dans la colonne Argument du plan d'exécution de requête. Si un prédicat WHERE:() figure dans la colonne Argument, seules les lignes répondant au prédicat sont supprimées.`Clustered Index Delete`  est un opérateur physique.|  
|![Icône d’opérateur d’insertion d’index cluster](../../2014/database-engine/media/clustered-index-insert-32x.gif "Icône d’opérateur d’insertion d’index cluster")|`Clustered Index Insert`|L'opérateur `Clustered Index Insert` Showplan insère des lignes de son entrée dans l'index cluster spécifié dans la colonne Argument. Cette colonne contient également un prédicat SET:(), qui indique la valeur à laquelle chaque colonne est définie. Si n' `Clustered Index Insert` a pas d’enfant pour les valeurs Insert, la ligne insérée est extraite de l' `Insert` opérateur lui-même.`Clustered Index Insert`  est un opérateur physique.|  
|![Opérateur de fusion d’index cluster](../../2014/database-engine/media/clustered-index-merge-32x.gif "Opérateur de fusion d’index cluster")|**Clustered Index Merge**|L'opérateur **Clustered Index Merge** applique un flux de données de fusion à un index cluster. L’opérateur supprime, met à jour ou insère des lignes de l’index cluster spécifié dans la `Argument` colonne de l’opérateur. L’opération réelle effectuée dépend de la valeur d’exécution de la colonne d' **action** spécifiée dans la `Argument` colonne de l’opérateur. **Clustered Index Merge** est un opérateur physique.|  
|![Icône d’opérateur d’analyse d’index cluster](../../2014/database-engine/media/clustered-index-scan-32x.gif "Icône d’opérateur d’analyse d’index cluster")|`Clustered Index Scan`|L'opérateur `Clustered Index Scan` analyse l'index cluster spécifié dans la colonne Argument du plan d'exécution de requête. Lorsqu'un prédicat facultatif WHERE:() y figure, seules les lignes répondant au prédicat sont retournées. Si la colonne Argument contient la clause ORDERED, cela signifie que le processeur de requêtes a demandé le renvoi des sorties de lignes dans l'ordre dans lequel l'index cluster les a triées. Si la clause ORDERED n'y figure pas, le moteur de stockage effectue la recherche dans l'index de façon optimale, sans nécessairement trier la sortie. `Clustered Index Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur de recherche d’index cluster](../../2014/database-engine/media/clustered-index-seek-32x.gif "Icône d’opérateur de recherche d’index cluster")|`Clustered Index Seek`|L'opérateur `Clustered Index Seek` utilise la capacité de recherche dans les index pour extraire des lignes d'un index cluster. La `Argument` colonne contient le nom de l’index cluster utilisé et le PRÉDICAT Seek :(). Le moteur de stockage utilise l'index pour ne traiter que les lignes répondant à ce prédicat SEEK:(). Il peut également inclure un prédicat WHERE: () dans lequel le moteur de stockage est évalué par rapport à toutes les lignes répondant au prédicat SEEK:(), mais ceci est facultatif et ne fait pas appel aux index pour exécuter ce processus.<br /><br /> Si la `Argument` colonne contient la clause ORDERED, le processeur de requêtes a déterminé que les lignes doivent être retournées dans l’ordre dans lequel l’index cluster les a triées. Si la clause ORDERED n'y figure pas, le moteur de stockage effectue la recherche dans l'index de façon optimale, sans nécessairement trier la sortie. Autoriser la sortie à conserver son classement peut s'avérer moins efficace que la production d'une sortie non triée. Lorsque le mot clé LOOKUP apparaît, une recherche de signet est alors exécutée. Dans [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] et les versions ultérieures, l' `Key Lookup` opérateur fournit la fonctionnalité de recherche de signet. `Clustered Index Seek` est un opérateur logique et physique.|  
|![Icône d’opérateur de mise à jour d’index cluster](../../2014/database-engine/media/clustered-index-update-32x.gif "Icône d’opérateur de mise à jour d’index cluster")|`Clustered Index Update`|L' `Clustered Index Update` opérateur met à jour les lignes d’entrée dans l’index cluster spécifié dans la `Argument` colonne. Si un prédicat WHERE :() est présent, seules les lignes répondant à ce prédicat sont mises à jour. Si un prédicat SET:() est présent, chaque colonne mise à jour prend cette valeur. Si un prédicat DEFINE:() est présent, il établit la liste des valeurs définies par cet opérateur. Ces valeurs peuvent être référencées dans la clause SET ou ailleurs dans cet opérateur, et ailleurs dans cette requête. `Clustered Index Update` est un opérateur logique et physique.|  
|![Icône d’opérateur Collapse](../../2014/database-engine/media/collapse-32x.gif "Icône d’opérateur de réduction")|`Collapse`|L'opérateur `Collapse` permet d'optimiser le traitement de mise à jour des données. Lorsqu'une mise à jour est effectuée, elle peut être divisée (par l'opérateur `Split`) en opérations de suppression puis d'insertion des données. La `Argument` colonne contient une clause Group by :() qui spécifie une liste de colonnes clés. Si le processeur de requêtes rencontre des lignes adjacentes d'instructions de suppression puis d'insertion des mêmes valeurs de clé, il regroupe alors ces opérations en une seule et même opération de mise à jour pour gagner en efficacité. `Collapse` est un opérateur logique et physique.|  
|![Analyse d'index columnstore](../../2014/database-engine/media/columnstoreindexscan.gif "Analyse d'index columnstore")|`Columnstore Index Scan`|L' `Columnstore Index Scan` opérateur analyse l’index ColumnStore spécifié dans la `Argument` colonne du plan d’exécution de la requête.|  
|![Icône d’opérateur Compute Scalar](../../2014/database-engine/media/compute-scalar-32x.gif "Icône d’opérateur Compute Scalar")|`Compute Scalar`|L' `Compute Scalar` opérateur évalue une expression pour produire une valeur scalaire calculée. Celle-ci peut ensuite être retournée à l'utilisateur, référencée n'importe où dans la requête, ou les deux. Les deux sont utilisés par exemple dans un prédicat de filtre ou de jointure. `Compute Scalar` est un opérateur logique et physique.<br /><br /> `Compute Scalar`les opérateurs qui apparaissent dans plans générés par SET STATISTICs XML peuvent ne pas contenir l' `RunTimeInformation` élément. Dans les plans d'exécution graphiques, **Actual Rows**, **Actual Rebinds**et **Actual Rewinds** peuvent être absents de la fenêtre **Propriétés** lorsque l'option **Inclure le plan d'exécution réel** est sélectionnée dans [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Si cela se produit, cela signifie que, même si ces opérateurs ont été utilisés dans le plan de requête compilé, leur travail a été exécuté par d'autres opérateurs dans le plan de requête à l'exécution. Notez également que le nombre d'exécutions figurant dans le résultat du plan d'exécution produit par SET STATISTICS PROFILE équivaut à la somme des reliaisons et des rembobinages des plans d'exécution produits par SET STATISTICS XML.|  
|![Icône d’opérateur de concaténation](../../2014/database-engine/media/concatenation-32x.gif "Icône d’opérateur de concaténation")|**Concatenation**|L'opérateur **Concatenation** analyse plusieurs entrées et renvoie chaque ligne analysée. L'opérateur**Concatenation** sert généralement à implémenter la construction [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL. L'opérateur physique **Concatenation** a deux entrées ou plus, et une sortie. L'opérateur Concatenation copie des lignes depuis le premier flux d'entrée vers le flux de sortie, puis répète l'opération pour chacun des autres flux d'entrée. **Concatenation** est un opérateur logique et physique.|  
|![Icône d’opérateur Constant Scan](../../2014/database-engine/media/constant-scan-32x.gif "Icône d’opérateur Constant Scan")|`Constant Scan`|L' `Constant Scan` opérateur introduit une ou plusieurs lignes constantes dans une requête. Un `Compute Scalar` opérateur est souvent utilisé après un `Constant Scan` pour ajouter des colonnes à une ligne produite par l' `Constant Scan` opérateur.|  
|![Icône d’élément de langue Convert (moteur de base de données)](../../2014/database-engine/media/convert-32x.gif "Icône d’élément de langue Convert (moteur de base de données)")|`Convert`|L'opérateur `Convert` convertit une expression d'un type de données scalaire en un autre. `Convert` est un élément de langage.|  
|None|`Cross Join`|L'opérateur `Cross Join` relie chaque ligne de la première entrée (du haut) à chaque ligne de la deuxième entrée (du bas). `Cross Join` est un opérateur logique.|  
|![Icône d’opérateur fourre-tout de curseurs](../../2014/database-engine/media/cursor-catch-all.gif "Icône d’opérateur fourre-tout de curseurs")|`catchall`|L'icône catchall s'affiche lorsque la logique qui produit des plans de requête graphiques ne parvient pas à trouver une icône adaptée pour l'itérateur. Cette icône n'indique pas nécessairement une condition d'erreur. Il existe trois types d'icône catchcall : bleu (pour les itérateurs), orange (pour les curseurs) et vert (pour les éléments du langage [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|None|**Curseur**|Les opérateurs physiques et logiques de **curseur** sont utilisés pour décrire le mode d'exécution d'une requête ou d'une mise à jour impliquant des opérations de curseur. Les opérateurs physiques décrivent l'algorithme d'implémentation physique utilisé pour traiter le curseur, par exemple, à l'aide d'un curseur contrôlé par clés. Chaque étape de l'exécution d'un curseur implique un opérateur physique. Les opérateurs logiques décrivent une propriété du curseur, par exemple, le curseur est en lecture seule.<br /><br /> Les opérateurs logiques incluent Asynchronous, Optimistic, Primary, Read Only, Scroll Locks et Secondary et Synchronous.<br /><br /> Les opérateurs physiques incluent Dynamic, Fetch Query, Keyset, Population Query, Refresh Query et Snapshot.|  
|![Icône d’élément de langage Declare](../../2014/database-engine/media/declare-32x.gif "Icône d’élément de langage Declare")|`Declare`|L' `Declare` opérateur alloue une variable locale dans le plan de requête. `Declare` est un élément de langage.|  
|![Icône d’opérateur de suppression (moteur de base de données)](../../2014/database-engine/media/delete-32x.gif "Icône d’opérateur de suppression (moteur de base de données)")|`Delete`|L' `Delete` opérateur supprime des lignes d’objet qui satisfont le prédicat facultatif dans la `Argument` colonne.|  
|![Icône d’opérateur de suppression d’analyse](../../2014/database-engine/media/delete-scan-32x.gif "Icône d’opérateur de suppression d’analyse")|`Deleted Scan`|L'opérateur `Deleted Scan` analyse la table supprimée dans un déclencheur.|  
|None|`Distinct`|L'opérateur `Distinct` supprime les doublons d'un ensemble de lignes ou d'une collection de valeurs. `Distinct` est un opérateur logique.|  
|None|`Distinct Sort`|L' `Distinct Sort` opérateur logique analyse l’entrée, en supprimant les doublons et en triant les colonnes spécifiées dans le PRÉDICAT distinct order by :() de la `Argument` colonne. `Distinct Sort` est un opérateur logique.|  
|![Icône d’opérateur de parallélisme Distribute Streams](../../2014/database-engine/media/parallelism-distribute-stream.gif "Icône d’opérateur de parallélisme Distribute Streams")|**Distribute Streams**|L'opérateur **Distribute Streams** est utilisé uniquement dans les plans de requête parallèles. L'opérateur **Distribute Streams** ne mobilise qu'un seul flux d'entrée d'enregistrements et produit plusieurs flux de sortie. Le contenu et le format des enregistrements ne sont pas modifiés. Chaque enregistrement provenant du flux d'entrée apparaît dans l'un des flux de sortie. Cet opérateur conserve automatiquement l'ordre relatif des enregistrements d'entrée dans les flux de sortie. Habituellement, le hachage est utilisé pour définir à quel flux de sortie appartient un enregistrement d'entrée particulier.<br /><br /> Si la sortie est partitionnée, la `Argument` colonne contient un PRÉDICAT partition Columns :() et les colonnes de partitionnement. **Distribute Streams** est un opérateur logique.|  
|![Icône d’opérateur de curseur dynamique](../../2014/database-engine/media/dynamic-32x.gif "Icône d’opérateur de curseur dynamique")|`Dynamic`|L'opérateur `Dynamic` utilise un curseur capable de détecter toutes les modifications effectuées par d'autres utilisateurs.|  
|![Icône d’opérateur de mise en attente](../../2014/database-engine/media/spool-32x.gif "Icône d’opérateur de mise en attente")|**Eager Spool**|L’opérateur de **spool hâtif** prend la totalité de l’entrée, en stockant chaque ligne dans un objet temporaire masqué stocké dans la `tempdb` base de données. Si l’opérateur est rembobiné (par exemple, par un `Nested Loops` opérateur) mais qu’aucune reliaison n’est nécessaire, les données mises en file d’attente sont utilisées au lieu de réanalyser l’entrée. Si une nouvelle liaison est nécessaire, les données mises en attente sont supprimées et l'objet en attente est recréé par une nouvelle analyse de l'entrée (liée une nouvelle fois). L'opérateur **Eager Spool** crée le fichier spouleur avec « avidité » : lorsque l'opérateur parent du spool demande la première ligne, l'opérateur spool consomme toutes les lignes de son opérateur d'entrée et les stocke dans le spool. **Eager Spool** est un opérateur logique.|  
|![Icône d’opérateur de curseur Fetch Query](../../2014/database-engine/media/fetch-query-32x.gif "Icône d’opérateur de curseur Fetch Query")|`Fetch Query`|L'opérateur `Fetch Query` extrait des lignes lorsqu'une extraction est émise à l'aide d'un curseur.|  
|![Icône d’opérateur de filtre (moteur de base de données)](../../2014/database-engine/media/filter-32x.gif "Icône d’opérateur de filtre (moteur de base de données)")|**Filter**|L’opérateur **Filter** analyse l’entrée en ne retournant que les lignes répondant à l’expression de filtre (prédicat) qui apparaît dans la `Argument` colonne.|  
|None|`Flow Distinct`|L'opérateur logique `Flow Distinct` analyse les entrées en éliminant les doublons. Tandis que l' `Distinct` opérateur consomme toutes les entrées avant de produire une sortie, l’opérateur **FlowDistinct** retourne chaque ligne telle qu’elle est obtenue à partir de l’entrée (sauf si cette ligne est un doublon, auquel cas elle est ignorée).|  
|None|`Full Outer Join`|L'opérateur logique `Full Outer Join` retourne chaque ligne répondant au prédicat de jointure de la première entrée (du haut) joint à chaque ligne de la seconde entrée (du bas). Il renvoie également les lignes de :<br /><br /> -la première entrée qui ne possède pas de correspondance dans la seconde entrée ;<br /><br /> -la seconde entrée sans correspondance dans la première entrée.<br /><br /> <br /><br /> L'entrée qui ne contient pas les valeurs correspondantes est retournée sous forme de valeur NULL. `Full Outer Join` est un opérateur logique.|  
|![Icône d’opérateur de parallélisme Gather Streams](../../2014/database-engine/media/parallelism-32x.gif "Icône d’opérateur de parallélisme Gather Streams")|**Gather Streams**|L'opérateur **Gather Streams** n'est utilisé que dans les plans de requête parallèle. **Cet opérateur** mobilise plusieurs flux d'entrée et ne produit qu'un flux de sortie d'enregistrements en associant les flux d'entrée. Le contenu et le format des enregistrements ne sont pas modifiés. Si l'opérateur conserve l'ordre, tous les flux d'entrée doivent alors être classés. Si la sortie est triée, la `Argument` colonne contient un PRÉDICAT order by :() et les noms des colonnes classées. **Gather Streams** est un opérateur logique.|  
|![Icône d’opérateur Hash Match](../../2014/database-engine/media/hash-match-32x.gif "Icône d’opérateur Hash Match")|`Hash Match`|L'opérateur `Hash Match` crée une table de hachage en calculant une valeur de hachage pour chaque ligne à partir de son entrée de génération. Un prédicat HASH :() avec une liste de colonnes utilisées pour créer une valeur de hachage apparaît dans la `Argument` colonne. Ensuite, il calcule, pour chaque ligne de sondage (le cas échéant), une valeur de hachage en utilisant la même fonction de hachage, et consulte la table de hachage pour trouver les correspondances. Si un prédicat résiduel est présent (identifié par un prédicat résiduel résiduel dans la `Argument` colonne), ce prédicat doit également être respecté pour que les lignes soient considérées comme une correspondance. Son comportement dépend de l'opération logique exécutée :<br /><br /> Pour toutes les jointures, utilisez la première entrée (du haut) pour créer la table de hachage et la seconde entrée (du bas) pour tester cette table. Les correspondances (ou non correspondances) de sortie sont dictées par le type de jointure. Si plusieurs jointures utilisent la même colonne de jointure, ces opérations sont regroupées dans une équipe de hachage.<br /><br /> Pour les opérateurs distincts ou d'agrégation, utilisez l'entrée pour créer la table de hachage (en supprimant les doublons et en calculant les expressions d'agrégation). Une fois la table de hachage construite, parcourez-la et sortez toutes les entrées.<br /><br /> Pour l'opérateur UNION, utilisez la première entrée pour créer la table de hachage (en supprimant les doublons). Utilisez la deuxième entrée (qui ne doit pas comporter de doublons) pour analyser la table de hachage, retourner toutes les lignes sans correspondance, puis analyser la table de hachage et retourner toutes les entrées.<br /><br /> <br /><br /> `Hash Match` est un opérateur physique.|  
|![Icône d’élément de langage If](../../2014/database-engine/media/if-32x.gif "Icône d’élément de langage If")|`If`|L'opérateur `If` effectue un traitement conditionnel basé sur une expression. `If` est un élément de langage.|  
|None|`Inner Join`|L'opérateur logique `Inner Join` retourne chaque ligne répondant à la jointure de la première entrée (du haut) et de la seconde entrée (du bas).|  
|![Icône d’opérateur d’insertion (moteur de base de données)](../../2014/database-engine/media/insert-32x.gif "Icône d’opérateur d’insertion (moteur de base de données)")|`Insert`|L' `Insert` opérateur logique insère chaque ligne de son entrée dans l’objet spécifié dans la `Argument` colonne. L'opérateur physique est l'opérateur `Table Insert`, `Index Insert` ou `Clustered Index Insert`.|  
|![Icône d’opérateur Inserted Scan](../../2014/database-engine/media/inserted-scan-32x.gif "Icône d’opérateur Inserted Scan")|**Inserted Scan**|L'opérateur **Inserted Scan** analyse la table **insérée** . **Inserted Scan** est un opérateur logique et physique.|  
|![Icône d’élément de langage intrinsèque](../../2014/database-engine/media/intrinsic-32x.gif "Icône d’élément de langage intrinsèque")|`Intrinsic`|L'opérateur `Intrinsic` appelle une fonction [!INCLUDE[tsql](../includes/tsql-md.md)] interne. `Intrinsic` est un élément de langage.|  
|![Icône d’opérateur fourre-tout d’itérateurs](../../2014/database-engine/media/iterator-catch-all.gif "Icône d’opérateur fourre-tout d’itérateurs")|`Iterator`|L'icône catchall `Iterator` s'affiche lorsque la logique qui produit des plans de requête graphiques ne parvient pas à trouver une icône adaptée pour l'itérateur. Cette icône n'indique pas nécessairement une condition d'erreur. Il existe trois types d'icône catchcall : bleu (pour les itérateurs), orange (pour les curseurs) et vert (pour les constructions de langage [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icône d’opérateur Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icône d’opérateur Bookmark Lookup")|`Key Lookup`|L' `Key Lookup` opérateur est une recherche de signet sur une table avec un index cluster. La `Argument` colonne contient le nom de l’index cluster et la clé de clustering utilisée pour rechercher la ligne dans l’index cluster. `Key Lookup`est toujours accompagné par un `Nested Loops` opérateur. Si la clause WITH prefetch apparaît dans la `Argument` colonne, le processeur de requêtes a déterminé qu’il est optimal d’utiliser la prérécupération asynchrone (lecture anticipée) lors de la recherche de signets dans l’index cluster.<br /><br /> L’utilisation d’un `Key Lookup` opérateur dans un plan de requête indique que la requête peut bénéficier du réglage des performances. Par exemple, l'ajout d'un index explicatif peut améliorer les performances des requêtes.|  
|![Icône d’opérateur du curseur Keyset](../../2014/database-engine/media/keyset-32x.gif "Icône d’opérateur du curseur Keyset")|`Keyset`|L'opérateur `Keyset` utilise un curseur qui peut détecter les mises à jour, mais pas les insertions effectuées par d'autres.|  
|![Icône Fourre-tout d’élément de langue](../../2014/database-engine/media/language-construct-catch-all.gif "Icône Fourre-tout d’élément de langue")|`Language Element`|L'icône catchall `Language Element` s'affiche lorsque la logique qui produit des plans de requête graphiques ne parvient pas à trouver une icône adaptée pour l'itérateur. Cette icône n'indique pas nécessairement une condition d'erreur. Il existe trois types d'icône catchcall : bleu (pour les itérateurs), orange (pour les curseurs) et vert (pour les constructions de langage [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icône d’opérateur de mise en attente](../../2014/database-engine/media/spool-32x.gif "Icône d’opérateur de mise en attente")|**Lazy Spool**|L’opérateur logique **Lazy spool** stocke chaque ligne de son entrée dans un objet temporaire masqué stocké dans la `tempdb` base de données. Si l’opérateur est rembobiné (par exemple, par un `Nested Loops` opérateur) mais qu’aucune reliaison n’est nécessaire, les données mises en file d’attente sont utilisées au lieu de réanalyser l’entrée. Si une nouvelle liaison est nécessaire, les données mises en attente sont supprimées et l'objet en attente est recréé par une nouvelle analyse de l'entrée (liée une nouvelle fois). L'opérateur **Lazy Spool** crée son fichier d'attente de manière « économique » : chaque fois que l'opérateur parent du fichier d'attente demande une ligne, l'opérateur en attente obtient une ligne de son opérateur d'entrée et la stocke dans le fichier d'attente, au lieu de consommer toutes les lignes simultanément. Lazy Spool est un opérateur logique.|  
|None|`Left Anti Semi Join`|L'opérateur `Left Anti Semi Join` retourne chaque ligne de la première entrée (du haut) lorsqu'il n'y a aucune ligne correspondante dans la seconde entrée (du bas). S’il n’existe aucun prédicat de jointure dans la `Argument` colonne, chaque ligne est une ligne correspondante. `Left Anti Semi Join` est un opérateur logique.|  
|None|`Left Outer Join`|L'opérateur logique `Left Outer Join` renvoie chaque ligne répondant à la jointure de la première entrée (du haut) et de la seconde entrée (du bas). Il renvoie également toute ligne de la première entrée n'ayant pas de ligne en correspondance dans la seconde entrée. Les lignes sans correspondance dans la seconde entrée sont retournées sous forme de valeurs NULL. S’il n’existe aucun prédicat de jointure dans la `Argument` colonne, chaque ligne est une ligne correspondante. `Left Outer Join` est un opérateur logique.|  
|None|`Left Semi Join`|L'opérateur `Left Semi Join` retourne chaque ligne de la première entrée (du haut) lorsqu'il y a une ligne correspondante dans la seconde entrée (du bas). S’il n’existe aucun prédicat de jointure dans la `Argument` colonne, chaque ligne est une ligne correspondante. `Left Semi Join` est un opérateur logique.|  
|![Icône d’opérateur Log Row Scan](../../2014/database-engine/media/log-row-scan-32x.gif "Icône d’opérateur Log Row Scan")|`Log Row Scan`|L'opérateur `Log Row Scan` analyse le journal des transactions. `Log Row Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur Merge Interval](../../2014/database-engine/media/merge-interval-32x.gif "Icône d’opérateur Merge Interval")|`Merge Interval`|L'opérateur `Merge Interval` fusionne plusieurs intervalles (susceptibles de se chevaucher) pour produire des intervalles minimaux qui ne se chevauchent pas, intervalles qui seront ensuite utilisés pour rechercher des entrées d'index. Cet opérateur apparaît généralement au-dessus d’un ou plusieurs opérateurs `Compute Scalar` sur des `Constant Scan` opérateurs, qui créent les intervalles (représentés sous forme de colonnes dans une ligne) que cet opérateur fusionne. `Merge Interval` est un opérateur logique et physique.|  
|![Icône d’opérateur Merge Join](../../2014/database-engine/media/merge-join-32x.gif "Icône d’opérateur Merge Join")|**Merge Join**|L'opérateur **Merge Join** exécute les opérations logiques suivantes : inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join et union.<br /><br /> Dans la `Argument` colonne, l’opérateur de **jointure de fusion** contient un prédicat Merge :() si l’opération exécute une jointure un-à-plusieurs, ou un PRÉDICAT de fusion plusieurs-à-plusieurs si l’opération exécute une jointure plusieurs-à-plusieurs. La `Argument` colonne comprend également une liste de colonnes séparées par des virgules, utilisées pour effectuer l’opération. L'opérateur **Merge Join** nécessite deux entrées triées dans leurs colonnes respectives, peut-être par l'insertion d'opérations de tri explicites dans le plan de requête. L'opérateur Merge join est particulièrement efficace si le tri explicite n'est pas nécessaire, par exemple s'il existe un index B-tree approprié dans la base de données ou si l'ordre de tri peut être exploité pour plusieurs opérations, telles que jointure de fusion et regroupement par cumuls. **Merge Join** est un opérateur physique.|  
|![Icône d’opérateur de boucles imbriquées](../../2014/database-engine/media/nested-loops-32x.gif "Icône d’opérateur de boucles imbriquées")|`Nested Loops`|L'opérateur `Nested Loops` réalise les opérations logiques Inner Join, Left Outer Join, Left Semi Join et Left Anti Semi Join. Les jointures de boucles imbriquées effectuent une recherche sur la table interne pour chaque ligne de la table externe, généralement en utilisant un index. Le processeur de requêtes décide, sur la base des coûts anticipés, de trier ou non l’entrée externe pour améliorer la localisation des recherches dans l’index de l’entrée interne. Toutes les lignes qui répondent au prédicat (facultatif) dans la `Argument` colonne sont retournées selon le cas, en fonction de l’opération logique en cours d’exécution. `Nested Loops` est un opérateur physique.|  
|![Icône d’opérateur de suppression d’index non cluster](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Icône d’opérateur de suppression d’index non cluster")|`Nonclustered Index Delete`|L' `Nonclustered Index Delete` opérateur supprime les lignes d’entrée de l’index non-cluster spécifié dans la `Argument` colonne. `Nonclustered Index Delete` est un opérateur physique.|  
|![Icône d’opérateur d’insertion d’index non cluster](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Icône d’opérateur d’insertion d’index non cluster")|`Index Insert`|L' `Index Insert` opérateur insère les lignes de son entrée dans l’index non-cluster spécifié dans la `Argument` colonne. La colonne `Argument` contient également un prédicat SET:(), qui indique la valeur sur laquelle chaque colonne est définie. `Index Insert` est un opérateur physique.|  
|![Icône d’opérateur d’analyse d’index non cluster](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Icône d’opérateur d’analyse d’index non cluster")|`Index Scan`|L' `Index Scan` opérateur récupère toutes les lignes de l’index non-cluster spécifié dans la `Argument` colonne. Si un prédicat WHERE :() facultatif figure dans la `Argument` colonne, seules les lignes répondant au prédicat sont retournées. `Index Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur de recherche d’index non cluster](../../2014/database-engine/media/index-seek-32x.gif "Icône d’opérateur de recherche d’index non cluster")|`Index Seek`|L'opérateur `Index Seek` utilise la capacité de recherche dans les index pour extraire des lignes d'un index non-cluster. La `Argument` colonne contient le nom de l’index non-cluster utilisé. Il contient également le prédicat SEEK:(). Le moteur de stockage utilise l'index pour ne traiter que les lignes répondant au prédicat SEEK:(). Il peut éventuellement inclure un prédicat WHERE:() dans lequel le moteur de stockage est évalué par rapport à toutes les lignes répondant au prédicat SEEK:() ; il ne fait pas appel aux index pour exécuter ce processus. Si la `Argument` colonne contient la clause ORDERED, le processeur de requêtes a déterminé que les lignes doivent être retournées dans l’ordre dans lequel l’index non-cluster les a triées. Si la clause ORDERED n'apparaît pas, le moteur de stockage recherche dans l'index de façon optimale (sans garantie de tri de la sortie). Autoriser la sortie à conserver son ordre peut s'avérer moins efficace que la production d'une sortie non triée. `Index Seek` est un opérateur logique et physique.|  
|![Icône d’opérateur de spool d’index non cluster](../../2014/database-engine/media/index-spool-32x.gif "Icône d’opérateur de spool d’index non cluster")|**Index spool**|L’opérateur physique **index spool** contient un prédicat SEEK :() dans la `Argument` colonne. L’opérateur **index spool** analyse ses lignes d’entrée, en plaçant une copie de chaque ligne dans un fichier d’attente caché (stocké dans la `tempdb` base de données et existant uniquement pendant la durée de vie de la requête), et génère un index non-cluster sur les lignes. Ceci vous permet d'utiliser les capacités de recherche des index afin de ne sortir que les lignes répondant au prédicat SEEK:(). Si l’opérateur est rembobiné (par exemple, par un `Nested Loops` opérateur) mais qu’aucune reliaison n’est nécessaire, les données mises en file d’attente sont utilisées au lieu de réanalyser l’entrée.|  
|![Icône d’opérateur de mise à jour d’index non cluster](../../2014/database-engine/media/nonclust-index-update-32x.gif "Icône d’opérateur de mise à jour d’index non cluster")|`Nonclustered Index Update`|L' `Nonclustered Index Update` opérateur physique met à jour les lignes de son entrée dans l’index non-cluster spécifié dans la `Argument` colonne. Si un prédicat SET:() est présent, chaque colonne mise à jour prend cette valeur. `Nonclustered Index Update` est un opérateur physique.|  
|![Icône d’opérateur d’insertion d’index en ligne](../../2014/database-engine/media/online-index-32x.gif "Icône d’opérateur d’insertion d’index en ligne")|**Online Index Insert**|L'opérateur physique **Online Index Insert** indique qu'une opération de création, modification ou suppression d'index est effectuée en ligne. Autrement dit, les données de la table sous-jacente restent disponibles aux utilisateurs pendant l'opération d'index.|  
|None|`Parallelism`|L' `Parallelism` opérateur effectue les opérations logiques de distribution de flux, de collecte de flux et de repartitionnement. Les `Argument` colonnes peuvent contenir un PRÉDICAT partition Columns :() avec une liste séparée par des virgules des colonnes partitionnées. Les `Argument` colonnes peuvent également contenir un PRÉDICAT order by :(), qui répertorie les colonnes pour conserver l’ordre de tri lors du partitionnement. `Parallelism` est un opérateur physique.<br /><br /> Remarque : si une requête a été compilée en tant que requête parallèle, mais qu’au moment de l’exécution elle est exécutée en tant que requête en série, la sortie Showplan générée par SET STATISTICs XML ou à l’aide de l’option **inclure le plan d’exécution réel** dans [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] ne contient pas l' `RunTimeInformation` élément pour l' `Parallelism` opérateur. Dans SET STATISTICs PROFILe output, le nombre réel de lignes et le nombre réel d’exécutions afficheront des zéros pour l' `Parallelism` opérateur. Lorsque l’une ou l’autre condition se produit, cela signifie que l' `Parallelism` opérateur n’a été utilisé que lors de la compilation de la requête et non dans le plan de requête au moment de l’exécution. Notez que certaines fois, les plans de requête parallèles sont exécutés séquentiellement si le serveur doit faire face à des charges concurrentes élevées.|  
|![Icône d’opérateur Parameter Table Scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "Icône d’opérateur Parameter Table Scan")|`Parameter Table Scan`|L'opérateur `Parameter Table Scan` analyse une table qui agit comme paramètre dans la requête en cours. Généralement, cet opérateur est utilisé dans une procédure stockée pour les requêtes INSERT. `Parameter Table Scan` est un opérateur logique et physique.|  
|None|**Partial Aggregate**|**Partial Aggregate** est utilisé dans des plans parallèles. Il applique une fonction d'agrégation à autant de lignes d'entrée que possible, afin que l'écriture sur le disque (appelé « débordement ») ne soit pas nécessaire. `Hash Match`est le seul opérateur physique (itérateur) qui implémente l’agrégation de partition. **Partial Aggregate** est un opérateur logique.|  
|![Icône d’opérateur de curseur Population Query](../../2014/database-engine/media/poulation-query-32x.gif "Icône d’opérateur de curseur Population Query")|`Population Query`|L'opérateur `Population Query` permet de renseigner la table de travail d'un curseur lorsque le curseur est ouvert.|  
|![Icône d’opérateur de curseur Refresh Query](../../2014/database-engine/media/refresh-query-32x.gif "Icône d’opérateur de curseur Refresh Query")|`Refresh Query`|L'opérateur `Refresh Query` extrait les données courantes des lignes du tampon d'extraction.|  
|![Icône d’opérateur Remote Delete](../../2014/database-engine/media/remote-delete-32x.gif "Icône d’opérateur Remote Delete")|`Remote Delete`|L'opérateur `Remote Delete` supprime les lignes d'entrée d'un objet distant. `Remote Delete` est un opérateur logique et physique.|  
|![Opérateur Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-scan-32x.gif "opérateur Showplan Remote Index Seek")|**Remote Index Scan**|L’opérateur **Remote Index Scan** analyse l’index distant spécifié dans la colonne Argument. **Remote Index Scan** est un opérateur logique et physique.|  
|![Opérateur Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-seek-32x.gif "opérateur Showplan Remote Index Seek")|**Remote Index Seek**|L'opérateur **Remote Index Seek** utilise les capacités de recherche d'un objet d'index distant pour extraire des lignes. La `Argument` colonne contient le nom de l’index distant utilisé et le PRÉDICAT Seek :(). **Remote Index Seek** est un opérateur physique logique.|  
|![Icône d’opérateur Remote Insert](../../2014/database-engine/media/remote-insert-32x.gif "Icône d’opérateur Remote Insert")|**Remote Insert**|L'opérateur **Remote Insert** insère des lignes d'entrée dans un objet distant. **Remote Insert** est un opérateur logique et physique.|  
|![Icône d’opérateur Remote Query](../../2014/database-engine/media/remote-query-32x.gif "Icône d’opérateur Remote Query")|`Remote Query`|L'opérateur `Remote Query` soumet une requête à une source distante. Le texte de la requête envoyée au serveur distant apparaît dans la `Argument` colonne. `Remote Query` est un opérateur logique et physique.|  
|![Icône d’opérateur Remote Scan](../../2014/database-engine/media/remote-scan-32x.gif "Icône d’opérateur Remote Scan")|`Remote Scan`|L'opérateur `Remote Scan` analyse un objet distant. Le nom de l’objet distant apparaît dans la `Argument` colonne. `Remote Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur Remote Update](../../2014/database-engine/media/remote-update-32x.gif "Icône d’opérateur Remote Update")|`Remote Update`|L'opérateur `Remote Update` met à jour les lignes d'entrée dans un objet distant. `Remote Update` est un opérateur logique et physique.|  
|![Icône d’opérateur de parallélisme Repartition Streams](../../2014/database-engine/media/parallelism-repartition-stream.gif "Icône d’opérateur de parallélisme Repartition Streams")|**Repartition Streams**|L'opérateur **Repartition Streams** consomme plusieurs flux et produit plusieurs flux d'enregistrements. Le contenu et le format des enregistrements ne sont pas modifiés. Si l'optimiseur de requête utilise un filtre bitmap, le nombre de lignes dans le flux de sortie est réduit. Chaque enregistrement d'un flux d'entrée est placé dans un flux de sortie. Si l'opérateur conserve l'ordre de tri, tous les flux d'entrée seront classés et fusionnés en plusieurs flux de sortie triés. Si la sortie est partitionnée, la `Argument` colonne contient un PRÉDICAT partition Columns :() et les colonnes de partitionnement. Si la sortie est triée, la `Argument` colonne contient un PRÉDICAT order by :() et les colonnes classées. **Repartition Streams** est un opérateur logique. Cet opérateur n'est utilisé que dans les plans de requête en parallèle.|  
|![Icône d’élément de langage Result](../../2014/database-engine/media/result-32x.gif "Icône d’élément de langage Result")|`Result`|L'opérateur `Result` contient les données retournées à la fin d'un plan de requête. Il représente en général l'élément racine d'un plan d'exécution de requêtes. `Result` est un élément de langage.|  
|![Icône d’opérateur RID Lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Icône d’opérateur RID Lookup")|`RID Lookup`|`RID Lookup` est une recherche de signet sur un segment utilisant un identificateur de ligne fourni (RID, Row Identifier). La `Argument` colonne contient l’étiquette de signet utilisée pour rechercher la ligne dans la table et le nom de la table dans laquelle la ligne est recherchée. `RID Lookup` est toujours accompagné par un opérateur NESTED LOOP JOIN. `RID Lookup` est un opérateur physique. Pour plus d'informations sur les recherches de signets, consultez «[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)» (en anglais) sur le blog MSDN SQL Server.|  
|None|`Right Anti Semi Join`|L'opérateur `Right Anti Semi Join` sort chaque ligne de la seconde entrée (en bas) lorsqu'il n'existe pas de ligne correspondante dans la première entrée (en haut). Une ligne correspondante est définie comme une ligne répondant au prédicat de la `Argument` colonne (si aucun prédicat n’existe, chaque ligne est une ligne correspondante). `Right Anti Semi Join` est un opérateur logique.|  
|None|`Right Outer Join`|L'opérateur `Right Outer Join` retourne chaque ligne répondant à la condition de jointure de la seconde entrée (du bas) avec chaque ligne correspondante dans la première entrée (du haut). Il retourne également toutes les lignes de la seconde entrée qui n'ont pas de lignes correspondantes dans la première entrée, reliées par la valeur NULL. S’il n’existe aucun prédicat de jointure dans la `Argument` colonne, chaque ligne est une ligne correspondante. `Right Outer Join` est un opérateur logique.|  
|None|`Right Semi Join`|L'opérateur `Right Semi Join` renvoie chaque ligne de la seconde entrée (du bas) s'il n'y a pas de ligne correspondante dans la première entrée (du haut). S’il n’existe aucun prédicat de jointure dans la `Argument` colonne, chaque ligne est une ligne correspondante. `Right Semi Join` est un opérateur logique.|  
|![Icône d’opérateur Row Count Spool](../../2014/database-engine/media/remote-count-spool-32x.gif "Icône d’opérateur Row Count Spool")|**Row Count Spool**|L'opérateur **Row Count Spool** analyse l'entrée en comptant le nombre de lignes présentes et en retournant ce même nombre de lignes exemptes de données. Cet opérateur est utilisé lorsqu'il est plus important de vérifier l'existence des lignes que les données qu'elles contiennent. Par exemple, si un `Nested Loops` opérateur effectue une opération semi-jointure gauche et que le prédicat de jointure s’applique à l’entrée interne, un spool de nombre de lignes peut être placé en haut de l’entrée interne de l' `Nested Loops` opérateur. L' `Nested Loops` opérateur peut ensuite déterminer le nombre de lignes sorties par le spool du nombre de lignes (car les données réelles du côté interne ne sont pas nécessaires) pour déterminer s’il faut retourner la ligne externe. **Row Count Spool** est un opérateur physique.|  
|![Icône d’opérateur Segment](../../2014/database-engine/media/segment-32x.gif "Icône d’opérateur Segment")|**Segment**|**Segment** est un opérateur logique et physique. Il divise le jeu d'entrée en segments en fonction de la valeur d'une ou plusieurs colonnes. Ces colonnes apparaissent en tant qu'arguments dans l'opérateur **Segment** . L'opérateur génère ensuite un segment à la fois.|  
|None|`Segment Repartition`|Dans un plan de requête parallèle, il existe parfois des régions conceptuelles composées d'itérateurs. Tous les itérateurs de ces régions peuvent être exécutés par des threads parallèles. Les régions elles-mêmes doivent être exécutées séquentiellement. Certains itérateurs `Parallelism` d'une région distincte sont appelés `Branch Repartition`. L'itérateur `Parallelism` situé à la limite de deux régions de ce type est appelé `Segment Repartition`. `Branch Repartition` et `Segment Repartition` sont des opérateurs logiques.|  
|![Icône d’opérateur de séquence](../../2014/database-engine/media/sequence-32x.gif "Icône d’opérateur de séquence")|`Sequence`|L'opérateur `Sequence` gère des plans de mise à jour étendus. Il exécute, sur le plan fonctionnel, chaque entrée en séquence (de haut en bas). Chaque entrée est généralement une mise à jour d'un objet différent. Il ne retourne que les lignes provenant de sa dernière entrée (du bas). `Sequence` est un opérateur logique et physique.|  
|![Icône d’opérateur de projet de séquence](../../2014/database-engine/media/sequence-project-32x.gif "Icône d’opérateur de projet de séquence")|`Sequence Project`|L'opérateur `Sequence Project` ajoute des colonnes pour effectuer des calculs sur un jeu ordonné. Il divise le jeu d'entrée en segments en fonction de la valeur d'une ou plusieurs colonnes. L'opérateur génère ensuite un segment à la fois. Ces colonnes s'affichent en tant qu'arguments dans l'opérateur `Sequence Project`. `Sequence Project` est un opérateur logique et physique.|  
|![Icône d’opérateur du curseur d’instantané](../../2014/database-engine/media/snapshot-32x.gif "Icône d’opérateur du curseur d’instantané")|**Instantané**|L'opérateur **Snapshot** crée un curseur qui ne voit pas les modifications apportées par les autres.|  
|![Icône d’opérateur de tri](../../2014/database-engine/media/sort-32x.gif "Icône d’opérateur de tri")|`Sort`|L' `Sort` opérateur trie toutes les lignes entrantes. La `Argument` colonne contient un PRÉDICAT distinct order by :() si les doublons sont supprimés par cette opération, ou un PRÉDICAT order by :() avec une liste séparée par des virgules des colonnes en cours de tri. Les colonnes comportent le préfixe ASC si elles sont triées dans l'ordre ascendant, ou DESC si elles sont triées dans l'ordre descendant. `Sort` est un opérateur logique et physique.|  
|![Icône d’opérateur de fractionnement](../../2014/database-engine/media/split-32x.gif "Icône d’opérateur de fractionnement")|`Split`|L' `Split` opérateur est utilisé pour optimiser le traitement des mises à jour. Il divise chaque opération de mise à jour en opérations DELETE et INSERT. `Split` est un opérateur logique et physique.|  
|![Icône d’opérateur de mise en attente](../../2014/database-engine/media/spool-32x.gif "Icône d’opérateur de mise en attente")|**Spool**|L’opérateur **spool** enregistre un résultat de requête intermédiaire dans la `tempdb` base de données.|  
|![Icône d’opérateur Stream Aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "Icône d’opérateur Stream Aggregate")|`Stream Aggregate`|L'opérateur `Stream Aggregate` effectue un regroupement d'après une ou plusieurs colonnes et calcule une ou plusieurs expressions d'agrégation retournées par la requête. La sortie de cet opérateur peut être référencée par des opérateurs ultérieurs dans la requête, retournés au client, ou les deux. L'opérateur `Stream Aggregate` exige que l'entrée suive l'ordre des colonnes dans ses groupes. L'optimiseur utilise un opérateur `Sort` avant cet opérateur si les données ne sont pas déjà triées en raison d'un opérateur `Sort` précédent ou d'une recherche ou d'une analyse d'index triée. Dans l’instruction SHOWPLAN_ALL ou le plan d’exécution graphique dans [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] , les colonnes du PRÉDICAT Group by sont répertoriées dans la `Argument` colonne, et les expressions d’agrégation sont répertoriées dans la colonne **valeurs définies** . `Stream Aggregate` est un opérateur physique.|  
|![Icône d’opérateur Switch](../../2014/database-engine/media/switch-32x.gif "Icône d’opérateur Switch")|**Switch**|**Switch** est un type particulier d'itérateur de concaténation qui a *n* entrées. Une expression est associée à chaque opérateur **Switch** . Selon la valeur renvoyée par l’expression (entre 0 et *n*-1), **Switch** copie le flux d’entrée approprié dans le flux de sortie. L'une des utilisations de **Switch** consiste à implémenter des plans de requête impliquant des curseurs à avance rapide avec certains opérateurs tels que l'opérateur **TOP** . **Switch** est un opérateur logique et physique.|  
|![Icône d’opérateur Table Delete](../../2014/database-engine/media/table-delete-32x.gif "Icône d’opérateur Table Delete")|`Table Delete`|L' `Table Delete` opérateur physique supprime les lignes de la table spécifiée dans la `Argument` colonne du plan d’exécution de la requête.|  
|![Icône d’opérateur Table Insert](../../2014/database-engine/media/table-insert-32x.gif "Icône d’opérateur Table Insert")|`Table Insert`|L' `Table Insert` opérateur insère les lignes de son entrée dans la table spécifiée dans la `Argument` colonne du plan d’exécution de la requête. La colonne `Argument` contient également un prédicat SET:(), qui indique la valeur sur laquelle chaque colonne est définie. Si `Table Insert` ne possède pas d'enfant pour les valeurs insert, la ligne insérée est extraite de l'opérateur Insert lui-même. `Table Insert` est un opérateur physique.|  
|![Opérateur Table Merge](../../2014/database-engine/media/table-merge-32x.gif "Opérateur Table Merge")|**Table Merge**|L'opérateur **Table Merge** applique un flux de données de fusion à un tas. L’opérateur supprime, met à jour ou insère des lignes dans la table spécifiée dans la `Argument` colonne de l’opérateur. L’opération réelle effectuée dépend de la valeur d’exécution de la colonne d' **action** spécifiée dans la `Argument` colonne de l’opérateur. **Table Merge** est un opérateur physique.|  
|![Icône d’opérateur Table Scan](../../2014/database-engine/media/table-scan-32x.gif "Icône d’opérateur Table Scan")|`Table Scan`|L' `Table Scan` opérateur récupère toutes les lignes de la table spécifiée dans la `Argument` colonne du plan d’exécution de la requête. Si un prédicat WHERE :() apparaît dans la `Argument` colonne, seules les lignes répondant au prédicat sont retournées. `Table Scan` est un opérateur logique et physique.|  
|![Icône d’opérateur Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icône d’opérateur Table Spool")|**Table Spool**|L'opérateur **Table Spool** analyse l'entrée et place une copie de chaque ligne dans une table d'attente cachée, qui est stockée dans la base de données [tempdb](../relational-databases/databases/tempdb-database.md) et qui n'existe que le temps de la requête. Si l’opérateur est rembobiné (par exemple, par un `Nested Loops` opérateur) mais qu’aucune reliaison n’est nécessaire, les données mises en file d’attente sont utilisées au lieu de réanalyser l’entrée. **Table Spool** est un opérateur physique.|  
|![Icône d’opérateur Table Update](../../2014/database-engine/media/table-update-32x.gif "Icône d’opérateur Table Update")|`Table Update`|L' `Table Update` opérateur physique met à jour les lignes d’entrée dans la table spécifiée dans la `Argument` colonne du plan d’exécution de la requête. Le prédicat SET:() détermine la valeur de chaque colonne mise à jour. Ces valeurs peuvent être référencées dans la clause SET ou ailleurs dans cet opérateur et ailleurs dans cette requête.|  
|![Icône d’opérateur de fonction table](../../2014/database-engine/media/table-valued-function-32x.gif "Icône d’opérateur de fonction table")|**Table-valued Function**|L’opérateur **Table-valued Function** évalue une fonction table ( [!INCLUDE[tsql](../includes/tsql-md.md)] ou CLR) et stocke les lignes obtenues dans la base de données [tempdb](../relational-databases/databases/tempdb-database.md) . Lorsque les itérateurs parents demandent les lignes, la **fonction table** retourne les lignes de `tempdb` .<br /><br /> Les requêtes avec des appels à des fonctions table génèrent des plans de requêtes avec l’itérateur **Table-valued Function** . La**fonction table** peut être évaluée avec différentes valeurs de paramètres :<br /><br /> **Lecteur XML de fonctions table** entre un BLOB XML en guise de paramètre et produit un ensemble de lignes représentant des nœuds XML dans l’ordre des documents XML. D'autres paramètres d'entrée peuvent limiter les nœuds XML renvoyés à un sous-ensemble d'un document XML.<br /><br /> **Lecteur XML de fonctions table avec filtre XPath** est un type spécial de **Fonction table de lecteur XML** qui limite la sortie aux nœuds XML qui satisfont à une expression XPath.<br /><br /> <br /><br /> **Table-valued Function** est un opérateur logique et physique.|  
|![Icône d’opérateur Top](../../2014/database-engine/media/top-32x.gif "Icône d’opérateur Top")|**Top**|L'opérateur **Top** analyse l'entrée et retourne uniquement le premier nombre ou pourcentage spécifié de lignes, éventuellement en fonction d'un ordre de tri. La `Argument` colonne peut contenir une liste des colonnes pour lesquelles des liens sont vérifiés. Dans les plans de mise à jour, l'opérateur **Top** renforce les limites du nombre de lignes. **Top** est un opérateur logique et physique. **Top** est un opérateur logique et physique.|  
|None|**Top N Sort**|**Top n sort** est similaire à l' `Sort` itérateur, sauf que seules les *n* premières lignes sont nécessaires, et non l’intégralité du jeu de résultats. Pour de petites valeurs de *N*, le moteur d'exécution de requête de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] essaie de réaliser en mémoire la totalité de l'opération de tri. Pour des valeurs élevées de *N*, le moteur d'exécution de requête recourt à la méthode de tri plus générique, dans laquelle *N* n'est pas un paramètre.|  
|![Icône d’opérateur étendu (UDX)](../../2014/database-engine/media/udx-32x.gif "Icône d’opérateur étendu (UDX)")|`UDX`|Les opérateurs UDX (Extended Operators) implémentent l'une des nombreuses opérations XQuery et XPath dans [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Tous les opérateurs UDX sont des opérateurs logiques et physiques.<br /><br /> L'opérateur UDX `FOR XML` est utilisé pour sérialiser l'ensemble de lignes relationnelles qu'il entre dans une représentation XML dans une colonne BLOB dans une ligne de sortie. Il s'agit d'un opérateur d'agrégation XML qui tient compte de l'ordre.<br /><br /> L'opérateur UDX `XML SERIALIZER` est un opérateur d'agrégation XML qui tient compte de l'ordre. Il entre des lignes qui représentent des nœuds XML ou des valeurs scalaires XQuery dans un ordre de document XML et produit un objet BLOB XML sérialisé dans une colonne XML dans une ligne de sortie.<br /><br /> L'opérateur UDX `XML FRAGMENT SERIALIZER` est un type de `XML SERIALIZER` qui permet de traiter les lignes d'entrée représentant les fragments XML à insérer dans l'extension de modification de données d'insertion XQuery.<br /><br /> L'opérateur UDX `XQUERY STRING` évalue la valeur de la chaîne XQuery des lignes d'entrée représentant des nœuds XML. Il s'agit d'un opérateur d'agrégation de chaîne qui tient compte de l'ordre. Il produit une ligne avec des colonnes représentant la valeur scalaire XQuery qui contient la valeur de chaîne de l'entrée.<br /><br /> L'opérateur UDX `XQUERY LIST DECOMPOSER` est un opérateur de décomposition de liste XQuery. Pour chaque ligne d'entrée représentant un nœud XML, il produit une ou plusieurs lignes représentant chacune une valeur scalaire contenant une valeur d'élément de liste si le type d'entrée est une liste XSD.<br /><br /> L'opérateur UDX `XQUERY DATA` évalue la fonction XQuery fn:data() dans l'entrée représentant des nœuds XML. Il s'agit d'un opérateur d'agrégation de chaîne qui tient compte de l'ordre. Il produit une ligne avec des colonnes représentant la valeur scalaire XQuery qui contient le résultat de **fn:data()** .<br /><br /> L'opérateur UDX `XQUERY CONTAINS` évalue la fonction XQuery fn:contains() dans l'entrée représentant des nœuds XML. Il s'agit d'un opérateur d'agrégation de chaîne qui tient compte de l'ordre. Il produit une ligne avec des colonnes représentant la valeur scalaire XQuery qui contient le résultat de **fn:contains()** .<br /><br /> L’opérateur étendu `UPDATE XML NODE` met à jour le nœud XML dans l’extension de modification de données de remplacement XQuery dans la méthode **Modify ()** sur le type XML.|  
|None|**Union**|L'opérateur **Union** analyse plusieurs entrées en sortant chaque ligne analysée et en supprimant les doublons. **Union** est un opérateur logique.|  
|![Icône d’opérateur de mise à jour (moteur de base de données)](../../2014/database-engine/media/update-32x.gif "Icône d’opérateur de mise à jour (moteur de base de données)")|`Update`|L' `Update` opérateur met à jour chaque ligne de son entrée dans l’objet spécifié dans la `Argument` colonne du plan d’exécution de la requête. `Update` est un opérateur logique. L'opérateur physique est `Table Update`, `Index Update` ou `Clustered Index Update`.|  
|![Icône d’élément de langage While](../../2014/database-engine/media/while-32x.gif "Icône d’élément de langage While")|`While`|L'opérateur `While` implémente la boucle WHILE [!INCLUDE[tsql](../includes/tsql-md.md)]. `While`est un élément de langage|  
|![Icône d’opérateur Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icône d’opérateur Table Spool")|`Window Spool`|L'opérateur `Window Spool` développe chaque ligne dans un ensemble de lignes qui représente la fenêtre qui lui est associée. Dans une requête, la clause OVER définit la fenêtre dans un jeu de résultats de la requête et une fonction de fenêtre calcule ensuite une valeur pour chaque ligne de la fenêtre. `Window Spool` est un opérateur logique et physique.|  
  
  
