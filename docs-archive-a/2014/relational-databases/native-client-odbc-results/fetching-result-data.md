---
title: Extraction des données de résultat | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: rothja
ms.author: jroth
ms.openlocfilehash: 7eb038d431dd7f733c36e5913d72cdc6a161acad
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87709332"
---
# <a name="fetching-result-data"></a><span data-ttu-id="aadaf-102">Extraction des données de résultat</span><span class="sxs-lookup"><span data-stu-id="aadaf-102">Fetching Result Data</span></span>
  <span data-ttu-id="aadaf-103">Une application ODBC offre trois options pour l'extraction des données de résultat.</span><span class="sxs-lookup"><span data-stu-id="aadaf-103">An ODBC application has three options for fetching result data.</span></span>  
  
 <span data-ttu-id="aadaf-104">La première option est basée sur [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span><span class="sxs-lookup"><span data-stu-id="aadaf-104">The first option is based on [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span></span> <span data-ttu-id="aadaf-105">Avant de récupérer le jeu de résultats, l’application utilise **SQLBindCol** pour lier chaque colonne du jeu de résultats à une variable de programme.</span><span class="sxs-lookup"><span data-stu-id="aadaf-105">Before fetching the result set, the application uses **SQLBindCol** to bind each column in the result set to a program variable.</span></span> <span data-ttu-id="aadaf-106">Une fois les colonnes liées, le pilote transfère les données de la ligne actuelle dans les variables liées aux colonnes de l’ensemble de résultats chaque fois que l’application appelle **SQLFetch** ou [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span><span class="sxs-lookup"><span data-stu-id="aadaf-106">After the columns have been bound, the driver transfers the data of the current row into the variables bound to the result set columns each time the application calls **SQLFetch** or [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span></span> <span data-ttu-id="aadaf-107">Le pilote gère les conversions de données si la colonne du jeu de résultats et la variable de programme possèdent des types de données différents.</span><span class="sxs-lookup"><span data-stu-id="aadaf-107">The driver handles data conversions if the result set column and program variable have different data types.</span></span> <span data-ttu-id="aadaf-108">Si l’application a SQL_ATTR_ROW_ARRAY_SIZE défini sur une valeur supérieure à 1, elle peut lier des colonnes de résultats à des tableaux de variables, qui seront tous renseignés sur chaque appel à **SQLFetchScroll**.</span><span class="sxs-lookup"><span data-stu-id="aadaf-108">If the application has SQL_ATTR_ROW_ARRAY_SIZE set greater than 1, it can bind result columns to arrays of variables, which will all be filled on each call to **SQLFetchScroll**.</span></span>  
  
 <span data-ttu-id="aadaf-109">La deuxième option est basée sur [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span><span class="sxs-lookup"><span data-stu-id="aadaf-109">The second option is based on [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span></span> <span data-ttu-id="aadaf-110">L’application n’utilise pas **SQLBindCol** pour lier des colonnes de jeu de résultats à des variables de programme.</span><span class="sxs-lookup"><span data-stu-id="aadaf-110">The application does not use **SQLBindCol** to bind result set columns to program variables.</span></span> <span data-ttu-id="aadaf-111">Après chaque appel à **SQLFetch**, l’application appelle **SQLGetData** une fois pour chaque colonne du jeu de résultats.</span><span class="sxs-lookup"><span data-stu-id="aadaf-111">After each call to **SQLFetch**, the application calls **SQLGetData** once for each column in the result set.</span></span> <span data-ttu-id="aadaf-112">**SQLGetData** demande au pilote de transférer des données d’une colonne de jeu de résultats spécifique vers une variable de programme spécifique et spécifie les types de données de la colonne et de la variable.</span><span class="sxs-lookup"><span data-stu-id="aadaf-112">**SQLGetData** instructs the driver to transfer data from a specific result set column to a specific program variable and specifies the data types of the column and variable.</span></span> <span data-ttu-id="aadaf-113">Le pilote peut ainsi convertir des données si la colonne de résultat et la variable de programme possèdent des types de données différents.</span><span class="sxs-lookup"><span data-stu-id="aadaf-113">This allows the driver to convert data if the result column and program variable have different data types.</span></span> <span data-ttu-id="aadaf-114">Les colonnes **Text**, **ntext**et **image** sont généralement trop volumineuses pour tenir dans une variable de programme, mais elles peuvent toujours être récupérées à l’aide de **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="aadaf-114">**Text**, **ntext**, and **image** columns are typically too large to fit into a program variable but can still be retrieved using **SQLGetData**.</span></span> <span data-ttu-id="aadaf-115">Si les données **Text**, **ntext**ou **image** de la colonne de résultats sont plus volumineuses que la variable de programme, **SQLGetData** retourne SQL_SUCCESS_WITH_INFO et SQLSTATE 01004 (données de chaîne tronquées à droite).</span><span class="sxs-lookup"><span data-stu-id="aadaf-115">If the **text**, **ntext**, or **image** data in the result column is larger than the program variable, **SQLGetData** returns SQL_SUCCESS_WITH_INFO and SQLSTATE 01004 (string data, right truncated).</span></span> <span data-ttu-id="aadaf-116">Les appels successifs à **SQLGetData** retournent des blocs successifs des données **Text** ou **image** .</span><span class="sxs-lookup"><span data-stu-id="aadaf-116">Successive calls to **SQLGetData** return successive chunks of the **text** or **image** data.</span></span> <span data-ttu-id="aadaf-117">Lorsque la fin des données est atteinte, **SQLGetData** retourne SQL_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="aadaf-117">When the end of the data is reached, **SQLGetData** returns SQL_SUCCESS.</span></span> <span data-ttu-id="aadaf-118">Chaque extraction retourne un jeu de lignes, ou « ensemble de lignes », si SQL_ATTR_ROW_ARRAY_SIZE est supérieur à 1.</span><span class="sxs-lookup"><span data-stu-id="aadaf-118">Each fetch returns a set of rows, or rowset, if SQL_ATTR_ROW_ARRAY_SIZE is greater than 1.</span></span> <span data-ttu-id="aadaf-119">Avant d’utiliser **SQLGetData**, vous devez d’abord utiliser **SQLSetPos** pour spécifier une ligne spécifique dans l’ensemble de lignes en tant que ligne actuelle.</span><span class="sxs-lookup"><span data-stu-id="aadaf-119">Before using **SQLGetData**, you must first use **SQLSetPos** to specify a specific row within the rowset as the current row.</span></span>  
  
 <span data-ttu-id="aadaf-120">La troisième option consiste à utiliser une combinaison de **SQLBindCol** et **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="aadaf-120">The third option is to use a mix of **SQLBindCol** and **SQLGetData**.</span></span> <span data-ttu-id="aadaf-121">Une application peut, par exemple, lier les dix premières colonnes d’un jeu de résultats, puis, à chaque extraction, appeler **SQLGetData** trois fois pour extraire les données de trois colonnes indépendantes.</span><span class="sxs-lookup"><span data-stu-id="aadaf-121">An application could, for example, bind the first ten columns of a result set and then, on each fetch, call **SQLGetData** three times to retrieve the data from three unbound columns.</span></span> <span data-ttu-id="aadaf-122">Cela est généralement utilisé lorsqu’un jeu de résultats contient une ou plusieurs colonnes **Text** ou **image** .</span><span class="sxs-lookup"><span data-stu-id="aadaf-122">This would typically be used when a result set contains one or more **text** or **image** columns.</span></span>  
  
 <span data-ttu-id="aadaf-123">En fonction des options de curseur définies pour le jeu de résultats, une application peut également utiliser les options de défilement de **SQLFetchScroll** pour faire défiler le jeu de résultats.</span><span class="sxs-lookup"><span data-stu-id="aadaf-123">Depending on the cursor options set for the result set, an application can also use the scrolling options of **SQLFetchScroll** to scroll around the result set.</span></span>  
  
 <span data-ttu-id="aadaf-124">L’utilisation excessive de **SQLBindCol** pour lier une colonne de jeu de résultats à une variable de programme est coûteuse, car **SQLBindCol** force un pilote ODBC à allouer de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="aadaf-124">Excess use of **SQLBindCol** to bind a result set column to a program variable is expensive because **SQLBindCol** causes an ODBC driver to allocate memory.</span></span> <span data-ttu-id="aadaf-125">Lorsque vous liez une colonne de résultats à une variable, cette liaison reste en vigueur jusqu’à ce que vous appeliez [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) pour libérer le descripteur d’instruction ou que vous appeliez [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) avec *fOption* défini sur SQL_UNBIND.</span><span class="sxs-lookup"><span data-stu-id="aadaf-125">When you bind a result column to a variable, that binding remains in effect until you either call [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) to free the statement handle or call [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) with *fOption* set to SQL_UNBIND.</span></span> <span data-ttu-id="aadaf-126">Les liaisons ne sont pas automatiquement annulées à la fin de l'instruction.</span><span class="sxs-lookup"><span data-stu-id="aadaf-126">The bindings are not automatically undone when the statement completes.</span></span>  
  
 <span data-ttu-id="aadaf-127">Cette logique vous permet de gérer avec efficacité l'exécution à maintes reprises de la même instruction avec des paramètres différents.</span><span class="sxs-lookup"><span data-stu-id="aadaf-127">This logic allows you to effectively deal with executing the same SELECT statement several times with different parameters.</span></span> <span data-ttu-id="aadaf-128">Étant donné que le jeu de résultats conserve la même structure, vous pouvez lier le jeu de résultats une fois, traiter toutes les instructions SELECT, puis appeler **SQLFreeStmt** avec *fOption* défini sur SQL_UNBIND après la dernière exécution.</span><span class="sxs-lookup"><span data-stu-id="aadaf-128">Because the result set keeps the same structure, you can bind the result set once, process all the SELECT statements, then call **SQLFreeStmt** with *fOption* set to SQL_UNBIND after the last execution.</span></span> <span data-ttu-id="aadaf-129">Vous ne devez pas appeler **SQLBindCol** pour lier les colonnes d’un jeu de résultats sans appeler d’abord **SQLFreeStmt** avec *fOption* défini sur SQL_UNBIND pour libérer toutes les liaisons précédentes.</span><span class="sxs-lookup"><span data-stu-id="aadaf-129">You should not call **SQLBindCol** to bind the columns in a result set without first calling **SQLFreeStmt** with *fOption* set to SQL_UNBIND to free any previous bindings.</span></span>  
  
 <span data-ttu-id="aadaf-130">Lorsque vous utilisez **SQLBindCol**, vous pouvez effectuer une liaison selon les lignes ou selon les colonnes.</span><span class="sxs-lookup"><span data-stu-id="aadaf-130">When using **SQLBindCol**, you can either do row-wise or column-wise binding.</span></span> <span data-ttu-id="aadaf-131">La liaison selon les lignes est un tantinet plus rapide que la liaison selon les colonnes.</span><span class="sxs-lookup"><span data-stu-id="aadaf-131">Row-wise binding is somewhat faster than column-wise binding.</span></span>  
  
 <span data-ttu-id="aadaf-132">Vous pouvez utiliser **SQLGetData** pour récupérer des données colonne par colonne au lieu de lier des colonnes de jeu de résultats à l’aide de **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="aadaf-132">You can use **SQLGetData** to retrieve data on a column-by-column basis instead of binding result set columns using **SQLBindCol**.</span></span> <span data-ttu-id="aadaf-133">Si un jeu de résultats contient uniquement quelques lignes, l’utilisation de **SQLGetData** au lieu de **SQLBindCol** est plus rapide. dans le cas contraire, **SQLBindCol** offre les meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="aadaf-133">If a result set contains only a few rows, using **SQLGetData** instead of **SQLBindCol** is faster; otherwise, **SQLBindCol** gives the best performance.</span></span> <span data-ttu-id="aadaf-134">Si vous ne placez pas toujours les données dans le même ensemble de variables, vous devez utiliser **SQLGetData** au lieu de relier constamment.</span><span class="sxs-lookup"><span data-stu-id="aadaf-134">If you do not always put the data in the same set of variables, you should use **SQLGetData** instead of constantly rebinding.</span></span> <span data-ttu-id="aadaf-135">Vous pouvez uniquement utiliser **SQLGetData** sur les colonnes qui figurent dans la liste de sélection une fois toutes les colonnes liées à **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="aadaf-135">You can only use **SQLGetData** on columns that are in the select list after all columns are bound with **SQLBindCol**.</span></span> <span data-ttu-id="aadaf-136">La colonne doit également apparaître après toutes les colonnes sur lesquelles vous avez déjà utilisé **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="aadaf-136">The column must also appear after any columns on which you have already used **SQLGetData**.</span></span>  
  
 <span data-ttu-id="aadaf-137">Les fonctions ODBC qui gèrent le déplacement des données dans ou hors des variables de programme, telles que **SQLGetData**, **SQLBindCol**et [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), prennent en charge la conversion de type de données implicite.</span><span class="sxs-lookup"><span data-stu-id="aadaf-137">The ODBC functions that deal with moving data into or out of program variables, such as **SQLGetData**, **SQLBindCol**, and [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), support implicit data type conversion.</span></span> <span data-ttu-id="aadaf-138">Par exemple, si une application lie une colonne d'entiers à une variable de programme de chaîne de caractères, le pilote convertit automatiquement les données d'entier en caractère avant de les insérer dans la variable de programme.</span><span class="sxs-lookup"><span data-stu-id="aadaf-138">For example, if an application binds an integer column to a character string program variable, the driver automatically converts the data from integer to character before placing it into the program variable.</span></span>  
  
 <span data-ttu-id="aadaf-139">La conversion de données dans les applications doit être réduite.</span><span class="sxs-lookup"><span data-stu-id="aadaf-139">Data conversion in applications should be minimized.</span></span> <span data-ttu-id="aadaf-140">À moins que la conversion de données ne soit nécessaire pour le traitement pris en charge par l'application, les applications doivent lier les colonnes et les paramètres à des variables de programme du même type de données.</span><span class="sxs-lookup"><span data-stu-id="aadaf-140">Unless data conversion is required for the processing done by the application, applications should bind columns and parameters to program variables of the same data type.</span></span> <span data-ttu-id="aadaf-141">En revanche, si les données doivent être converties d'un type à un autre, il est plus efficace de confier la conversion au pilote plutôt que de l'effectuer dans l'application.</span><span class="sxs-lookup"><span data-stu-id="aadaf-141">If the data must be converted from one type to another, however, it is more efficient to have the driver do the conversion than doing it in the application.</span></span> <span data-ttu-id="aadaf-142">Normalement, le pilote ODBC [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client se contente de transférer directement les données des tampons réseau vers les variables de l'application.</span><span class="sxs-lookup"><span data-stu-id="aadaf-142">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver normally just transfers data directly from the network buffers to the variables of the application.</span></span> <span data-ttu-id="aadaf-143">En confiant la conversion des données au pilote, vous forcez ce dernier à mettre les données en mémoire tampon et à les convertir au moyen de cycles processeur.</span><span class="sxs-lookup"><span data-stu-id="aadaf-143">Requesting the driver to do data conversion forces the driver to buffer the data and use CPU cycles to convert the data.</span></span>  
  
 <span data-ttu-id="aadaf-144">Les variables de programme doivent être suffisamment volumineuses pour contenir les données transférées à partir d’une colonne, à l’exception des données **Text**, **ntext**et **image** .</span><span class="sxs-lookup"><span data-stu-id="aadaf-144">Program variables should be large enough to hold data transferred in from a column, except for **text**, **ntext**, and **image** data.</span></span> <span data-ttu-id="aadaf-145">Si une application tente d'extraire les données d'un jeu de résultats et de les placer dans une variable trop petite pour les contenir, le pilote émet un avertissement.</span><span class="sxs-lookup"><span data-stu-id="aadaf-145">If an application attempts to retrieve result set data and place it into a variable that is too small to hold it, the driver generates a warning.</span></span> <span data-ttu-id="aadaf-146">Cette opération contraint le pilote à allouer de la mémoire pour le message et le pilote et l'application doivent tous les deux utiliser des cycles processeur pour traiter le message et gérer les erreurs.</span><span class="sxs-lookup"><span data-stu-id="aadaf-146">This forces the driver to allocate memory for the message, and the driver and application both have to spend CPU cycles processing the message and doing error handling.</span></span> <span data-ttu-id="aadaf-147">L'application doit soit allouer une variable suffisamment grande pour accueillir les données extraites, soit faire appel à la fonction SUBSTRING dans la liste de sélection pour réduire la taille de la colonne au sein du jeu de résultats.</span><span class="sxs-lookup"><span data-stu-id="aadaf-147">The application should either allocate a variable large enough to hold the data being retrieved or use the SUBSTRING function in the select list to reduce the size of the column in the result set.</span></span>  
  
 <span data-ttu-id="aadaf-148">Soyez vigilant lorsque vous utilisez SQL_C_DEFAULT pour définir le type de la variable C.</span><span class="sxs-lookup"><span data-stu-id="aadaf-148">Care must be taken when using SQL_C_DEFAULT to specify the type of the C variable.</span></span> <span data-ttu-id="aadaf-149">SQL_C_DEFAULT spécifie que le type de la variable C correspond au type de données SQL de la colonne ou du paramètre.</span><span class="sxs-lookup"><span data-stu-id="aadaf-149">SQL_C_DEFAULT specifies that the type of the C variable matches the SQL data type of the column or parameter.</span></span> <span data-ttu-id="aadaf-150">Si SQL_C_DEFAULT est spécifié pour une colonne **ntext**, **nchar**ou **nvarchar** , les données Unicode sont retournées à l’application.</span><span class="sxs-lookup"><span data-stu-id="aadaf-150">If SQL_C_DEFAULT is specified for an **ntext**, **nchar**, or **nvarchar** column, Unicode data is returned to the application.</span></span> <span data-ttu-id="aadaf-151">Ceci peut entraîner divers problèmes si l'application n'a pas été codée pour gérer des données Unicode.</span><span class="sxs-lookup"><span data-stu-id="aadaf-151">This can cause various problems if the application has not been coded to handle Unicode data.</span></span> <span data-ttu-id="aadaf-152">Les mêmes types de problèmes peuvent se produire avec le type de données **uniqueidentifier** (SQL_GUID).</span><span class="sxs-lookup"><span data-stu-id="aadaf-152">The same types of problems can occur with the **uniqueidentifier** (SQL_GUID) data type.</span></span>  
  
 <span data-ttu-id="aadaf-153">les données **Text**, **ntext**et **image** sont généralement trop volumineuses pour tenir dans une seule variable de programme, et sont généralement traitées avec **SQLGetData** au lieu de **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="aadaf-153">**text**, **ntext**, and **image** data is typically too large to fit into a single program variable, and is usually processed with **SQLGetData** instead of **SQLBindCol**.</span></span> <span data-ttu-id="aadaf-154">Lors de l’utilisation de curseurs côté serveur, le [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] pilote ODBC Native Client est optimisé pour ne pas transmettre les données des colonnes non liées **Text**, **ntext**ou **image** au moment où la ligne est extraite.</span><span class="sxs-lookup"><span data-stu-id="aadaf-154">When using server cursors, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver is optimized to not transmit the data for unbound **text**, **ntext**, or **image** columns at the time the row is fetched.</span></span> <span data-ttu-id="aadaf-155">Les données **Text**, **ntext**ou **image** ne sont pas réellement récupérées à partir du serveur tant que l’application n’émet pas **SQLGetData** pour la colonne.</span><span class="sxs-lookup"><span data-stu-id="aadaf-155">The **text**, **ntext**, or **image** data is not actually retrieved from the server until the application issues **SQLGetData** for the column.</span></span>  
  
 <span data-ttu-id="aadaf-156">Cette optimisation peut être appliquée aux applications afin qu’aucune donnée **Text**, **ntext**ou **image** ne soit affichée pendant qu’un utilisateur fait défiler un curseur.</span><span class="sxs-lookup"><span data-stu-id="aadaf-156">This optimization can be applied to applications so that no **text**, **ntext**, or **image** data is displayed while a user is scrolling up and down a cursor.</span></span> <span data-ttu-id="aadaf-157">Une fois que l’utilisateur a sélectionné une ligne, l’application peut appeler **SQLGetData** pour extraire les données **Text**, **ntext**ou **image** .</span><span class="sxs-lookup"><span data-stu-id="aadaf-157">After the user selects a row, the application can call **SQLGetData** to retrieve the **text**, **ntext**, or **image** data.</span></span> <span data-ttu-id="aadaf-158">Cela permet d’économiser la transmission des données **Text**, **ntext**ou **image** pour les lignes que l’utilisateur ne sélectionne pas et peut enregistrer la transmission de très grandes quantités de données.</span><span class="sxs-lookup"><span data-stu-id="aadaf-158">This saves transmitting the **text**, **ntext**, or **image** data for any of the rows the user does not select and can save the transmission of very large amounts of data.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="aadaf-159">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="aadaf-159">See Also</span></span>  
 [<span data-ttu-id="aadaf-160">Traitement des résultats &#40;ODBC&#41;</span><span class="sxs-lookup"><span data-stu-id="aadaf-160">Processing Results &#40;ODBC&#41;</span></span>](processing-results-odbc.md)  
  
  
