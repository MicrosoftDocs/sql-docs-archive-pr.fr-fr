---
title: Développement de composants de flux de données avec plusieurs entrées | Microsoft Docs
ms.custom: ''
ms.date: 04/27/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: integration-services
ms.topic: reference
ms.assetid: 3c7b50e8-2aa6-4f6a-8db4-e8293bc21027
author: chugugrace
ms.author: chugu
ms.openlocfilehash: fb56878c1b1b68dfdc4de19cb2b811de494c761b
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/04/2020
ms.locfileid: "87705312"
---
# <a name="developing-data-flow-components-with-multiple-inputs"></a><span data-ttu-id="6a3af-102">Développement de composants de flux de données avec plusieurs entrées</span><span class="sxs-lookup"><span data-stu-id="6a3af-102">Developing Data Flow Components with Multiple Inputs</span></span>
  <span data-ttu-id="6a3af-103">Un composant de flux de données avec plusieurs entrées peut consommer excessivement de la mémoire si ses entrées multiples produisent des données à des taux irréguliers.</span><span class="sxs-lookup"><span data-stu-id="6a3af-103">A data flow component with multiple inputs may consume excessive memory if its multiple inputs produce data at uneven rates.</span></span> <span data-ttu-id="6a3af-104">Lorsque vous développez un composant de flux de données personnalisé qui prend en charge plusieurs entrées, vous pouvez gérer cette sollicitation de la mémoire en utilisant les membres suivants dans l’espace de noms Microsoft.SqlServer.Dts.Pipeline :</span><span class="sxs-lookup"><span data-stu-id="6a3af-104">When you develop a custom data flow component that supports two or more inputs, you can manage this memory pressure by using the following members in the Microsoft.SqlServer.Dts.Pipeline namespace:</span></span>  
  
-   <span data-ttu-id="6a3af-105">La propriété <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> de la classe <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute>.</span><span class="sxs-lookup"><span data-stu-id="6a3af-105">The <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> property of the <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute> class.</span></span> <span data-ttu-id="6a3af-106">Définissez la valeur de cette propriété à `true` si vous souhaitez implémenter le code qui est nécessaire pour votre composant de flux de données personnalisé afin de gérer des données qui s'écoulent à des taux irréguliers.</span><span class="sxs-lookup"><span data-stu-id="6a3af-106">Set the value of this property to `true` if you want to implement the code that is necessary for your custom data flow component to manage data flowing at uneven rates.</span></span>  
  
-   <span data-ttu-id="6a3af-107">La méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> de la classe <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent>.</span><span class="sxs-lookup"><span data-stu-id="6a3af-107">The <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> method of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent> class.</span></span> <span data-ttu-id="6a3af-108">Vous devez fournir une implémentation de cette méthode si vous définissez la propriété <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> à `true`.</span><span class="sxs-lookup"><span data-stu-id="6a3af-108">You must provide an implementation of this method if you set the <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> property to `true`.</span></span> <span data-ttu-id="6a3af-109">Si vous ne fournissez pas d'implémentation, le moteur de flux de données lève une exception au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="6a3af-109">If you do not provide an implementation, the data flow engine raises an exception at run time.</span></span>  
  
-   <span data-ttu-id="6a3af-110">La méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> de la classe <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent>.</span><span class="sxs-lookup"><span data-stu-id="6a3af-110">The <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> method of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent> class.</span></span> <span data-ttu-id="6a3af-111">Vous devez également fournir une implémentation de cette méthode si vous définissez la propriété <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> à `true` et que votre composant personnalisé prend en charge plusieurs entrées.</span><span class="sxs-lookup"><span data-stu-id="6a3af-111">You must also provide an implementation of this method if you set the <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> property to `true` and your custom component supports more than two inputs.</span></span> <span data-ttu-id="6a3af-112">Si vous ne fournissez pas d'implémentation, le moteur de flux de données lève une exception au moment de l'exécution si l'utilisateur joint plusieurs entrées.</span><span class="sxs-lookup"><span data-stu-id="6a3af-112">If you do not provide an implementation, the data flow engine raises an exception at run time if the user attaches more than two inputs.</span></span>  
  
 <span data-ttu-id="6a3af-113">Ces deux membres vous permettent de développer une solution pour la sollicitation de la mémoire qui est semblable à la solution que Microsoft a développée pour les transformations de fusion et de jointure de la fusion.</span><span class="sxs-lookup"><span data-stu-id="6a3af-113">Together, these members enable you to develop a solution for memory pressure that is similar to the solution that Microsoft developed for the Merge and Merge Join transformations.</span></span>  
  
## <a name="setting-the-supportsbackpressure-property"></a><span data-ttu-id="6a3af-114">Définition de la propriété SupportsBackPressure</span><span class="sxs-lookup"><span data-stu-id="6a3af-114">Setting the SupportsBackPressure Property</span></span>  
 <span data-ttu-id="6a3af-115">La première étape pour l'implémentation d'une meilleure gestion de la mémoire pour un composant de flux de données personnalisé qui prend en charge plusieurs entrées consiste à définir la valeur de la propriété <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> à `true` dans le <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute>.</span><span class="sxs-lookup"><span data-stu-id="6a3af-115">The first step in implementing better memory management for a custom data flow component that supports multiple inputs is to set the value of the <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> property to `true` in the <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute>.</span></span> <span data-ttu-id="6a3af-116">Lorsque la valeur de <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> est `true`, le moteur de flux de données appelle la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> et, lorsqu'il y a plusieurs entrées, il appelle également la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="6a3af-116">When the value of <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> is `true`, the data flow engine calls the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> method and, when there are more than two inputs, also calls the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> method at run time.</span></span>  
  
### <a name="example"></a><span data-ttu-id="6a3af-117">Exemple</span><span class="sxs-lookup"><span data-stu-id="6a3af-117">Example</span></span>  
 <span data-ttu-id="6a3af-118">Dans l'exemple suivant, l'implémentation du <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute> définit la valeur de <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> à `true`.</span><span class="sxs-lookup"><span data-stu-id="6a3af-118">In the following example, the implementation of the <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute> sets the value of <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> to `true`.</span></span>  
  
```csharp  
[DtsPipelineComponent(ComponentType = ComponentType.Transform,  
        DisplayName = "Shuffler",  
        Description = "Shuffle the rows from input.",  
        SupportsBackPressure = true,  
        LocalizationType = typeof(Localized),  
        IconResource = "Microsoft.Samples.SqlServer.Dts.MIBPComponent.ico")  
]  
public class Shuffler : Microsoft.SqlServer.Dts.Pipeline.PipelineComponent  
        {  
          ...  
        }  
```  
  
## <a name="implementing-the-isinputready-method"></a><span data-ttu-id="6a3af-119">Implémentation de la méthode IsInputReady</span><span class="sxs-lookup"><span data-stu-id="6a3af-119">Implementing the IsInputReady Method</span></span>  
 <span data-ttu-id="6a3af-120">Lorsque vous définissez la valeur de la propriété <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> à `true` dans l'objet <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute>, vous devez également fournir une implémentation pour la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> de la classe <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent>.</span><span class="sxs-lookup"><span data-stu-id="6a3af-120">When you set the value of the <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute.SupportsBackPressure%2A> property to `true` in the <xref:Microsoft.SqlServer.Dts.Pipeline.DtsPipelineComponentAttribute> object, you must also provide an implementation for the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> method of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent> class.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6a3af-121">Votre implémentation de la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> ne doit pas appeler les implémentations dans la classe de base.</span><span class="sxs-lookup"><span data-stu-id="6a3af-121">Your implementation of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> method should not call the implementations in the base class.</span></span> <span data-ttu-id="6a3af-122">L'implémentation par défaut de cette méthode dans la classe de base lève simplement une `NotImplementedException`.</span><span class="sxs-lookup"><span data-stu-id="6a3af-122">The default implementation of this method in the base class simply raises a `NotImplementedException`.</span></span>  
  
 <span data-ttu-id="6a3af-123">Lorsque vous implémentez cette méthode, vous définissez l’état d’un élément dans le tableau booléen *canProcess* pour chacune des entrées du composant.</span><span class="sxs-lookup"><span data-stu-id="6a3af-123">When you implement this method, you set the status of an element in the Boolean *canProcess* array for each of the component's inputs.</span></span> <span data-ttu-id="6a3af-124">(Les entrées sont identifiées par leurs valeurs d’ID dans le tableau *inputIDs* .) Lorsque vous définissez la valeur d’un élément dans le tableau *canProcess* sur `true` pour une entrée, le moteur de workflow appelle la méthode du composant <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.ProcessInput%2A> et fournit davantage de données pour l’entrée spécifiée.</span><span class="sxs-lookup"><span data-stu-id="6a3af-124">(The inputs are identified by their ID values in the *inputIDs* array.) When you set the value of an element in the *canProcess* array to `true` for an input, the data flow engine calls the component's <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.ProcessInput%2A> method and provides more data for the specified input.</span></span>  
  
 <span data-ttu-id="6a3af-125">Alors que davantage de données en amont sont disponibles, la valeur de l’élément de tableau *canProcess* pour au moins une entrée doit toujours être `true` , sinon le traitement s’arrête.</span><span class="sxs-lookup"><span data-stu-id="6a3af-125">While more upstream data is available, the value of the *canProcess* array element for at least one input must always be `true`, or processing stops.</span></span>  
  
 <span data-ttu-id="6a3af-126">Le moteur de flux de données appelle la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> avant d'envoyer chaque mémoire tampon de données pour  déterminer quelles entrées attendent de recevoir d'autres données.</span><span class="sxs-lookup"><span data-stu-id="6a3af-126">The data flow engine calls the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> method before sending each buffer of data to determine which inputs are waiting to receive more data.</span></span> <span data-ttu-id="6a3af-127">Lorsque la valeur de retour indique qu'une entrée est bloquée, le moteur de flux de données met temporairement en cache les mémoires tampon supplémentaires de données pour cette entrée au lieu de les envoyer au composant.</span><span class="sxs-lookup"><span data-stu-id="6a3af-127">When the return value indicates that an input is blocked, the data flow engine temporarily caches additional buffers of data for that input instead of sending them to the component.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6a3af-128">Vous n'appelez pas les méthodes <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> ou <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> dans votre propre code.</span><span class="sxs-lookup"><span data-stu-id="6a3af-128">You do not call the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> or <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> methods in your own code.</span></span> <span data-ttu-id="6a3af-129">Le moteur de flux de données appelle ces méthodes, et les autres méthodes de la classe `PipelineComponent` que vous remplacez, lorsque le moteur de flux de données exécute votre composant.</span><span class="sxs-lookup"><span data-stu-id="6a3af-129">The data flow engine calls these methods, and the other methods of the `PipelineComponent` class that you override, when the data flow engine runs your component.</span></span>  
  
### <a name="example"></a><span data-ttu-id="6a3af-130">Exemple</span><span class="sxs-lookup"><span data-stu-id="6a3af-130">Example</span></span>  
 <span data-ttu-id="6a3af-131">Dans l'exemple suivant, l'implémentation de la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> indique qu'une entrée attend pour recevoir plus de données lorsque les conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="6a3af-131">In the following example, the implementation of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> method indicates that an input is waiting to receive more data when the following conditions are true:</span></span>  
  
-   <span data-ttu-id="6a3af-132">Plus de données en amont sont disponibles pour l'entrée (`!inputEOR`).</span><span class="sxs-lookup"><span data-stu-id="6a3af-132">More upstream data is available for the input (`!inputEOR`).</span></span>  
  
-   <span data-ttu-id="6a3af-133">Le composant n'a pas actuellement de données disponibles pour traiter l'entrée dans les mémoires tampon que le composant a déjà reçues (`inputBuffers[inputIndex].CurrentRow() == null`).</span><span class="sxs-lookup"><span data-stu-id="6a3af-133">The component does not currently have data available to process for the input in the buffers that the component has already received (`inputBuffers[inputIndex].CurrentRow() == null`).</span></span>  
  
 <span data-ttu-id="6a3af-134">Si une entrée attend de recevoir plus de données, le composant de transmission de données indique cela en définissant sur `true` la valeur de l’élément dans le tableau *canProcess* qui correspond à cette entrée.</span><span class="sxs-lookup"><span data-stu-id="6a3af-134">If an input is waiting to receive more data, the data flow component indicates this by setting to `true` the value of the element in the *canProcess* array that corresponds to that input.</span></span>  
  
 <span data-ttu-id="6a3af-135">Inversement, lorsque le composant a encore des données disponibles à traiter pour l'entrée, l'exemple interrompt le traitement de l'entrée.</span><span class="sxs-lookup"><span data-stu-id="6a3af-135">Conversely, when the component still has data available to process for the input, the example suspends the processing of the input.</span></span> <span data-ttu-id="6a3af-136">L’exemple fait cela en définissant sur `false` la valeur de l’élément dans le tableau *canProcess* qui correspond à cette entrée.</span><span class="sxs-lookup"><span data-stu-id="6a3af-136">The example does this by setting to `false` the value of the element in the *canProcess* array that corresponds to that input.</span></span>  
  
```csharp  
public override void IsInputReady(int[] inputIDs, ref bool[] canProcess)  
{  
    for (int i = 0; i < inputIDs.Length; i++)  
    {  
        int inputIndex = ComponentMetaData.InputCollection.GetObjectIndexByID(inputIDs[i]);  
  
        canProcess[i] = (inputBuffers[inputIndex].CurrentRow() == null)  
            && !inputEOR[inputIndex];  
    }  
}  
```  
  
 <span data-ttu-id="6a3af-137">L'exemple précédent utilise le tableau `inputEOR` booléen pour indiquer si davantage de données en amont sont disponibles pour chaque entrée.</span><span class="sxs-lookup"><span data-stu-id="6a3af-137">The preceding example uses the Boolean `inputEOR` array to indicate whether more upstream data is available for each input.</span></span> <span data-ttu-id="6a3af-138">`EOR` dans le nom du tableau représente « fin d'ensemble de lignes » et fait référence à la propriété <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineBuffer.EndOfRowset%2A> de mémoires tampon de flux de données.</span><span class="sxs-lookup"><span data-stu-id="6a3af-138">`EOR` in the name of the array represents "end of rowset" and refers to the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineBuffer.EndOfRowset%2A> property of data flow buffers.</span></span> <span data-ttu-id="6a3af-139">Dans une partie de l'exemple qui n'est pas inclus ici, la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.ProcessInput%2A> vérifie la valeur de la propriété <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineBuffer.EndOfRowset%2A> pour chaque mémoire tampon des données qu'elle reçoit.</span><span class="sxs-lookup"><span data-stu-id="6a3af-139">In a portion of the example that is not included here, the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.ProcessInput%2A> method checks the value of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineBuffer.EndOfRowset%2A> property for each buffer of data that it receives.</span></span> <span data-ttu-id="6a3af-140">Lorsqu'une valeur `true` indique que plus aucune donnée en amont n'est disponible pour une entrée, l'exemple définit la valeur de l'élément de tableau `inputEOR` pour cette entrée à `true`.</span><span class="sxs-lookup"><span data-stu-id="6a3af-140">When a value of `true` indicates that there is no more upstream data available for an input, the example sets the value of the `inputEOR` array element for that input to `true`.</span></span> <span data-ttu-id="6a3af-141">Cet exemple de la <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> méthode définit la valeur de l’élément correspondant dans le tableau *canProcess* sur `false` pour une entrée lorsque la valeur de l' `inputEOR` élément de tableau indique qu’il n’y a plus de données en amont disponibles pour l’entrée.</span><span class="sxs-lookup"><span data-stu-id="6a3af-141">This example of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> method sets the value of the corresponding element in the *canProcess* array to `false` for an input when the value of the `inputEOR` array element indicates that there is no more upstream data available for the input.</span></span>  
  
## <a name="implementing-the-getdependentinputs-method"></a><span data-ttu-id="6a3af-142">Implémentation de la méthode GetDependentInputs</span><span class="sxs-lookup"><span data-stu-id="6a3af-142">Implementing the GetDependentInputs Method</span></span>  
 <span data-ttu-id="6a3af-143">Lorsque votre composant de flux de données personnalisé prend en charge plus de deux entrées, vous devez également fournir une implémentation pour la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> de la classe <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent>.</span><span class="sxs-lookup"><span data-stu-id="6a3af-143">When your custom data flow component supports more than two inputs, you must also provide an implementation for the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> method of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent> class.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6a3af-144">Votre implémentation de la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> ne doit pas appeler les implémentations dans la classe de base.</span><span class="sxs-lookup"><span data-stu-id="6a3af-144">Your implementation of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> method should not call the implementations in the base class.</span></span> <span data-ttu-id="6a3af-145">L'implémentation par défaut de cette méthode dans la classe de base lève simplement une `NotImplementedException`.</span><span class="sxs-lookup"><span data-stu-id="6a3af-145">The default implementation of this method in the base class simply raises a `NotImplementedException`.</span></span>  
  
 <span data-ttu-id="6a3af-146">Le moteur de flux de données appelle seulement la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> lorsque l'utilisateur joint plus de deux entrées au composant.</span><span class="sxs-lookup"><span data-stu-id="6a3af-146">The data flow engine only calls the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> method when the user attaches more than two inputs to the component.</span></span> <span data-ttu-id="6a3af-147">Lorsqu’un composant a uniquement deux entrées, et <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> que la méthode indique qu’une entrée est bloquée (*canProcess*  =  `false` ), le moteur de workflow sait que l’autre entrée attend de recevoir plus de données.</span><span class="sxs-lookup"><span data-stu-id="6a3af-147">When a component has only two inputs, and the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> method indicates that one input is blocked (*canProcess* = `false`), the data flow engine knows that the other input is waiting to receive more data.</span></span> <span data-ttu-id="6a3af-148">Toutefois, lorsqu'il y a plus de deux entrées, et que la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> indique qu'une entrée est bloquée, le code supplémentaire dans le <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> identifie quelles entrées attendent de recevoir plus de données.</span><span class="sxs-lookup"><span data-stu-id="6a3af-148">However, when there are more than two inputs, and the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> method indicates that one input is blocked, the additional code in the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> identifies which inputs are waiting to receive more data.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="6a3af-149">Vous n'appelez pas les méthodes <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> ou <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> dans votre propre code.</span><span class="sxs-lookup"><span data-stu-id="6a3af-149">You do not call the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.IsInputReady%2A> or <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> methods in your own code.</span></span> <span data-ttu-id="6a3af-150">Le moteur de flux de données appelle ces méthodes, et les autres méthodes de la classe `PipelineComponent` que vous remplacez, lorsque le moteur de flux de données exécute votre composant.</span><span class="sxs-lookup"><span data-stu-id="6a3af-150">The data flow engine calls these methods, and the other methods of the `PipelineComponent` class that you override, when the data flow engine runs your component.</span></span>  
  
### <a name="example"></a><span data-ttu-id="6a3af-151">Exemple</span><span class="sxs-lookup"><span data-stu-id="6a3af-151">Example</span></span>  
 <span data-ttu-id="6a3af-152">Pour une entrée spécifique bloquée, l'implémentation suivante de la méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> retourne une collection des entrées qui attendent de recevoir plus de données et par conséquent bloque l'entrée spécifiée.</span><span class="sxs-lookup"><span data-stu-id="6a3af-152">For a specific input that is blocked, the following implementation of the <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> method returns a collection of the inputs that are waiting to receive more data, and are therefore blocking the specified input.</span></span> <span data-ttu-id="6a3af-153">Le composant identifie les entrées bloquantes en recherchant d'autres entrées que celle qui est bloquée qui n'ont pas actuellement de données disponibles pour traiter dans les mémoires tampon que le composant a déjà reçues (`inputBuffers[i].CurrentRow() == null`).</span><span class="sxs-lookup"><span data-stu-id="6a3af-153">The component identifies the blocking inputs by checking for inputs other than the blocked input that do not currently have data available to process in the buffers that the component has already received (`inputBuffers[i].CurrentRow() == null`).</span></span> <span data-ttu-id="6a3af-154">La méthode <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> retourne ensuite la collection d'entrées bloquantes comme une collection d'ID d'entrée.</span><span class="sxs-lookup"><span data-stu-id="6a3af-154">The <xref:Microsoft.SqlServer.Dts.Pipeline.PipelineComponent.GetDependentInputs%2A> method then returns the collection of blocking inputs as a collection of input IDs.</span></span>  
  
```csharp  
public override Collection<int> GetDependentInputs(int blockedInputID)  
{  
    Collection<int> currentDependencies = new Collection<int>();  
    for (int i = 0; i < ComponentMetaData.InputCollection.Count; i++)  
    {  
        if (ComponentMetaData.InputCollection[i].ID != blockedInputID  
            && inputBuffers[i].CurrentRow() == null)  
        {  
            currentDependencies.Add(ComponentMetaData.InputCollection[i].ID);  
        }  
    }  
  
    return currentDependencies;  
}  
```  
  
  
